/**
 * @license
 * KLineChart v8.2.0
 * Copyright (c) 2019 lihu.
 * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0
 */
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.klinecharts = {}));
})(this, (function (exports) { 'use strict';

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var extension = {
  technicalIndicatorExtensions: {},
  shapeExtensions: {},
  addTechnicalIndicatorTemplate: function addTechnicalIndicatorTemplate(template) {
    var _this = this;

    if (template) {
      [].concat(template).forEach(function (tmp) {
        if (tmp.name) {
          _this.technicalIndicatorExtensions[tmp.name] = tmp;
        }
      });
    }
  },
  addShapeTemplate: function addShapeTemplate(template) {
    var _this2 = this;

    if (template) {
      [].concat(template).forEach(function (tmp) {
        if (tmp.name) {
          _this2.shapeExtensions[tmp.name] = tmp;
        }
      });
    }
  }
};

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }

      return desc.value;
    };
  }

  return _get.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * åˆå¹¶
 * @param target
 * @param source
 */
function merge(target, source) {
  if (!isObject(target) || !isObject(source)) {
    return;
  }

  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key) && key in target) {
      var targetProp = target[key];
      var sourceProp = source[key];

      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp)) {
        merge(targetProp, sourceProp);
      } else {
        if (isValid(source[key])) {
          target[key] = source[key];
        }
      }
    }
  }
}
/**
 * å…‹éš†
 * @param target
 * @return {{}|*}
 */

function clone(target) {
  if (!isObject(target)) {
    return target;
  }

  var copy;

  if (isArray(target)) {
    copy = [];
  } else {
    copy = {};
  }

  for (var key in target) {
    if (Object.prototype.hasOwnProperty.call(target, key)) {
      var v = target[key];

      if (isObject(v)) {
        copy[key] = clone(v);
      } else {
        copy[key] = v;
      }
    }
  }

  return copy;
}
/**
 * æ˜¯å¦æ˜¯æ•°ç»„
 * @param value
 * @return {boolean}
 */

function isArray(value) {
  return Object.prototype.toString.call(value) === '[object Array]';
}
/**
 * æ˜¯å¦æ˜¯æ–¹æ³•
 * @param {*} value
 * @return {boolean}
 */

function isFunction(value) {
  return value && typeof value === 'function';
}
/**
 * æ˜¯å¦æ˜¯å¯¹è±¡
 * @param {*} value
 * @return {boolean}
 */

function isObject(value) {
  return !!value && _typeof(value) === 'object';
}
/**
 * åˆ¤æ–­æ˜¯å¦æ˜¯æ•°å­—
 * @param value
 * @returns {boolean}
 */

function isNumber(value) {
  return typeof value === 'number' && !isNaN(value);
}
/**
 * åˆ¤æ–­æ˜¯å¦æœ‰æ•ˆ
 * @param value
 * @returns {boolean}
 */

function isValid(value) {
  return value !== null && value !== undefined;
}
/**
 * åˆ¤æ–­æ˜¯å¦æ˜¯boolean
 * @param value
 * @returns {boolean}
 */

function isBoolean(value) {
  return typeof value === 'boolean';
}
/**
 * æ˜¯å¦æ˜¯å­—ç¬¦ä¸²
 * @param value
 * @return {boolean}
 */

function isString(value) {
  return typeof value === 'string';
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * å¡«å……ç©ºå¿ƒæ ·å¼ç±»å‹
 */
var StrokeFillStyle = {
  STROKE: 'stroke',
  FILL: 'fill'
};
/**
 * çº¿çš„æ ·å¼
 * @type {{DASH: string, SOLID: string}}
 */

var LineStyle = {
  DASH: 'dash',
  SOLID: 'solid'
};
/**
 * yè½´ä½ç½®
 * @type {{LEFT: string, RIGHT: string}}
 */

var YAxisPosition = {
  LEFT: 'left',
  RIGHT: 'right'
};
/**
 * yè½´ç±»å‹
 * @type {{PERCENTAGE: string, NORMAL: string}}
 */

var YAxisType = {
  NORMAL: 'normal',
  PERCENTAGE: 'percentage',
  LOG: 'log'
};
/**
 * èœ¡çƒ›å›¾æ ·å¼
 * @type {{AREA: string, OHLC: string, CANDLE_STROKE: string, CANDLE_SOLID: string, CANDLE_DOWN_STROKE: string, CANDLE_UP_STROKE: string}}
 */

var CandleType = {
  CANDLE_SOLID: 'candle_solid',
  CANDLE_STROKE: 'candle_stroke',
  CANDLE_UP_STROKE: 'candle_up_stroke',
  CANDLE_DOWN_STROKE: 'candle_down_stroke',
  OHLC: 'ohlc',
  AREA: 'area'
};
/**
 * è¯´æ˜æ˜¾ç¤ºè§„åˆ™
 * @type {{FOLLOW_CROSS: string, NONE: string, ALWAYS: string}}
 */

var TooltipShowRule = {
  ALWAYS: 'always',
  FOLLOW_CROSS: 'follow_cross',
  NONE: 'none'
};
/**
 * æ•°æ®æç¤ºæ˜¾ç¤ºç±»å‹
 * @type {{RECT: string, STANDARD: string}}
 */

var TooltipShowType = {
  RECT: 'rect',
  STANDARD: 'standard'
};
/**
 * æ³¨è§£æ ‡è¯†ç±»ä¼¼
 * @type {{RECT: string, TRIANGLE: string, DIAMOND: string, CUSTOM: string, NONE: string, CIRCLE: string}}
 */

var AnnotationSymbolType = {
  CIRCLE: 'circle',
  RECT: 'rect',
  TRIANGLE: 'triangle',
  DIAMOND: 'diamond',
  CUSTOM: 'custom',
  NONE: 'none'
};
/**
 * è¦†ç›–ç‰©ä½ç½®
 * @type {{TOP: string, BOTTOM: string, POINT: string}}
 */

var OverlayPosition = {
  POINT: 'point',
  TOP: 'top',
  BOTTOM: 'bottom'
};
/**
 * é»˜è®¤ç½‘æ ¼é…ç½®
 * @type {{horizontal: {size: number, color: string, dashValue: number[], show: boolean, style: string}, show: boolean, vertical: {size: number, color: string, dashValue: number[], show: boolean, style: string}}}
 */

var defaultGrid = {
  show: true,
  horizontal: {
    show: true,
    size: 1,
    color: '#EDEDED',
    style: LineStyle.DASH,
    dashValue: [2, 2]
  },
  vertical: {
    show: true,
    size: 1,
    color: '#EDEDED',
    style: LineStyle.DASH,
    dashValue: [2, 2]
  }
};
/**
 * é»˜è®¤èœ¡çƒ›æŸ±å›¾æ ·å¼é…ç½®
 * @type {{area: {backgroundColor: [{offset: number, color: string}, {offset: number, color: string}], lineColor: string, lineSize: number, value: string}, bar: {noChangeColor: string, upColor: string, downColor: string}, tooltip: {rect: {offsetTop: number, fillColor: string, borderColor: string, paddingBottom: number, borderRadius: number, paddingRight: number, borderSize: number, offsetLeft: number, paddingTop: number, paddingLeft: number, offsetRight: number}, showRule: string, values: null, showType: string, text: {marginRight: number, size: number, color: string, weight: string, marginBottom: number, family: string, marginTop: number, marginLeft: number}, labels: string[]}, type: string, priceMark: {high: {textMargin: number, textSize: number, color: string, textFamily: string, show: boolean, textWeight: string}, last: {noChangeColor: string, upColor: string, line: {dashValue: number[], size: number, show: boolean, style: string}, show: boolean, text: {paddingBottom: number, size: number, color: string, paddingRight: number, show: boolean, weight: string, paddingTop: number, family: string, paddingLeft: number}, downColor: string}, low: {textMargin: number, textSize: number, color: string, textFamily: string, show: boolean, textWeight: string}, show: boolean}}}
 */

var defaultCandle = {
  margin: {
    top: 0.2,
    bottom: 0.1
  },
  type: CandleType.CANDLE_SOLID,
  bar: {
    /**
     * ä¸Šæ¶¨é¢œè‰²
     */
    upColor: '#26A69A',

    /**
     * ä¸‹è·Œé¢œè‰²
     */
    downColor: '#EF5350',

    /**
     * æ— å˜åŒ–æ—¶é¢œè‰²
     */
    noChangeColor: '#999999'
  },
  area: {
    lineSize: 2,
    lineColor: '#2196F3',
    value: 'close',
    backgroundColor: [{
      offset: 0,
      color: 'rgba(33, 150, 243, 0.01)'
    }, {
      offset: 1,
      color: 'rgba(33, 150, 243, 0.2)'
    }]
  },
  priceMark: {
    show: true,
    high: {
      show: true,
      color: '#76808F',
      textMargin: 5,
      textSize: 10,
      textFamily: 'Helvetica Neue',
      textWeight: 'normal'
    },
    low: {
      show: true,
      color: '#76808F',
      textMargin: 5,
      textSize: 10,
      textFamily: 'Helvetica Neue',
      textWeight: 'normal'
    },
    last: {
      show: true,
      upColor: '#26A69A',
      downColor: '#EF5350',
      noChangeColor: '#888888',
      line: {
        show: true,
        style: LineStyle.DASH,
        dashValue: [4, 4],
        size: 1
      },
      text: {
        show: true,
        size: 12,
        paddingLeft: 2,
        paddingTop: 2,
        paddingRight: 2,
        paddingBottom: 2,
        color: '#FFFFFF',
        family: 'Helvetica Neue',
        weight: 'normal',
        borderRadius: 2
      }
    }
  },
  tooltip: {
    showRule: TooltipShowRule.ALWAYS,
    showType: TooltipShowType.STANDARD,
    labels: ['æ—¶é—´: ', 'å¼€: ', 'æ”¶: ', 'é«˜: ', 'ä½: ', 'æˆäº¤é‡: '],
    values: null,
    defaultValue: 'n/a',
    rect: {
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 6,
      offsetLeft: 8,
      offsetTop: 8,
      offsetRight: 8,
      borderRadius: 4,
      borderSize: 1,
      borderColor: '#F2F3F5',
      backgroundColor: '#FEFEFE'
    },
    text: {
      size: 12,
      family: 'Helvetica Neue',
      weight: 'normal',
      color: '#76808F',
      marginLeft: 8,
      marginTop: 6,
      marginRight: 8,
      marginBottom: 0
    }
  }
};
/**
 * é»˜è®¤çš„æŠ€æœ¯æŒ‡æ ‡æ ·å¼é…ç½®
 * @type {{bar: {noChangeColor: string, upColor: string, downColor: string}, line: {size: number, colors: [string, string, string, string, string]}, tooltip: {showParams: boolean, showName: boolean, showRule: string, text: {marginRight: number, size: number, color: string, weight: string, marginBottom: number, family: string, marginTop: number, marginLeft: number}}, circle: {noChangeColor: string, upColor: string, downColor: string}, lastValueMark: {show: boolean, text: {paddingBottom: number, color: string, size: number, paddingRight: number, show: boolean, weight: string, paddingTop: number, family: string, paddingLeft: number}}}}
 */

var defaultTechnicalIndicator = {
  margin: {
    top: 0.2,
    bottom: 0.1
  },
  bar: {
    upColor: 'rgba(38, 166, 154, .65)',
    downColor: 'rgba(239, 83, 80, .65)',
    noChangeColor: '#888888'
  },
  line: {
    size: 1,
    colors: ['#FF9600', '#9D65C9', '#2196F3', '#E11D74', '#01C5C4']
  },
  circle: {
    upColor: 'rgba(38, 166, 154, .65)',
    downColor: 'rgba(239, 83, 80, .65)',
    noChangeColor: '#888888'
  },
  lastValueMark: {
    show: false,
    text: {
      show: false,
      color: '#FFFFFF',
      size: 12,
      family: 'Helvetica Neue',
      weight: 'normal',
      paddingLeft: 3,
      paddingTop: 2,
      paddingRight: 3,
      paddingBottom: 2,
      borderRadius: 2
    }
  },
  tooltip: {
    showRule: TooltipShowRule.ALWAYS,
    showType: TooltipShowType.STANDARD,
    showName: true,
    showParams: true,
    defaultValue: 'n/a',
    text: {
      size: 12,
      family: 'Helvetica Neue',
      weight: 'normal',
      color: '#76808F',
      marginTop: 6,
      marginRight: 8,
      marginBottom: 0,
      marginLeft: 8
    }
  }
};
/**
 * é»˜è®¤xè½´é…ç½®
 * @type {{axisLine: {color: string, size: number, show: boolean}, show: boolean, tickText: {paddingBottom: number, color: string, size: number, show: boolean, weight: string, paddingTop: number, family: string}, height: null, tickLine: {size: number, color: string, show: boolean, length: number}}}
 */

var defaultXAxis = {
  /**
   * æ˜¯å¦æ˜¾ç¤ºæ•´ä¸ªè½´
   */
  show: true,

  /**
   * é«˜åº¦
   */
  height: null,

  /**
   * è½´çº¿é…ç½®
   */
  axisLine: {
    show: true,
    color: '#DDDDDD',
    size: 1
  },

  /**
   * tickæ–‡å­—
   */
  tickText: {
    show: true,
    color: '#76808F',
    size: 12,
    family: 'Helvetica Neue',
    weight: 'normal',
    paddingTop: 3,
    paddingBottom: 6
  },
  // tickçº¿
  tickLine: {
    show: true,
    size: 1,
    length: 3,
    color: '#DDDDDD'
  }
};
/**
 * é»˜è®¤yè½´é…ç½®
 * @type {{axisLine: {color: string, size: number, show: boolean}, show: boolean, width: null, position: string, tickText: {color: string, size: number, paddingRight: number, show: boolean, weight: string, family: string, paddingLeft: number}, type: string, inside: boolean, tickLine: {size: number, color: string, show: boolean, length: number}}}
 */

var defaultYAxis = {
  /**
   * æ˜¯å¦æ˜¾ç¤ºæ•´ä¸ªè½´
   */
  show: true,

  /**
   * å®½åº¦
   */
  width: null,

  /**
   * yè½´ç±»å‹
   */
  type: YAxisType.NORMAL,

  /**
   * è½´ä½ç½®
   */
  position: YAxisPosition.RIGHT,

  /**
   * è½´æ˜¯å¦åœ¨å†…éƒ¨
   */
  inside: false,

  /**
   * è½´çº¿é…ç½®
   */
  axisLine: {
    show: true,
    color: '#DDDDDD',
    size: 1
  },

  /**
   * tickæ–‡å­—
   */
  tickText: {
    show: true,
    color: '#76808F',
    size: 12,
    family: 'Helvetica Neue',
    weight: 'normal',
    paddingLeft: 3,
    paddingRight: 6
  },
  // tickçº¿
  tickLine: {
    show: true,
    size: 1,
    length: 3,
    color: '#DDDDDD'
  }
};
var defaultCrosshair = {
  show: true,
  horizontal: {
    show: true,
    line: {
      show: true,
      style: LineStyle.DASH,
      dashValue: [4, 2],
      size: 1,
      color: '#76808F'
    },
    text: {
      show: true,
      color: '#FFFFFF',
      size: 12,
      family: 'Helvetica Neue',
      weight: 'normal',
      paddingLeft: 2,
      paddingRight: 2,
      paddingTop: 2,
      paddingBottom: 2,
      borderSize: 1,
      borderColor: '#686D76',
      borderRadius: 2,
      backgroundColor: '#686D76'
    }
  },
  vertical: {
    show: true,
    line: {
      show: true,
      style: LineStyle.DASH,
      dashValue: [4, 2],
      size: 1,
      color: '#76808F'
    },
    text: {
      show: true,
      color: '#FFFFFF',
      size: 12,
      family: 'Helvetica Neue',
      weight: 'normal',
      paddingLeft: 2,
      paddingRight: 2,
      paddingTop: 2,
      paddingBottom: 2,
      borderSize: 1,
      borderRadius: 2,
      borderColor: '#686D76',
      backgroundColor: '#686D76'
    }
  }
};
/**
 * é»˜è®¤å›¾å½¢é…ç½®
 * @type {{arc: {style: string, color: string, size: number}, polygon: {style: string, color: string, size: number}, line: {style: string, color: string, size: number, dashValue: number[]}, text: {style: string, marginRight: number, color: string, size: number, weight: string, marginBottom: number, family: string, marginTop: number, marginLeft: number}, point: {backgroundColor: string, borderColor: string, activeBorderSize: number, activeRadius: number, activeBorderColor: string, activeBackgroundColor: string, borderSize: number, radius: number}}}
 */

var defaultShape = {
  point: {
    backgroundColor: '#2196F3',
    borderColor: 'rgba(33, 150, 243, 0.35)',
    borderSize: 1,
    radius: 5,
    activeBackgroundColor: '#2196F3',
    activeBorderColor: 'rgba(33, 150, 243, 0.35)',
    activeBorderSize: 3,
    activeRadius: 5
  },
  line: {
    style: LineStyle.SOLID,
    color: '#2196F3',
    size: 1,
    dashValue: [2, 2]
  },
  polygon: {
    style: StrokeFillStyle.STROKE,
    stroke: {
      style: LineStyle.SOLID,
      size: 1,
      color: '#2196F3',
      dashValue: [2, 2]
    },
    fill: {
      color: '#2196F3'
    }
  },
  arc: {
    style: StrokeFillStyle.STROKE,
    stroke: {
      style: LineStyle.SOLID,
      size: 1,
      color: '#2196F3',
      dashValue: [2, 2]
    },
    fill: {
      color: '#2196F3'
    }
  },
  text: {
    style: StrokeFillStyle.FILL,
    color: '#2196F3',
    size: 12,
    family: 'Helvetica Neue',
    weight: 'normal',
    offset: [0, 0]
  }
};
/**
 * é»˜è®¤æ³¨è§£ä¿¡æ¯é…ç½®
 * @type {{}}
 */

var defaultAnnotation = {
  position: OverlayPosition.TOP,
  offset: [20, 0],
  symbol: {
    type: AnnotationSymbolType.DIAMOND,
    size: 8,
    color: '#2196F3',
    activeSize: 10,
    activeColor: '#FF9600'
  }
};
var defaultTag = {
  position: OverlayPosition.POINT,
  offset: 0,
  line: {
    show: true,
    style: LineStyle.DASH,
    dashValue: [4, 2],
    size: 1,
    color: '#2196F3'
  },
  text: {
    color: '#FFFFFF',
    backgroundColor: '#2196F3',
    size: 12,
    family: 'Helvetica Neue',
    weight: 'normal',
    paddingLeft: 2,
    paddingRight: 2,
    paddingTop: 2,
    paddingBottom: 2,
    borderRadius: 2,
    borderSize: 1,
    borderColor: '#2196F3'
  },
  mark: {
    offset: 0,
    color: '#FFFFFF',
    backgroundColor: '#2196F3',
    size: 12,
    family: 'Helvetica Neue',
    weight: 'normal',
    paddingLeft: 2,
    paddingRight: 2,
    paddingTop: 2,
    paddingBottom: 2,
    borderRadius: 2,
    borderSize: 1,
    borderColor: '#2196F3'
  }
};
/**
 * å›¾è¡¨ä¹‹é—´é»˜è®¤åˆ†å‰²é…ç½®
 * @type {{size: number, color: string}}
 */

var defaultSeparator = {
  size: 1,
  color: '#DDDDDD',
  fill: true,
  activeBackgroundColor: 'rgba(33, 150, 243, 0.08)'
};
var defaultStyleOptions = {
  grid: defaultGrid,
  candle: defaultCandle,
  technicalIndicator: defaultTechnicalIndicator,
  xAxis: defaultXAxis,
  yAxis: defaultYAxis,
  separator: defaultSeparator,
  crosshair: defaultCrosshair,
  shape: defaultShape,
  annotation: defaultAnnotation,
  tag: defaultTag
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * æ ¼å¼åŒ–å€¼
 * @param data
 * @param key
 * @param defaultValue
 * @returns {string|*}
 */

function formatValue(data, key) {
  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '--';

  if (isObject(data)) {
    var value = data[key];

    if (isValid(value)) {
      return value;
    }
  }

  return defaultValue;
}
/**
 * æ ¼å¼åŒ–æ—¶é—´
 * @param dateTimeFormat
 * @param timestamp
 * @param format
 * @returns {string}
 */

function formatDate(dateTimeFormat, timestamp) {
  var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'MM-DD hh:mm';

  if (isNumber(timestamp)) {
    var dateTimeString = dateTimeFormat.format(new Date(timestamp));
    var dateTimeStringArray = dateTimeString.split(', ');
    var dateStringArray = dateTimeStringArray[0].split('/');
    var date = {
      YYYY: dateStringArray[2],
      MM: dateStringArray[0],
      DD: dateStringArray[1],
      'hh:mm': dateTimeStringArray[1].match(/^[\d]{2}/)[0] === '24' ? dateTimeStringArray[1].replace(/^[\d]{2}/, '00') : dateTimeStringArray[1]
    };
    return format.replace(/YYYY|MM|DD|(hh:mm)/g, function (key) {
      return date[key];
    });
  }

  return '--';
}
/**
 * æ ¼å¼åŒ–ç²¾åº¦
 */

function formatPrecision(value) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var v = +value;

  if ((v || v === 0) && isNumber(v)) {
    return v.toFixed(precision);
  }

  return "".concat(v);
}
/**
 * æ ¼å¼åŒ–å¤§æ•°æ®
 * @param value
 */

function formatBigNumber(value) {
  if (isNumber(+value)) {
    if (value > 1000000000) {
      return "".concat(+(value / 1000000000).toFixed(3), "B");
    }

    if (value > 1000000) {
      return "".concat(+(value / 1000000).toFixed(3), "M");
    }

    if (value > 1000) {
      return "".concat(+(value / 1000).toFixed(3), "K");
    }

    return value;
  }

  return '--';
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * æ‰“å°è­¦å‘Šæ—¥å¿—
 * @param api
 * @param invalidParam
 * @param append
 */

function logWarn(api, invalidParam) {
  var append = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

  {
    console.log('%cğŸ˜‘ warning: \n%s%s%s', 'color:#fcaf17;font-weight:bold', api ? "Call api ".concat(api).concat(invalidParam || append ? ', ' : '.') : '', invalidParam ? "invalid parameter ".concat(invalidParam).concat(append ? ', ' : '.') : '', append ? "".concat(append) : '');
  }
}
/**
 * æ‰“å°é”™è¯¯æ—¥å¿—
 * @param api
 * @param invalidParam
 * @param append
 */

function logError(api, invalidParam) {
  var append = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

  {
    console.log('%cğŸ˜Ÿ error: \n%s%s%s', 'color:#ed1941;font-weight:bold', api ? "Call api ".concat(api).concat(invalidParam || append ? ', ' : '.', ",") : '', invalidParam ? "invalid parameter ".concat(invalidParam).concat(append ? ', ' : '.') : '', append ? "".concat(append) : '');
  }
}
/**
 * æ‰“å°æ ‡è¯†
 */

function logTag() {
  {
	  
  }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * äºŒåˆ†æŸ¥æ‰¾æœ€æ¥è¿‘çš„æ•°
 * @param dataList
 * @param valueKey
 * @param targetNumber
 * @return {number}
 */
function binarySearchNearest(dataList, valueKey, targetNumber) {
  var left = 0;
  var right = 0;

  for (right = dataList.length - 1; left !== right;) {
    var midIndex = Math.floor((right + left) / 2);
    var mid = right - left;
    var midValue = dataList[midIndex][valueKey];

    if (targetNumber === dataList[left][valueKey]) {
      return left;
    }

    if (targetNumber === dataList[right][valueKey]) {
      return right;
    }

    if (targetNumber === midValue) {
      return midIndex;
    }

    if (targetNumber > midValue) {
      left = midIndex;
    } else {
      right = midIndex;
    }

    if (mid <= 2) {
      break;
    }
  }

  return left;
}
/**
 * ä¼˜åŒ–æ•°å­—
 * @param value
 * @return {number|number}
 */

function nice(value) {
  var exponent = Math.floor(log10(value));
  var exp10 = index10(exponent);
  var f = value / exp10; // 1 <= f < 10

  var nf = 0;

  if (f < 1.5) {
    nf = 1;
  } else if (f < 2.5) {
    nf = 2;
  } else if (f < 3.5) {
    nf = 3;
  } else if (f < 4.5) {
    nf = 4;
  } else if (f < 5.5) {
    nf = 5;
  } else if (f < 6.5) {
    nf = 6;
  } else {
    nf = 8;
  }

  value = nf * exp10;
  return exponent >= -20 ? +value.toFixed(exponent < 0 ? -exponent : 0) : value;
}
/**
 * å››å’Œäº”å…¥
 * @param value
 * @param precision
 * @return {number}
 */

function round(value, precision) {
  if (precision == null) {
    precision = 10;
  }

  precision = Math.min(Math.max(0, precision), 20);
  value = (+value).toFixed(precision);
  return +value;
}
/**
 * è·å–å°æ•°ä½æ•°
 * @param value
 * @return {number|number}
 */

function getPrecision(value) {
  var str = value.toString();
  var eIndex = str.indexOf('e');

  if (eIndex > 0) {
    var precision = +str.slice(eIndex + 1);
    return precision < 0 ? -precision : 0;
  } else {
    var dotIndex = str.indexOf('.');
    return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;
  }
}
/**
 * 10ä¸ºä½çš„å¯¹æ•°å‡½æ•°
 * @param value
 * @return {number}
 */

function log10(value) {
  return Math.log(value) / Math.log(10);
}
/**
 * 10çš„æŒ‡æ•°å‡½æ•°
 * @param value
 * @return {number}
 */

function index10(value) {
  return Math.pow(10, value);
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * å›¾è¡¨åŠ¨ä½œ
 */
var ActionType = {
  ZOOM: 'zoom',
  SCROLL: 'scroll',
  CROSSHAIR: 'crosshair',
  TOOLTIP: 'tooltip',
  PANE_DRAG: 'pane_drag'
};
function hasAction(type) {
  return Object.values(ActionType).indexOf(type) > -1;
}

var MIN_DATA_SPACE = 1; // æœ€å¤§å•æ¡æ•°æ®å®½åº¦

var MAX_DATA_SPACE = 50;

var TimeScaleStore = /*#__PURE__*/function () {
  function TimeScaleStore(chartStore) {
    _classCallCheck(this, TimeScaleStore);

    this._chartStore = chartStore;
    this._dateTimeFormat = new Intl.DateTimeFormat('en', {
      hour12: false,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    }); // æ˜¯å¦å¯ä»¥ç¼©æ”¾

    this._zoomEnabled = true; // æ˜¯å¦å¯ä»¥æ‹–æ‹½æ»‘åŠ¨

    this._scrollEnabled = true; // æ˜¯å¦åœ¨åŠ è½½ä¸­

    this._loading = true; // åŠ è½½æ›´å¤šå›è°ƒ

    this._loadMoreCallback = null; // è¿˜æœ‰æ›´å¤š

    this._more = true; // å¯è§åŒºåŸŸæ•°æ®å ç”¨çš„ç©ºé—´

    this._totalDataSpace = 0; // æ¯ä¸€æ¡æ•°æ®çš„ç©ºé—´

    this._dataSpace = 6; // barçš„ç©ºé—´

    this._barSpace = this._calcBarSpace(); // å‘å³åç§»çš„ç©ºé—´

    this._offsetRightSpace = 50; // å‘å³åç§»çš„æ•°é‡

    this._offsetRightBarCount = this._offsetRightSpace / this._dataSpace; // å·¦è¾¹æœ€å°å¯è§barçš„ä¸ªæ•°

    this._leftMinVisibleBarCount = 2; // å³è¾¹æœ€å°å¯è§barçš„ä¸ªæ•°

    this._rightMinVisibleBarCount = 2; // å¼€å§‹ç»˜åˆ¶çš„ç´¢å¼•

    this._from = 0; // ç»“æŸçš„ç´¢å¼•

    this._to = 0; // ç”¨æ¥è®°å½•å¼€å§‹æ‹–æ‹½æ—¶å‘å³åç§»çš„æ•°é‡

    this._preOffsetRightBarCount = 0;
  }
  /**
   * è®¡ç®—ä¸€æ¡æŸ±å­çš„ç©ºé—´
   * @returns {number}
   * @private
   */


  _createClass(TimeScaleStore, [{
    key: "_calcBarSpace",
    value: function _calcBarSpace() {
      var rateBarSpace = Math.floor(this._dataSpace * 0.82);
      var floorBarSpace = Math.floor(this._dataSpace);
      var optimalBarSpace = Math.min(rateBarSpace, floorBarSpace - 1);
      return Math.max(1, optimalBarSpace);
    }
    /**
     * è°ƒæ•´ç»˜åˆ¶èµ·ç‚¹ç»ˆç‚¹ä½ç½®
     * @private
     */

  }, {
    key: "adjustFromTo",
    value: function adjustFromTo() {
      var dataSize = this._chartStore.dataList().length;

      var barLength = this._totalDataSpace / this._dataSpace;
      var maxRightOffsetBarCount = barLength - Math.min(this._leftMinVisibleBarCount, dataSize);

      if (this._offsetRightBarCount > maxRightOffsetBarCount) {
        this._offsetRightBarCount = maxRightOffsetBarCount;
      }

      var minRightOffsetBarCount = -dataSize + Math.min(this._rightMinVisibleBarCount, dataSize);

      if (this._offsetRightBarCount < minRightOffsetBarCount) {
        this._offsetRightBarCount = minRightOffsetBarCount;
      }

      this._to = Math.round(this._offsetRightBarCount + dataSize + 0.5);
      this._from = Math.round(this._to - barLength) - 1;

      if (this._to > dataSize) {
        this._to = dataSize;
      }

      if (this._from < 0) {
        this._from = 0;
      }

      this._chartStore.adjustVisibleDataList(); // å¤„ç†åŠ è½½æ›´å¤šï¼Œæœ‰æ›´å¤šå¹¶ä¸”æ²¡æœ‰åœ¨åŠ è½½åˆ™å»åŠ è½½æ›´å¤š


      if (this._from === 0 && this._more && !this._loading && isFunction(this._loadMoreCallback)) {
        this._loading = true;

        this._loadMoreCallback(formatValue(this._chartStore.dataList()[0], 'timestamp'));
      }
    }
    /**
     * è®¾ç½®æ˜¯å¦æœ‰æ›´å¤š
     * @param more
     */

  }, {
    key: "setMore",
    value: function setMore(more) {
      this._more = more;
    }
    /**
     * è®¾ç½®æ˜¯å¦åœ¨åŠ è½½
     */

  }, {
    key: "setLoading",
    value: function setLoading(loading) {
      this._loading = loading;
    }
    /**
     * è·å–æ—¶é—´æ ¼å¼åŒ–
     * @returns {Intl.DateTimeFormat | Intl.DateTimeFormat}
     */

  }, {
    key: "dateTimeFormat",
    value: function dateTimeFormat() {
      return this._dateTimeFormat;
    }
    /**
     * è®¾ç½®æ—¶åŒº
     * @param timezone
     */

  }, {
    key: "setTimezone",
    value: function setTimezone(timezone) {
      var dateTimeFormat;

      try {
        dateTimeFormat = new Intl.DateTimeFormat('en', {
          hour12: false,
          timeZone: timezone,
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit'
        });
      } catch (e) {
        logWarn('', '', 'Timezone is error!!!');
      }

      if (dateTimeFormat) {
        this._dateTimeFormat = dateTimeFormat;
      }
    }
    /**
     * è·å–æ—¶åŒº
     * @returns {null}
     */

  }, {
    key: "timezone",
    value: function timezone() {
      return this._dateTimeFormat.resolvedOptions().timeZone;
    }
    /**
     * è·å–ä¸€æ¡æ•°æ®çš„ç©ºé—´
     * @returns {number}
     */

  }, {
    key: "dataSpace",
    value: function dataSpace() {
      return this._dataSpace;
    }
    /**
     * è·å–ç»˜åˆ¶ä¸€æ¡æ•°æ®çš„ç©ºé—´ï¼ˆä¸åŒ…æ‹¬barä¹‹é—´çš„é—´éš™ï¼‰
     * @returns {*}
     */

  }, {
    key: "barSpace",
    value: function barSpace() {
      return this._barSpace;
    }
    /**
     * è·å–ç»˜åˆ¶ä¸€æ¡æ•°æ®ä¸€åŠçš„ç©ºé—´ï¼ˆä¸åŒ…æ‹¬barä¹‹é—´çš„é—´éš™ï¼‰
     * @returns
     */

  }, {
    key: "halfBarSpace",
    value: function halfBarSpace() {
      return this._barSpace / 2;
    }
    /**
     * è®¾ç½®ä¸€æ¡æ•°æ®çš„ç©ºé—´
     * @param dataSpace
     * @param adjustBeforeFuc
     */

  }, {
    key: "setDataSpace",
    value: function setDataSpace(dataSpace, adjustBeforeFuc) {
      if (dataSpace < MIN_DATA_SPACE || dataSpace > MAX_DATA_SPACE || this._dataSpace === dataSpace) {
        return;
      }

      this._dataSpace = dataSpace;
      this._barSpace = this._calcBarSpace();
      adjustBeforeFuc && adjustBeforeFuc();
      this.adjustFromTo();

      this._chartStore.crosshairStore().recalculate(true);

      this._chartStore.invalidate();
    }
    /**
     * è®¾ç½®å¯è§åŒºåŸŸæ•°æ®å ç”¨çš„æ€»ç©ºé—´
     * @param totalSpace
     */

  }, {
    key: "setTotalDataSpace",
    value: function setTotalDataSpace(totalSpace) {
      if (this._totalDataSpace === totalSpace) {
        return;
      }

      this._totalDataSpace = totalSpace;
      this.adjustFromTo();

      this._chartStore.crosshairStore().recalculate(true);
    }
    /**
     * è®¾ç½®å³è¾¹å¯ä»¥åç§»çš„ç©ºé—´
     * @param space
     * @param invalidate
     */

  }, {
    key: "setOffsetRightSpace",
    value: function setOffsetRightSpace(space, invalidate) {
      this._offsetRightSpace = space;
      this._offsetRightBarCount = space / this._dataSpace;

      if (invalidate) {
        this.adjustFromTo();

        this._chartStore.crosshairStore().recalculate(true);

        this._chartStore.invalidate();
      }
    }
    /**
     * é‡ç½®å³è¾¹å¯ä»¥åç§»çš„ç©ºé—´
     */

  }, {
    key: "resetOffsetRightSpace",
    value: function resetOffsetRightSpace() {
      this.setOffsetRightSpace(this._offsetRightSpace);
    }
    /**
     * å³åç§»è·ç¦»
     * @return {number}
     */

  }, {
    key: "offsetRightSpace",
    value: function offsetRightSpace() {
      return this._offsetRightSpace;
    }
    /**
     * å³åç§»baræ•°é‡
     * @return {*|number}
     */

  }, {
    key: "offsetRightBarCount",
    value: function offsetRightBarCount() {
      return this._offsetRightBarCount;
    }
    /**
     * è®¾ç½®å³åç§»baræ•°é‡
     * @param barCount
     */

  }, {
    key: "setOffsetRightBarCount",
    value: function setOffsetRightBarCount(barCount) {
      this._offsetRightBarCount = barCount;
    }
    /**
     * è®¾ç½®å·¦è¾¹å¯è§çš„æœ€å°baræ•°é‡
     * @param barCount
     */

  }, {
    key: "setLeftMinVisibleBarCount",
    value: function setLeftMinVisibleBarCount(barCount) {
      this._leftMinVisibleBarCount = barCount;
    }
    /**
     * è®¾ç½®å³è¾¹å¯è§çš„æœ€å°baræ•°é‡
     * @param barCount
     */

  }, {
    key: "setRightMinVisibleBarCount",
    value: function setRightMinVisibleBarCount(barCount) {
      this._rightMinVisibleBarCount = barCount;
    }
    /**
     * è·å–æ•°æ®ç»˜åˆ¶èµ·ç‚¹
     * @returns {number}
     */

  }, {
    key: "from",
    value: function from() {
      return this._from;
    }
    /**
     * è·å–æ•°æ®ç»˜åˆ¶ç»ˆç‚¹
     * @returns {number}
     */

  }, {
    key: "to",
    value: function to() {
      return this._to;
    }
    /**
     * å¼€å§‹æ»šåŠ¨
     */

  }, {
    key: "startScroll",
    value: function startScroll() {
      this._preOffsetRightBarCount = this._offsetRightBarCount;
    }
    /**
     * æ»šåŠ¨
     * @param distance
     * @param crosshair
     */

  }, {
    key: "scroll",
    value: function scroll(distance, crosshair) {
      if (!this._scrollEnabled) {
        return;
      }

      var distanceBarCount = distance / this._dataSpace;

      this._chartStore.actionStore().execute(ActionType.SCROLL, {
        barCount: distanceBarCount,
        distance: distance
      });

      this._offsetRightBarCount = this._preOffsetRightBarCount - distanceBarCount;
      this.adjustFromTo();

      var cross = crosshair || this._chartStore.crosshairStore().get();

      this._chartStore.crosshairStore().set(cross, true);

      this._chartStore.invalidate();
    }
    /**
     * æ ¹æ®ç´¢å¼•è·å–æ•°æ®
     * @param dataIndex
     */

  }, {
    key: "getDataByDataIndex",
    value: function getDataByDataIndex(dataIndex) {
      return this._chartStore.dataList()[dataIndex];
    }
    /**
     * xè½¬æ¢æˆæµ®ç‚¹æ•°çš„ä½ç½®
     * @param x
     * @returns {number}
     */

  }, {
    key: "coordinateToFloatIndex",
    value: function coordinateToFloatIndex(x) {
      var dataSize = this._chartStore.dataList().length;

      var deltaFromRight = (this._totalDataSpace - x) / this._dataSpace;
      var index = dataSize + this._offsetRightBarCount - deltaFromRight;
      return Math.round(index * 1000000) / 1000000;
    }
    /**
     * æ•°æ®ç´¢å¼•è½¬æ¢æˆæ—¶é—´æˆ³
     * @param dataIndex
     * @return {*}
     */

  }, {
    key: "dataIndexToTimestamp",
    value: function dataIndexToTimestamp(dataIndex) {
      var data = this.getDataByDataIndex(dataIndex);

      if (data) {
        return data.timestamp;
      }
    }
    /**
     * å°†æ—¶é—´æˆ³è½¬æ¢æˆæ•°æ®ç´¢å¼•ä½ç½®
     * @param timestamp
     * @return {number}
     */

  }, {
    key: "timestampToDataIndex",
    value: function timestampToDataIndex(timestamp) {
      if (this._chartStore.dataList().length === 0) {
        return 0;
      }

      return binarySearchNearest(this._chartStore.dataList(), 'timestamp', timestamp);
    }
    /**
     * æ•°æ®ç´¢å¼•è½¬æ¢æˆåæ ‡
     * @param dataIndex
     */

  }, {
    key: "dataIndexToCoordinate",
    value: function dataIndexToCoordinate(dataIndex) {
      var dataSize = this._chartStore.dataList().length;

      var deltaFromRight = dataSize + this._offsetRightBarCount - dataIndex;
      return this._totalDataSpace - (deltaFromRight - 0.5) * this._dataSpace;
    }
    /**
     * åæ ‡æ¢æˆæ•°æ®ç´¢å¼•è½¬
     * @param pixel
     */

  }, {
    key: "coordinateToDataIndex",
    value: function coordinateToDataIndex(pixel) {
      return Math.ceil(this.coordinateToFloatIndex(pixel)) - 1;
    }
    /**
     * ç¼©æ”¾
     * @param scale
     * @param coordinate
     */

  }, {
    key: "zoom",
    value: function zoom(scale, coordinate) {
      var _this = this;

      if (!this._zoomEnabled) {
        return;
      }

      if (!coordinate || !isValid(coordinate.x)) {
        var crosshair = this._chartStore.crosshairStore().get();

        coordinate = {
          x: isValid(crosshair.x) ? crosshair.x : this._totalDataSpace / 2
        };
      }

      this._chartStore.actionStore().execute(ActionType.ZOOM, {
        coordinate: coordinate,
        scale: scale
      });

      var floatIndex = this.coordinateToFloatIndex(coordinate.x);
      var dataSpace = this._dataSpace + scale * (this._dataSpace / 10);
      this.setDataSpace(dataSpace, function () {
        _this._offsetRightBarCount += floatIndex - _this.coordinateToFloatIndex(coordinate.x);
      });
    }
    /**
     * è®¾ç½®æ˜¯å¦å¯ä»¥ç¼©æ”¾
     * @param enabled
     */

  }, {
    key: "setZoomEnabled",
    value: function setZoomEnabled(enabled) {
      this._zoomEnabled = enabled;
    }
    /**
     * è·å–æ˜¯å¦å¯ä»¥ç¼©æ”¾
     * @return {boolean}
     */

  }, {
    key: "zoomEnabled",
    value: function zoomEnabled() {
      return this._zoomEnabled;
    }
    /**
     * è®¾ç½®æ˜¯å¦å¯ä»¥æ‹–æ‹½æ»šåŠ¨
     * @param enabled
     */

  }, {
    key: "setScrollEnabled",
    value: function setScrollEnabled(enabled) {
      this._scrollEnabled = enabled;
    }
    /**
     * è·å–æ˜¯å¦å¯ä»¥æ‹–æ‹½æ»šåŠ¨
     * @return {boolean}
     */

  }, {
    key: "scrollEnabled",
    value: function scrollEnabled() {
      return this._scrollEnabled;
    }
    /**
     * è®¾ç½®åŠ è½½æ›´å¤š
     * @param callback
     */

  }, {
    key: "setLoadMoreCallback",
    value: function setLoadMoreCallback(callback) {
      this._loadMoreCallback = callback;
    }
    /**
     * æ¸…é™¤æ•°æ®
     */

  }, {
    key: "clear",
    value: function clear() {
      this._more = true;
      this._loading = true;
      this._from = 0;
      this._to = 0;
    }
  }]);

  return TimeScaleStore;
}();

/**
 * ç»˜åˆ¶ç±»å‹
 * @type {{BAR: string, LINE: string, CIRCLE: string}}
 */

var TechnicalIndicatorPlotType = {
  LINE: 'line',
  BAR: 'bar',
  CIRCLE: 'circle'
};
/**
 * ç³»åˆ—
 */

var TechnicalIndicatorSeries = {
  PRICE: 'price',
  VOLUME: 'volume',
  NORMAL: 'normal'
};
/**
 * è·å–æŒ‡æ ‡é…ç½®é¡¹æ ·å¼
 * @param kLineDataList
 * @param techDataList
 * @param dataIndex
 * @param plot
 * @param techStyles
 * @param defaultStyle
 * @returns
 */

function getTechnicalIndicatorPlotStyle(kLineDataList, techDataList, dataIndex, plot, techStyles, defaultStyle) {
  var color = defaultStyle.color;
  var isStroke = defaultStyle.isStroke;
  var cbData = {
    prev: {
      kLineData: kLineDataList[dataIndex - 1],
      technicalIndicatorData: techDataList[dataIndex - 1]
    },
    current: {
      kLineData: kLineDataList[dataIndex],
      technicalIndicatorData: techDataList[dataIndex]
    },
    next: {
      kLineData: kLineDataList[dataIndex + 1],
      technicalIndicatorData: techDataList[dataIndex + 1]
    }
  };

  if (isValid(plot.color)) {
    if (isFunction(plot.color)) {
      color = plot.color(cbData, techStyles) || defaultStyle.color;
    } else {
      color = plot.color || defaultStyle.color;
    }
  }

  if (isValid(plot.isStroke)) {
    if (isFunction(plot.isStroke)) {
      isStroke = plot.isStroke(cbData);
    } else {
      isStroke = plot.isStroke;
    }
  }

  return {
    color: color,
    isStroke: isStroke
  };
}

var TechnicalIndicator = /*#__PURE__*/function () {
  function TechnicalIndicator(_ref) {
    var name = _ref.name,
        shortName = _ref.shortName,
        series = _ref.series,
        calcParams = _ref.calcParams,
        plots = _ref.plots,
        precision = _ref.precision,
        shouldCheckParamCount = _ref.shouldCheckParamCount,
        shouldOhlc = _ref.shouldOhlc,
        shouldFormatBigNumber = _ref.shouldFormatBigNumber,
        minValue = _ref.minValue,
        maxValue = _ref.maxValue,
        styles = _ref.styles;

    _classCallCheck(this, TechnicalIndicator);

    // æŒ‡æ ‡å
    this.name = name || ''; // æŒ‡æ ‡ç®€çŸ­åç§°ï¼Œç”¨äºæ˜¾ç¤º

    this.shortName = shortName || name || ''; // ç³»åˆ—

    this.series = Object.values(TechnicalIndicatorSeries).indexOf(series) !== -1 ? series : TechnicalIndicatorSeries.NORMAL; // ç²¾åº¦

    this.precision = isNumber(precision) && precision >= 0 ? precision : 4; // ç²¾åº¦è®¾ç½®æ ‡è¯†

    this._precisionFlag = false; // è®¡ç®—å‚æ•°

    this.calcParams = isArray(calcParams) ? calcParams : []; // æ•°æ®ä¿¡æ¯

    this.plots = isArray(plots) ? plots : []; // æ˜¯å¦éœ€è¦æ£€æŸ¥å‚æ•°

    this.shouldCheckParamCount = isBoolean(shouldCheckParamCount) ? shouldCheckParamCount : true; // æ˜¯å¦éœ€è¦ohlc

    this.shouldOhlc = isBoolean(shouldOhlc) ? shouldOhlc : false; // æ˜¯å¦éœ€è¦æ ¼å¼åŒ–å¤§æ•°æ®å€¼ï¼Œä»1000å¼€å§‹æ ¼å¼åŒ–ï¼Œæ¯”å¦‚100000æ˜¯å¦éœ€è¦æ ¼å¼åŒ–100K

    this.shouldFormatBigNumber = isBoolean(shouldFormatBigNumber) ? shouldFormatBigNumber : false; // æŒ‡å®šçš„æœ€å°å€¼

    this.minValue = minValue; // æŒ‡å®šçš„æœ€å¤§å€¼

    this.maxValue = maxValue; // æ ·å¼

    this.styles = styles; // ç»“æœ

    this.result = [];
  }

  _createClass(TechnicalIndicator, [{
    key: "_createParams",
    value: function _createParams(calcParams) {
      return calcParams.map(function (param) {
        if (isObject(param)) {
          return param.value;
        }

        return param;
      });
    }
    /**
     * è®¾ç½®ç®€çŸ­åç§°
     * @param shortName
     * @returns
     */

  }, {
    key: "setShortName",
    value: function setShortName(shortName) {
      if (this.shortName !== shortName) {
        this.shortName = shortName;
        return true;
      }

      return false;
    }
    /**
     * è®¾ç½®ç²¾åº¦
     * @param precision
     * @param flag
     * @returns
     */

  }, {
    key: "setPrecision",
    value: function setPrecision(precision, flag) {
      if (isNumber(precision) && precision >= 0 && (!flag || flag && !this._precisionFlag)) {
        this.precision = parseInt(precision, 10);

        if (!flag) {
          this._precisionFlag = true;
        }

        return true;
      }

      return false;
    }
    /**
     * è®¾ç½®è®¡ç®—å‚æ•°
     * @param params
     * @returns
     */

  }, {
    key: "setCalcParams",
    value: function setCalcParams(params) {
      if (!isArray(params)) {
        return false;
      }

      if (this.shouldCheckParamCount && params.length !== this.calcParams.length) {
        return false;
      }

      var calcParams = [];

      for (var i = 0; i < params.length; i++) {
        var param = params[i];
        var v = void 0;
        var allowDecimal = void 0;

        if (isObject(param)) {
          v = param.value;
          allowDecimal = param.allowDecimal;
        } else {
          v = param;
          allowDecimal = false;
        }

        var oldParam = this.calcParams[i];

        if (isObject(oldParam) && isBoolean(oldParam.allowDecimal)) {
          allowDecimal = oldParam.allowDecimal;
        }

        if (!isNumber(v) || v <= 0 || !allowDecimal && parseInt(v, 10) !== v) {
          return false;
        }

        calcParams.push({
          allowDecimal: allowDecimal,
          value: v
        });
      }

      this.calcParams = calcParams;
      var plots = this.regeneratePlots(this._createParams(calcParams));

      if (plots && isArray(plots)) {
        this.plots = plots;
      }

      return true;
    }
  }, {
    key: "setShouldOhlc",
    value: function setShouldOhlc(shouldOhlc) {
      if (isBoolean(shouldOhlc) && this.shouldOhlc !== shouldOhlc) {
        this.shouldOhlc = shouldOhlc;
        return true;
      }

      return false;
    }
  }, {
    key: "setShouldFormatBigNumber",
    value: function setShouldFormatBigNumber(shouldFormatBigNumber) {
      if (isBoolean(shouldFormatBigNumber) && this.shouldFormatBigNumber !== shouldFormatBigNumber) {
        this.shouldFormatBigNumber = shouldFormatBigNumber;
        return true;
      }

      return false;
    }
  }, {
    key: "setStyles",
    value: function setStyles(styles, defaultStyles) {
      if (!isObject(styles)) {
        return false;
      }

      if (!this.styles) {
        this.styles = {
          margin: clone(defaultStyles.margin),
          bar: clone(defaultStyles.bar),
          line: clone(defaultStyles.line),
          circle: clone(defaultStyles.circle)
        };
      }

      merge(this.styles, styles);
      return true;
    }
    /**
     * è®¡ç®—
     * @param dataList
     * @return {*}
     */

  }, {
    key: "calc",
    value: function calc(dataList) {
      this.result = this.calcTechnicalIndicator(dataList, {
        params: this._createParams(this.calcParams),
        plots: this.plots
      }) || [];
    }
    /**
     * è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
     */

  }, {
    key: "calcTechnicalIndicator",
    value: function calcTechnicalIndicator(dataList, options) {}
    /**
     * é‡æ–°ç”Ÿæˆå„é¡¹æ•°æ®
     * @param params
     */

  }, {
    key: "regeneratePlots",
    value: function regeneratePlots(params) {}
  }]);

  return TechnicalIndicator;
}();

var TechnicalIndicatorStore = /*#__PURE__*/function () {
  function TechnicalIndicatorStore(chartStore) {
    _classCallCheck(this, TechnicalIndicatorStore);

    this._chartStore = chartStore; // æŒ‡æ ‡æ¨¡æ¿

    this._templates = this._createTemplates();
    this._instances = new Map();
  }
  /**
   * è·å–æŒ‡æ ‡ä¿¡æ¯
   * @param tech
   * @return {{ calcParams, series, precision, name, shortName, shouldCheckParamCount, shouldOhlc, shouldFormatBigNumber, styles }}
   */


  _createClass(TechnicalIndicatorStore, [{
    key: "_createTechInfo",
    value: function _createTechInfo(tech) {
      return {
        name: tech.name,
        shortName: tech.shortName,
        series: tech.series,
        calcParams: tech.calcParams,
        shouldCheckParamCount: tech.shouldCheckParamCount,
        shouldOhlc: tech.shouldOhlc,
        shouldFormatBigNumber: tech.shouldFormatBigNumber,
        precision: tech.precision,
        styles: tech.styles,
        plots: tech.plots,
        result: tech.result || []
      };
    }
    /**
     * åˆ›å»ºæŠ€æœ¯æŒ‡æ ‡æ¨¡æ¿
     * @return {{}}
     */

  }, {
    key: "_createTemplates",
    value: function _createTemplates() {
      var mapping = {};
      var extensions = extension.technicalIndicatorExtensions;

      for (var name in extensions) {
        var templateInstance = this._createTemplateInstance(extensions[name]);

        if (templateInstance) {
          mapping[name] = templateInstance;
        }
      }

      return mapping;
    }
    /**
     * åˆ›å»ºä¸€ä¸ªæ–°çš„æŠ€æœ¯æŒ‡æ ‡
     * @param name
     * @param shortName
     * @param series
     * @param calcParams
     * @param plots
     * @param precision
     * @param shouldCheckParamCount
     * @param shouldOhlc
     * @param shouldFormatBigNumber
     * @param minValue
     * @param maxValue
     * @param styles
     * @param calcTechnicalIndicator
     * @param regeneratePlots
     * @param render
     * @returns {templateInstance|null}
     */

  }, {
    key: "_createTemplateInstance",
    value: function _createTemplateInstance(_ref) {
      var name = _ref.name,
          shortName = _ref.shortName,
          series = _ref.series,
          calcParams = _ref.calcParams,
          plots = _ref.plots,
          precision = _ref.precision,
          shouldCheckParamCount = _ref.shouldCheckParamCount,
          shouldOhlc = _ref.shouldOhlc,
          shouldFormatBigNumber = _ref.shouldFormatBigNumber,
          minValue = _ref.minValue,
          maxValue = _ref.maxValue,
          styles = _ref.styles,
          calcTechnicalIndicator = _ref.calcTechnicalIndicator,
          regeneratePlots = _ref.regeneratePlots,
          render = _ref.render;

      if (!name || !isFunction(calcTechnicalIndicator)) {
        logWarn('', '', 'The required attribute "name" and method "calcTechnicalIndicator" are missing, and new technical indicator cannot be generated!!!');
        return null;
      }

      var Template = /*#__PURE__*/function (_TechnicalIndicator) {
        _inherits(Template, _TechnicalIndicator);

        var _super = _createSuper(Template);

        function Template() {
          _classCallCheck(this, Template);

          return _super.call(this, {
            name: name,
            shortName: shortName,
            series: series,
            calcParams: calcParams,
            plots: plots,
            precision: precision,
            shouldCheckParamCount: shouldCheckParamCount,
            shouldOhlc: shouldOhlc,
            shouldFormatBigNumber: shouldFormatBigNumber,
            minValue: minValue,
            maxValue: maxValue,
            styles: styles
          });
        }

        return _createClass(Template);
      }(TechnicalIndicator);

      Template.prototype.calcTechnicalIndicator = calcTechnicalIndicator;

      if (isFunction(regeneratePlots)) {
        Template.prototype.regeneratePlots = regeneratePlots;
      }

      if (isFunction(render)) {
        Template.prototype.render = render;
      }

      return new Template();
    }
    /**
     * æ·»åŠ æŒ‡æ ‡æ¨¡æ¿
     * @param templates
     */

  }, {
    key: "addTemplate",
    value: function addTemplate(templates) {
      var _this = this;

      templates.forEach(function (tmp) {
        var instance = _this._createTemplateInstance(tmp || {});

        if (instance) {
          // å°†ç”Ÿæˆçš„æ–°çš„æŒ‡æ ‡ç±»æ”¾å…¥é›†åˆ
          _this._templates[instance.name] = instance;
        }
      });
    }
    /**
     * æ¨¡æ¿æ˜¯å¦å­˜åœ¨
     * @param {*} name
     * @returns
     */

  }, {
    key: "hasTemplate",
    value: function hasTemplate(name) {
      return !!this._templates[name];
    }
    /**
     * è·å–æŠ€æœ¯æŒ‡æ ‡æ¨¡æ¿ä¿¡æ¯
     * @param name
     * @return {{}|{calcParams: *, precision: *, name: *}}
     */

  }, {
    key: "getTemplateInfo",
    value: function getTemplateInfo(name) {
      if (isValid(name)) {
        var template = this._templates[name];

        if (template) {
          return this._createTechInfo(template);
        }
      } else {
        var templateInfos = {};

        for (var _name in this._templates) {
          var _template = this._templates[_name];
          templateInfos[_name] = this._createTechInfo(_template);
        }

        return templateInfos;
      }

      return {};
    }
    /**
     * æ·»åŠ æŠ€æœ¯æŒ‡æ ‡å®ä¾‹
     * @param paneId
     * @param tech
     * @param isStack
     * @returns
     */

  }, {
    key: "addInstance",
    value: function addInstance(paneId, tech, isStack) {
      if (tech) {
        var name = tech.name,
            calcParams = tech.calcParams,
            precision = tech.precision,
            shouldOhlc = tech.shouldOhlc,
            shouldFormatBigNumber = tech.shouldFormatBigNumber,
            styles = tech.styles;

        var paneInstances = this._instances.get(paneId);

        if (paneInstances && paneInstances.has(name)) {
          return false;
        }

        if (!paneInstances) {
          paneInstances = new Map();

          this._instances.set(paneId, paneInstances);
        }

        var template = this._templates[name];
        var instance;

        if (template) {
          instance = Object.create(Object.getPrototypeOf(template));

          for (var key in template) {
            if (Object.prototype.hasOwnProperty.call(template, key)) {
              instance[key] = template[key];
            }
          }
        }

        if (instance) {
          instance.setCalcParams(calcParams);
          instance.setPrecision(precision);
          instance.setShouldOhlc(shouldOhlc);
          instance.setShouldFormatBigNumber(shouldFormatBigNumber);
          instance.setStyles(styles, this._chartStore.styleOptions().technicalIndicator);

          if (!isStack) {
            paneInstances.clear();
          }

          paneInstances.set(name, instance);
          instance.calc(this._chartStore.dataList());
          return true;
        }
      }

      return false;
    }
    /**
     * è·å–å®ä¾‹
     * @param {*} paneId
     * @returns
     */

  }, {
    key: "instances",
    value: function instances(paneId) {
      return this._instances.get(paneId) || new Map();
    }
    /**
     * ç§»é™¤æŠ€æœ¯æŒ‡æ ‡
     * @param paneId
     * @param name
     * @return {boolean}
     */

  }, {
    key: "removeInstance",
    value: function removeInstance(paneId, name) {
      var removed = false;

      if (this._instances.has(paneId)) {
        var paneInstances = this._instances.get(paneId);

        if (isValid(name)) {
          if (paneInstances.has(name)) {
            paneInstances.delete(name);
            removed = true;
          }
        } else {
          paneInstances.clear();
          removed = true;
        }

        if (paneInstances.size === 0) {
          this._instances.delete(paneId);
        }
      }

      return removed;
    }
    /**
     * æ˜¯å¦æœ‰å®ä¾‹
     * @param paneId
     * @returns
     */

  }, {
    key: "hasInstance",
    value: function hasInstance(paneId) {
      return this._instances.has(paneId);
    }
    /**
     * å®ä¾‹è®¡ç®—
     * @param paneId
     * @param name
     */

  }, {
    key: "calcInstance",
    value: function calcInstance(name, paneId) {
      var _this2 = this;

      if (isValid(name)) {
        if (isValid(paneId)) {
          var paneInstances = this._instances.get(paneId);

          if (paneInstances && paneInstances.has(name)) {
            paneInstances.get(name).calc(this._chartStore.dataList());
          }
        } else {
          this._instances.forEach(function (paneInstances) {
            if (paneInstances.has(name)) {
              paneInstances.get(name).calc(_this2._chartStore.dataList());
            }
          });
        }
      } else {
        this._instances.forEach(function (paneInstances) {
          paneInstances.forEach(function (instance) {
            instance.calc(_this2._chartStore.dataList());
          });
        });
      }
    }
    /**
     * è·å–å®ä¾‹ä¿¡æ¯
     * @param paneId
     * @param name
     * @returns
     */

  }, {
    key: "getInstanceInfo",
    value: function getInstanceInfo(paneId, name) {
      var _this3 = this;

      var info = function info(paneInstances) {
        var instanceInfos = [];

        var _iterator = _createForOfIteratorHelper(paneInstances),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var entry = _step.value;
            var instance = entry[1];

            if (instance) {
              var instanceInfo = _this3._createTechInfo(instance);

              if (instance.name === name) {
                return instanceInfo;
              }

              instanceInfos.push(instanceInfo);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return instanceInfos;
      };

      if (isValid(paneId)) {
        if (this._instances.has(paneId)) {
          return info(this._instances.get(paneId));
        }
      } else {
        var infos = {};

        this._instances.forEach(function (paneInstance, paneId) {
          infos[paneId] = info(paneInstance);
        });

        return infos;
      }

      return {};
    }
    /**
     * è®¾ç½®ç³»åˆ—ç²¾åº¦
     * @param pricePrecision
     * @param volumePrecision
     */

  }, {
    key: "setSeriesPrecision",
    value: function setSeriesPrecision(pricePrecision, volumePrecision) {
      var setPrecision = function setPrecision(tech) {
        if (tech.series === TechnicalIndicatorSeries.PRICE) {
          tech.setPrecision(pricePrecision, true);
        }

        if (tech.series === TechnicalIndicatorSeries.VOLUME) {
          tech.setPrecision(volumePrecision, true);
        }
      };

      for (var key in this._templates) {
        setPrecision(this._templates[key]);
      }

      this._instances.forEach(function (paneInstances) {
        paneInstances.forEach(function (instance) {
          setPrecision(instance);
        });
      });
    }
    /**
     * è¦†ç›–
     * @param techOverride
     * @param paneId
     * @returns
     */

  }, {
    key: "override",
    value: function override(techOverride, paneId) {
      var _this4 = this;

      var name = techOverride.name,
          shortName = techOverride.shortName,
          calcParams = techOverride.calcParams,
          precision = techOverride.precision,
          shouldOhlc = techOverride.shouldOhlc,
          shouldFormatBigNumber = techOverride.shouldFormatBigNumber,
          styles = techOverride.styles;

      var defaultTechStyleOptions = this._chartStore.styleOptions().technicalIndicator;

      var instances = new Map();

      if (isValid(paneId)) {
        if (this._instances.has(paneId)) {
          instances.set(paneId, this._instances.get(paneId));
        }
      } else {
        instances = this._instances;
        var template = this._templates[name];

        if (template) {
          template.setCalcParams(calcParams);
          template.setShortName(shortName);
          template.setPrecision(precision);
          template.setShouldOhlc(shouldOhlc);
          template.setShouldFormatBigNumber(shouldFormatBigNumber);
          template.setStyles(styles, defaultTechStyleOptions);
        }
      }

      var overiderSuccss = false;
      var tasks = [];
      instances.forEach(function (paneInstances) {
        if (paneInstances.has(name)) {
          var tech = paneInstances.get(name);
          var shortNameSuccess = tech.setShortName(shortName);
          var calcParamsSuccess = tech.setCalcParams(calcParams);
          var precisionSuccess = tech.setPrecision(precision);
          var shouldOhlcSuccess = tech.setShouldOhlc(shouldOhlc);
          var shouldFormatBigNumberSuccess = tech.setShouldFormatBigNumber(shouldFormatBigNumber);
          var styleSuccess = tech.setStyles(styles, defaultTechStyleOptions);

          if (shortNameSuccess || calcParamsSuccess || precisionSuccess || shouldOhlcSuccess || shouldFormatBigNumberSuccess || styleSuccess) {
            overiderSuccss = true;
          }

          if (calcParamsSuccess) {
            tasks.push(Promise.resolve(tech.calc(_this4._chartStore.dataList())));
          }
        }
      });

      if (overiderSuccss) {
        return Promise.all(tasks);
      }
    }
  }]);

  return TechnicalIndicatorStore;
}();

/**
 * å®Œå–„è¦†ç›–ç‰©å®ä¾‹
 * @param overlay è¦†ç›–ç‰©å®ä¾‹
 * @param options å‚æ•°
 */

function perfectOverlayFunc(overlay, funcs) {
  funcs.forEach(function (_ref) {
    var key = _ref.key,
        fn = _ref.fn;

    if (isFunction(fn)) {
      overlay[key] = fn;
    }
  });
}
/**
 * è¦†ç›–ç‰©
 */

var Overlay = /*#__PURE__*/function () {
  function Overlay(_ref2) {
    var id = _ref2.id,
        chartStore = _ref2.chartStore,
        xAxis = _ref2.xAxis,
        yAxis = _ref2.yAxis;

    _classCallCheck(this, Overlay);

    this._id = id;
    this._chartStore = chartStore;
    this._xAxis = xAxis;
    this._yAxis = yAxis;
    this._styles = null;
  }
  /**
   * ç»˜åˆ¶
   * @param ctx
   */


  _createClass(Overlay, [{
    key: "draw",
    value: function draw(ctx) {}
    /**
     * è®¾ç½®æ ·å¼
     * @param styles
     * @param defaultStyles
     */

  }, {
    key: "setStyles",
    value: function setStyles(styles, defaultStyles) {
      if (!isObject(styles)) {
        return false;
      }

      if (!this._styles) {
        this._styles = clone(defaultStyles);
      }

      merge(this._styles, styles);
      return true;
    }
    /**
     * è·å–id
     * @return {*}
     */

  }, {
    key: "id",
    value: function id() {
      return this._id;
    }
    /**
     * è·å–æ ·å¼
     * @return {null}
     */

  }, {
    key: "styles",
    value: function styles() {
      return this._styles;
    }
    /**
     * è®¾ç½®yè½´
     * @param yAxis
     */

  }, {
    key: "setYAxis",
    value: function setYAxis(yAxis) {
      if (yAxis) {
        this._yAxis = yAxis;
      }
    }
    /**
     * æ£€æŸ¥é¼ æ ‡ç‚¹æ˜¯å¦åœ¨å›¾å½¢ä¸Š
     * @param coordinate
     */

  }, {
    key: "checkEventCoordinateOn",
    value: function checkEventCoordinateOn(coordinate) {} // -------------------- äº‹ä»¶å¼€å§‹ -------------------

    /**
     * ç‚¹å‡»äº‹ä»¶
     * @param id
     * @param points
     * @param event
     */

  }, {
    key: "onClick",
    value: function onClick(_ref3) {
      _ref3.id;
          _ref3.points;
          _ref3.event;
    }
    /**
     * å³å‡»äº‹ä»¶
     * @param id
     * @param points
     * @param event
     */

  }, {
    key: "onRightClick",
    value: function onRightClick(_ref4) {
      _ref4.id;
          _ref4.points;
          _ref4.event;
    }
    /**
     * é¼ æ ‡è¿›å…¥äº‹ä»¶
     * @param id
     * @param points
     * @param event
     */

  }, {
    key: "onMouseEnter",
    value: function onMouseEnter(_ref5) {
      _ref5.id;
          _ref5.points;
          _ref5.event;
    }
    /**
     * é¼ æ ‡ç¦»å¼€äº‹ä»¶
     * @param id
     * @param points
     * @param event
     */

  }, {
    key: "onMouseLeave",
    value: function onMouseLeave(_ref6) {
      _ref6.id;
          _ref6.points;
          _ref6.event;
    } // -------------------- äº‹ä»¶ç»“æŸ -------------------

  }]);

  return Overlay;
}();

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * ç»˜åˆ¶å®å¿ƒåœ†
 * @param ctx
 * @param fillColor
 * @param circleCoordinate
 * @param radius
 */

function renderFillCircle(ctx, fillColor, circleCoordinate, radius) {
  ctx.fillStyle = fillColor;
  ctx.beginPath();
  ctx.arc(circleCoordinate.x, circleCoordinate.y, radius, 0, Math.PI * 2);
  ctx.closePath();
  ctx.fill();
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEVIATION = 2;
/**
 * æ ¹æ®ä¸‰è§’å½¢ä¸‰ä¸ªç‚¹è·å–ä¸‰è§’å½¢é¢ç§¯
 * @param coordinate1
 * @param coordinate2
 * @param coordinate3
 * @return {number}
 */

function getTriangleSquare(coordinate1, coordinate2, coordinate3) {
  var x1 = Math.abs(coordinate2.x - coordinate1.x);
  var y1 = Math.abs(coordinate2.y - coordinate1.y);
  var x2 = Math.abs(coordinate3.x - coordinate1.x);
  var y2 = Math.abs(coordinate3.y - coordinate1.y);
  return Math.abs(x1 * y2 - x2 * y1) / 2;
}
/**
 * ç‚¹æ˜¯å¦åœ¨åœ†å†…
 * @param circleCenterCoordinate
 * @param radius
 * @param targetCoordinate
 * @returns {boolean}
 */

function checkCoordinateInCircle(circleCenterCoordinate, radius, targetCoordinate) {
  if (!targetCoordinate) {
    return false;
  }

  var difX = targetCoordinate.x - circleCenterCoordinate.x;
  var difY = targetCoordinate.y - circleCenterCoordinate.y;
  return !(difX * difX + difY * difY > radius * radius);
}
/**
 * æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…éƒ¨
 * @param triangleCoordinates
 * @param targetCoordinate
 * @return {boolean}
 */

function checkCoordinateInTriangle(triangleCoordinates, targetCoordinate) {
  var square = getTriangleSquare(triangleCoordinates[0], triangleCoordinates[1], triangleCoordinates[2]);
  var compareSquare = getTriangleSquare(triangleCoordinates[0], triangleCoordinates[1], targetCoordinate) + getTriangleSquare(triangleCoordinates[0], triangleCoordinates[2], targetCoordinate) + getTriangleSquare(triangleCoordinates[1], triangleCoordinates[2], targetCoordinate);
  return Math.abs(square - compareSquare) < DEVIATION;
}
/**
 * æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢è±å½¢å†…éƒ¨
 * @param centerCoordinate
 * @param width
 * @param height
 * @param targetCoordinate
 * @return {boolean}
 */

function checkCoordinateInDiamond(centerCoordinate, width, height, targetCoordinate) {
  var xDis = Math.abs(centerCoordinate.x - targetCoordinate.x);
  var yDis = Math.abs(centerCoordinate.y - targetCoordinate.y);
  return xDis * height + yDis * width < width * height / 2 + DEVIATION;
}
/**
 * æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨çŸ©å½¢å†…éƒ¨
 * @param coordinate1
 * @param coordinate2
 * @param targetCoordinate
 * @return {boolean}
 */

function checkCoordinateInRect(coordinate1, coordinate2, targetCoordinate) {
  return targetCoordinate.x >= coordinate1.x && targetCoordinate.x <= coordinate2.x && targetCoordinate.y >= coordinate1.y && targetCoordinate.y <= coordinate2.y;
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * ç»˜åˆ¶è·¯å¾„
 * @param ctx
 * @param coordinates
 * @param strokeFill
 */
function renderPath(ctx, coordinates, strokeFill) {
  ctx.save();

  if (ctx.lineWidth % 2) {
    ctx.translate(0.5, 0.5);
  }

  ctx.beginPath();
  var move = true;
  coordinates.forEach(function (coordinate) {
    if (coordinate) {
      if (move) {
        ctx.moveTo(coordinate.x, coordinate.y);
        move = false;
      } else {
        ctx.lineTo(coordinate.x, coordinate.y);
      }
    }
  });
  strokeFill();
  ctx.restore();
}
/**
 * æ¸²æŸ“è¾¹æ¡†è·¯å¾„
 * @param ctx
 * @param coordinates
 */


function renderStrokePath(ctx, coordinates) {
  renderPath(ctx, coordinates, function () {
    ctx.stroke();
    ctx.closePath();
  });
}
/**
 * æ¸²æŸ“å¡«å……è·¯å¾„
 * @param ctx
 * @param coordinates
 */

function renderFillPath(ctx, coordinates) {
  renderPath(ctx, coordinates, function () {
    ctx.closePath();
    ctx.fill();
  });
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * ç»˜åˆ¶æ°´å¹³ç›´çº¿
 * @param ctx
 * @param y
 * @param left
 * @param right
 */

function renderHorizontalLine(ctx, y, left, right) {
  ctx.beginPath();
  var correction = ctx.lineWidth % 2 ? 0.5 : 0;
  ctx.moveTo(left, y + correction);
  ctx.lineTo(right, y + correction);
  ctx.stroke();
  ctx.closePath();
}
/**
 * ç»˜åˆ¶å‚ç›´ç›´çº¿
 * @param ctx
 * @param x
 * @param top
 * @param bottom
 */

function renderVerticalLine(ctx, x, top, bottom) {
  ctx.beginPath();
  var correction = ctx.lineWidth % 2 ? 0.5 : 0;
  ctx.moveTo(x + correction, top);
  ctx.lineTo(x + correction, bottom);
  ctx.stroke();
  ctx.closePath();
}
/**
 * ç»˜åˆ¶çº¿
 * @param ctx
 * @param coordinates
 */

function renderLine(ctx, coordinates) {
  renderStrokePath(ctx, coordinates);
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * è·å–å±å¹•æ¯”
 * @param canvas
 * @returns {number}
 */
function getPixelRatio(canvas) {
  return canvas.ownerDocument && canvas.ownerDocument.defaultView && canvas.ownerDocument.defaultView.devicePixelRatio || 2;
}
/**
 * æµ‹é‡æ–‡å­—çš„å®½åº¦
 * @param ctx
 * @param text
 * @returns {number}
 */

function calcTextWidth(ctx, text) {
  return Math.round(ctx.measureText(text).width);
}
/**
 * åˆ›å»ºå­—ä½“
 * @param fontSize
 * @param fontFamily
 * @param fontWeight
 * @returns {string}
 */

function createFont() {
  var fontSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;
  var fontWeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';
  var fontFamily = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Helvetica Neue';
  return "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
}
/**
 * è·å–æ–‡å­—æ¡†å®½åº¦
 * @param ctx
 * @param text
 * @param options
 * @returns {number}
 */

function getTextRectWidth(ctx, text, options) {
  ctx.font = createFont(options.size, options.weight, options.family);
  var textWidth = calcTextWidth(ctx, text);
  return options.paddingLeft + options.paddingRight + textWidth + (options.borderSize || 0) * 2;
}
/**
 * è·å–æ–‡å­—æ¡†é«˜åº¦
 * @param options
 * @returns {number}
 */

function getTextRectHeight(options) {
  return options.paddingTop + options.paddingBottom + options.size + (options.borderSize || 0) * 2;
}

var SHAPE_DRAW_STEP_START = 1; // æ ‡è®°å›¾å½¢ç»˜åˆ¶æ­¥éª¤ç»“æŸ

var SHAPE_DRAW_STEP_FINISHED = -1;
/**
 * å›¾å½¢æ ‡è®°é¼ æ ‡æ“ä½œå…ƒç´ ç±»å‹
 * @type {{OTHER: string, POINT: string, NONE: string}}
 */

var ShapeMouseOperateElement = {
  OTHER: 'other',
  POINT: 'point',
  NONE: 'none'
};
/**
 * ç»˜åˆ¶ç±»å‹
 * @type {{ARC: string, POLYGON: string, LINE: string, CONTINUOUS_LINE: string, TEXT: string}}
 */

var ShapeElementType = {
  LINE: 'line',
  TEXT: 'text',
  CONTINUOUS_LINE: 'continuous_line',
  POLYGON: 'polygon',
  ARC: 'arc'
};
/**
 * çº¿ç±»å‹
 * @type {{VERTICAL: number, COMMON: number, HORIZONTAL: number}}
 */

var LineType = {
  COMMON: 0,
  HORIZONTAL: 1,
  VERTICAL: 2
};
/**
 * å›¾å½¢æ¨¡å¼
 */

var ShapeMode = {
  NORMAL: 'normal',
  WEAK_MAGNET: 'weak_magnet',
  STRONG_MAGNET: 'strong_magnet'
};
/**
 * è·å–ç»˜åˆ¶çº¿ç±»å‹
 * @param coordinate1
 * @param coordinate2
 * @private
 */

function getLineType(coordinate1, coordinate2) {
  if (coordinate1.x === coordinate2.x) {
    return LineType.VERTICAL;
  }

  if (coordinate1.y === coordinate2.y) {
    return LineType.HORIZONTAL;
  }

  return LineType.COMMON;
}
/**
 * æ ‡è®°å›¾å½¢
 */


var Shape = /*#__PURE__*/function (_Overlay) {
  _inherits(Shape, _Overlay);

  var _super = _createSuper(Shape);

  function Shape(_ref) {
    var _this;

    var id = _ref.id,
        name = _ref.name,
        totalStep = _ref.totalStep,
        chartStore = _ref.chartStore,
        xAxis = _ref.xAxis,
        yAxis = _ref.yAxis,
        points = _ref.points,
        styles = _ref.styles,
        lock = _ref.lock,
        data = _ref.data;

    _classCallCheck(this, Shape);

    _this = _super.call(this, {
      id: id,
      chartStore: chartStore,
      xAxis: xAxis,
      yAxis: yAxis
    });
    _this._name = name;
    _this._totalStep = totalStep;
    _this._lock = lock;
    _this._mode = ShapeMode.NORMAL;
    _this._data = data;
    _this._drawStep = SHAPE_DRAW_STEP_START;
    _this._points = [];

    _this.setPoints(points);

    _this.setStyles(styles, chartStore.styleOptions().shape);

    _this._prevPressPoint = null;
    _this._prevPoints = null;
    _this._coordinates = [];
    return _this;
  }
  /**
   * åŠ è½½ç‚¹
   * @param points
   */


  _createClass(Shape, [{
    key: "setPoints",
    value: function setPoints(points) {
      if (isArray(points) && points.length > 0) {
        var repeatTotalStep;

        if (points.length >= this._totalStep - 1) {
          this._drawStep = SHAPE_DRAW_STEP_FINISHED;
          this._points = points.slice(0, this._totalStep - 1);
          repeatTotalStep = this._totalStep - 1;
        } else {
          this._drawStep = points.length + 1;
          this._points = clone(points);
          repeatTotalStep = points.length;
        } // é‡æ–°æ¼”ç»ƒç»˜åˆ¶ä¸€éï¼Œé˜²æ­¢å› ä¸ºç‚¹ä¸å¯¹è€Œç»˜åˆ¶å‡ºé”™è¯¯çš„å›¾å½¢


        for (var i = 0; i < repeatTotalStep; i++) {
          this.performEventMoveForDrawing({
            step: i + 2,
            mode: this._mode,
            points: this._points,
            movePoint: this._points[i],
            xAxis: this._xAxis,
            yAxis: this._yAxis
          });
        }

        if (this._drawStep === SHAPE_DRAW_STEP_FINISHED) {
          this.performEventPressedMove({
            mode: this._mode,
            points: this._points,
            pressPointIndex: this._points.length - 1,
            pressPoint: this._points[this._points.length - 1],
            xAxis: this._xAxis,
            yAxis: this._yAxis
          });
        }
      }
    }
    /**
     * æ—¶é—´æˆ³è½¬æ¢æˆxè½´ä¸Šç‚¹çš„ä½ç½®
     * @param point
     * @return {*|number}
     * @private
     */

  }, {
    key: "_timestampOrDataIndexToCoordinateX",
    value: function _timestampOrDataIndexToCoordinateX(_ref2) {
      var timestamp = _ref2.timestamp,
          dataIndex = _ref2.dataIndex;

      if (timestamp) {
        dataIndex = this._chartStore.timeScaleStore().timestampToDataIndex(timestamp);
      }

      return this._xAxis.convertToPixel(dataIndex);
    }
    /**
     * ç»˜åˆ¶çº¿
     * @param ctx
     * @param lines
     * @param styles
     * @param defaultStyles
     * @private
     */

  }, {
    key: "_drawLines",
    value: function _drawLines(ctx, lines, styles, defaultStyles) {
      ctx.save();
      ctx.strokeStyle = styles.color || defaultStyles.color;
      ctx.lineWidth = styles.size || defaultStyles.size;

      if (styles.style === LineStyle.DASH) {
        ctx.setLineDash(styles.dashValue || defaultStyles.dashValue);
      }

      lines.forEach(function (coordinates) {
        if (coordinates.length > 1) {
          var lineType = getLineType(coordinates[0], coordinates[1]);

          switch (lineType) {
            case LineType.COMMON:
              {
                renderLine(ctx, coordinates);
                break;
              }

            case LineType.HORIZONTAL:
              {
                renderHorizontalLine(ctx, coordinates[0].y, coordinates[0].x, coordinates[1].x);
                break;
              }

            case LineType.VERTICAL:
              {
                renderVerticalLine(ctx, coordinates[0].x, coordinates[0].y, coordinates[1].y);
                break;
              }
          }
        }
      });
      ctx.restore();
    }
    /**
     * ç»˜åˆ¶è¿ç»­çº¿
     * @param ctx
     * @param continuousLines
     * @param styles
     * @param styles
     * @private
     */

  }, {
    key: "_drawContinuousLines",
    value: function _drawContinuousLines(ctx, continuousLines, styles, defaultStyles) {
      ctx.save();
      ctx.strokeStyle = styles.color || defaultStyles.color;
      ctx.lineWidth = styles.size || defaultStyles.size;

      if (styles.style === LineStyle.DASH) {
        ctx.setLineDash(styles.dashValue || defaultStyles.dashValue);
      }

      continuousLines.forEach(function (coordinates) {
        if (coordinates.length > 0) {
          renderLine(ctx, coordinates);
        }
      });
      ctx.restore();
    }
    /**
     * ç»˜åˆ¶å¤šè¾¹å½¢
     * @param ctx
     * @param polygons
     * @param styles
     * @param defaultStyles
     * @private
     */

  }, {
    key: "_drawPolygons",
    value: function _drawPolygons(ctx, polygons, styles, defaultStyles) {
      ctx.save();
      var strokeFill;

      if (styles.style === StrokeFillStyle.FILL) {
        ctx.fillStyle = (styles.fill || defaultStyles.fill).color;
        strokeFill = renderFillPath;
      } else {
        var strokeStyles = styles.stroke || defaultStyles.stroke;

        if (strokeStyles.style === LineStyle.DASH) {
          ctx.setLineDash(strokeStyles.dashValue);
        }

        ctx.lineWidth = strokeStyles.size;
        ctx.strokeStyle = strokeStyles.color;
        strokeFill = renderStrokePath;
      }

      polygons.forEach(function (coordinates) {
        if (coordinates.length > 0) {
          strokeFill(ctx, coordinates);
        }
      });
      ctx.restore();
    }
    /**
     * ç”»åœ†å¼§
     * @param ctx
     * @param arcs
     * @param styles
     * @param defaultStyles
     * @private
     */

  }, {
    key: "_drawArcs",
    value: function _drawArcs(ctx, arcs, styles, defaultStyles) {
      ctx.save();

      if (styles.style === StrokeFillStyle.FILL) {
        ctx.fillStyle = (styles.fill || defaultStyles.fill).color;
      } else {
        var strokeStyles = styles.stroke || defaultStyles.stroke;

        if (strokeStyles.style === LineStyle.DASH) {
          ctx.setLineDash(strokeStyles.dashValue);
        }

        ctx.lineWidth = strokeStyles.size;
        ctx.strokeStyle = strokeStyles.color;
      }

      arcs.forEach(function (_ref3) {
        var x = _ref3.x,
            y = _ref3.y,
            radius = _ref3.radius,
            startAngle = _ref3.startAngle,
            endAngle = _ref3.endAngle;
        ctx.beginPath();
        ctx.arc(x, y, radius, startAngle, endAngle);

        if (styles.style === StrokeFillStyle.FILL) {
          ctx.closePath();
          ctx.fill();
        } else {
          ctx.stroke();
          ctx.closePath();
        }
      });
      ctx.restore();
    }
    /**
     * ç»˜åˆ¶æ–‡å­—
     * @param ctx
     * @param texts
     * @param styles
     * @param defaultStyles
     * @private
     */

  }, {
    key: "_drawText",
    value: function _drawText(ctx, texts, styles, defaultStyles) {
      ctx.save();
      var fillStroke;

      if (styles.style === StrokeFillStyle.STROKE) {
        ctx.strokeStyle = styles.color || defaultStyles.color;
        fillStroke = ctx.strokeText;
      } else {
        ctx.fillStyle = styles.color || defaultStyles.color;
        fillStroke = ctx.fillText;
      }

      ctx.font = createFont(styles.size || defaultStyles.size, styles.family || defaultStyles.family, styles.weight || defaultStyles.weight);
      var offset = styles.offset || defaultStyles.offset || [0, 0];
      texts.forEach(function (_ref4) {
        var x = _ref4.x,
            y = _ref4.y,
            text = _ref4.text;
        fillStroke.call(ctx, text, x + offset[1], y + offset[0]);
      });
      ctx.restore();
    }
    /**
     * ç»˜åˆ¶
     * @param ctx
     */

  }, {
    key: "draw",
    value: function draw(ctx) {
      var _this2 = this;

      this._coordinates = this._points.map(function (_ref5) {
        var timestamp = _ref5.timestamp,
            value = _ref5.value,
            dataIndex = _ref5.dataIndex;
        return {
          x: _this2._timestampOrDataIndexToCoordinateX({
            timestamp: timestamp,
            dataIndex: dataIndex
          }),
          y: _this2._yAxis.convertToPixel(value)
        };
      });

      var shapeOptions = this._styles || this._chartStore.styleOptions().shape;

      if (this._drawStep !== SHAPE_DRAW_STEP_START && this._coordinates.length > 0) {
        var viewport = {
          width: this._xAxis.width(),
          height: this._yAxis.height()
        };
        var precision = {
          price: this._chartStore.pricePrecision(),
          volume: this._chartStore.volumePrecision()
        };
        this._shapeDataSources = this.createShapeDataSource({
          step: this._drawStep,
          mode: this._mode,
          points: this._points,
          coordinates: this._coordinates,
          viewport: {
            width: this._xAxis.width(),
            height: this._yAxis.height()
          },
          precision: {
            price: this._chartStore.pricePrecision(),
            volume: this._chartStore.volumePrecision()
          },
          styles: shapeOptions,
          xAxis: this._xAxis,
          yAxis: this._yAxis,
          data: this._data
        }) || [];

        this._shapeDataSources.forEach(function (_ref6) {
          var type = _ref6.type,
              isDraw = _ref6.isDraw,
              styles = _ref6.styles,
              _ref6$dataSource = _ref6.dataSource,
              dataSource = _ref6$dataSource === void 0 ? [] : _ref6$dataSource;

          if (isDraw) {
            switch (type) {
              case ShapeElementType.LINE:
                {
                  _this2._drawLines(ctx, dataSource, styles || shapeOptions.line, shapeOptions.line);

                  break;
                }

              case ShapeElementType.CONTINUOUS_LINE:
                {
                  _this2._drawContinuousLines(ctx, dataSource, styles || shapeOptions.line, shapeOptions.line);

                  break;
                }

              case ShapeElementType.POLYGON:
                {
                  _this2._drawPolygons(ctx, dataSource, styles || shapeOptions.polygon, shapeOptions.polygon);

                  break;
                }

              case ShapeElementType.ARC:
                {
                  _this2._drawArcs(ctx, dataSource, styles || shapeOptions.arc, shapeOptions.arc);

                  break;
                }

              case ShapeElementType.TEXT:
                {
                  _this2._drawText(ctx, dataSource, styles || shapeOptions.text, shapeOptions.text);

                  break;
                }
            }
          }
        });

        if (this.drawExtend) {
          ctx.save();
          this.drawExtend({
            ctx: ctx,
            dataSource: this._shapeDataSources,
            styles: shapeOptions,
            viewport: viewport,
            precision: precision,
            mode: this._mode,
            xAxis: this._xAxis,
            yAxis: this._yAxis,
            data: this._data
          });
          ctx.restore();
        }
      }

      var shapeMouseOperate = this._chartStore.shapeStore().mouseOperate();

      if (shapeMouseOperate.hover.id === this._id && shapeMouseOperate.hover.element !== ShapeMouseOperateElement.NONE || shapeMouseOperate.click.id === this._id && shapeMouseOperate.click.element !== ShapeMouseOperateElement.NONE || this.isDrawing()) {
        this._coordinates.forEach(function (_ref7, index) {
          var x = _ref7.x,
              y = _ref7.y;
          var radius = shapeOptions.point.radius;
          var color = shapeOptions.point.backgroundColor;
          var borderColor = shapeOptions.point.borderColor;
          var borderSize = shapeOptions.point.borderSize;

          if (shapeMouseOperate.hover.id === _this2._id && shapeMouseOperate.hover.element === ShapeMouseOperateElement.POINT && index === shapeMouseOperate.hover.elementIndex) {
            radius = shapeOptions.point.activeRadius;
            color = shapeOptions.point.activeBackgroundColor;
            borderColor = shapeOptions.point.activeBorderColor;
            borderSize = shapeOptions.point.activeBorderSize;
          }

          renderFillCircle(ctx, borderColor, {
            x: x,
            y: y
          }, radius + borderSize);
          renderFillCircle(ctx, color, {
            x: x,
            y: y
          }, radius);
        });
      }
    }
    /**
     * è®¾ç½®æ˜¯å¦é”å®š
     * @param lock
     */

  }, {
    key: "setLock",
    value: function setLock(lock) {
      this._lock = lock;
    }
    /**
     * è·å–åå­—
     * @return {*}
     */

  }, {
    key: "name",
    value: function name() {
      return this._name;
    }
    /**
     * æ˜¯å¦é”å®š
     * @return {*}
     */

  }, {
    key: "lock",
    value: function lock() {
      return this._lock;
    }
    /**
     * æ€»æ­¥éª¤æ•°
     * @return {*}
     */

  }, {
    key: "totalStep",
    value: function totalStep() {
      return this._totalStep;
    }
    /**
     * è·å–æ¨¡å¼ç±»å‹
     * @returns
     */

  }, {
    key: "mode",
    value: function mode() {
      return this._mode;
    }
    /**
     * è®¾ç½®æ¨¡å¼
     * @param mode
     */

  }, {
    key: "setMode",
    value: function setMode(mode) {
      if (Object.values(ShapeMode).indexOf > -1) {
        this._mode = mode;
      }
    }
    /**
     * è®¾ç½®æ•°æ®
     * @param data
     */

  }, {
    key: "setData",
    value: function setData(data) {
      if (data !== this._data) {
        this._data = data;
        return true;
      }

      return false;
    }
    /**
     * è·å–æ•°æ®
     * @returns
     */

  }, {
    key: "data",
    value: function data() {
      return this._data;
    }
    /**
     * è·å–ç‚¹
     * @return {[]}
     */

  }, {
    key: "points",
    value: function points() {
      return this._points;
    }
    /**
     * æ˜¯å¦åœ¨ç»˜åˆ¶ä¸­
     * @return {boolean}
     */

  }, {
    key: "isDrawing",
    value: function isDrawing() {
      return this._drawStep !== SHAPE_DRAW_STEP_FINISHED;
    }
    /**
     * æ˜¯å¦å¼€å§‹
     * @returns
     */

  }, {
    key: "isStart",
    value: function isStart() {
      return this._drawStep === SHAPE_DRAW_STEP_START;
    }
    /**
     * æ£€æŸ¥é¼ æ ‡ç‚¹æ˜¯å¦åœ¨å›¾å½¢ä¸Š
     * @param mouseCoordinate
     * @return {{id: *, elementIndex: number, element: string}}
     */

  }, {
    key: "checkEventCoordinateOn",
    value: function checkEventCoordinateOn(eventCoordinate) {
      var shapeOptions = this._styles || this._chartStore.styleOptions().shape; // æ£€æŸ¥é¼ æ ‡ç‚¹æ˜¯å¦åœ¨å›¾å½¢çš„ç‚¹ä¸Š


      var start = this._coordinates.length - 1;

      for (var i = start; i > -1; i--) {
        if (checkCoordinateInCircle(this._coordinates[i], shapeOptions.point.radius, eventCoordinate)) {
          return {
            id: this._id,
            element: ShapeMouseOperateElement.POINT,
            elementIndex: i,
            instance: this
          };
        }
      } // æ£€æŸ¥é¼ æ ‡ç‚¹æ˜¯å¦åœ¨ç‚¹æ„æˆçš„å…¶å®ƒå›¾å½¢ä¸Š


      if (this._shapeDataSources) {
        var _iterator = _createForOfIteratorHelper(this._shapeDataSources),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _step.value,
                key = _step$value.key,
                type = _step$value.type,
                isCheck = _step$value.isCheck,
                _step$value$dataSourc = _step$value.dataSource,
                dataSource = _step$value$dataSourc === void 0 ? [] : _step$value$dataSourc;

            if (isCheck) {
              for (var _i = 0; _i < dataSource.length; _i++) {
                var sources = dataSource[_i];

                if (this.checkEventCoordinateOnShape({
                  key: key,
                  type: type,
                  dataSource: sources,
                  eventCoordinate: eventCoordinate
                })) {
                  return {
                    id: this._id,
                    element: ShapeMouseOperateElement.OTHER,
                    elementIndex: _i,
                    instance: this
                  };
                }
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
    /**
     * ä¸åŒçš„æ¨¡å¼ä¸‹å¤„ç†å€¼
     * @param value
     * @param dataIndex
     * @param paneId
     */

  }, {
    key: "_performValue",
    value: function _performValue(y, dataIndex, paneId) {
      var value = this._yAxis.convertFromPixel(y);

      if (this._mode === ShapeMode.NORMAL || paneId !== 'candle_pane') {
        return value;
      }

      var kLineData = this._chartStore.timeScaleStore().getDataByDataIndex(dataIndex);

      if (!kLineData) {
        return value;
      }

      if (value > kLineData.high) {
        if (this._mode === ShapeMode.WEAK_MAGNET) {
          var highY = this._yAxis.convertToPixel(kLineData.high);

          var buffValue = this._yAxis.convertFromPixel(highY - 8);

          if (value < buffValue) {
            return kLineData.high;
          }

          return value;
        }

        return kLineData.high;
      }

      if (value < kLineData.low) {
        if (this._mode === ShapeMode.WEAK_MAGNET) {
          var lowY = this._yAxis.convertToPixel(kLineData.low);

          var _buffValue = this._yAxis.convertFromPixel(lowY - 8);

          if (value > _buffValue) {
            return kLineData.low;
          }

          return value;
        }

        return kLineData.low;
      }

      var max = Math.max(kLineData.open, kLineData.close);

      if (value > max) {
        if (value - max < kLineData.high - value) {
          return max;
        }

        return kLineData.high;
      }

      var min = Math.min(kLineData.open, kLineData.close);

      if (value < min) {
        if (value - kLineData.low < min - value) {
          return kLineData.low;
        }

        return min;
      }

      if (max - value < value - min) {
        return max;
      }

      return min;
    }
    /**
     * ç»˜åˆ¶è¿‡ç¨‹ä¸­é¼ æ ‡ç§»åŠ¨äº‹ä»¶
     * @param coordinate
     * @param event
     */

  }, {
    key: "mouseMoveForDrawing",
    value: function mouseMoveForDrawing(coordinate, event) {
      var dataIndex = this._xAxis.convertFromPixel(coordinate.x);

      var timestamp = this._chartStore.timeScaleStore().dataIndexToTimestamp(dataIndex);

      var value = this._performValue(coordinate.y, dataIndex, event.paneId);

      this._points[this._drawStep - 1] = {
        timestamp: timestamp,
        value: value,
        dataIndex: dataIndex
      };
      this.performEventMoveForDrawing({
        step: this._drawStep,
        mode: this._mode,
        points: this._points,
        movePoint: {
          timestamp: timestamp,
          value: value,
          dataIndex: dataIndex
        },
        xAxis: this._xAxis,
        yAxis: this._yAxis
      });
      this.onDrawing({
        id: this._id,
        step: this._drawStep,
        points: this._points
      });
    }
    /**
     * é¼ æ ‡å·¦è¾¹æŒ‰é’®ç‚¹å‡»äº‹ä»¶
     */

  }, {
    key: "mouseLeftButtonDownForDrawing",
    value: function mouseLeftButtonDownForDrawing() {
      if (this._drawStep === this._totalStep - 1) {
        this._drawStep = SHAPE_DRAW_STEP_FINISHED;

        this._chartStore.shapeStore().progressInstanceComplete();

        this.onDrawEnd({
          id: this._id,
          points: this._points
        });
      } else {
        this._drawStep++;
      }
    }
    /**
     * é¼ æ ‡æŒ‰ä½ç§»åŠ¨æ–¹æ³•
     * @param coordinate
     * @param event
     */

  }, {
    key: "mousePressedPointMove",
    value: function mousePressedPointMove(coordinate, event) {
      var shapeMouseOperate = this._chartStore.shapeStore().mouseOperate();

      var elementIndex = shapeMouseOperate.click.elementIndex;

      if (!this._lock && shapeMouseOperate.click.id === this._id && shapeMouseOperate.click.element === ShapeMouseOperateElement.POINT && elementIndex !== -1) {
        var dataIndex = this._xAxis.convertFromPixel(coordinate.x);

        var timestamp = this._chartStore.timeScaleStore().dataIndexToTimestamp(dataIndex);

        var value = this._performValue(coordinate.y, dataIndex, event.paneId);

        this._points[elementIndex].timestamp = timestamp;
        this._points[elementIndex].dataIndex = dataIndex;
        this._points[elementIndex].value = value;
        this.performEventPressedMove({
          points: this._points,
          mode: this._mode,
          pressPointIndex: elementIndex,
          pressPoint: {
            dataIndex: dataIndex,
            timestamp: timestamp,
            value: value
          },
          xAxis: this._xAxis,
          yAxis: this._yAxis
        });
        this.onPressedMove({
          id: this._id,
          element: ShapeMouseOperateElement.POINT,
          points: this._points,
          event: event
        });
      }
    }
    /**
     * æŒ‰ä½éç‚¹æ‹–åŠ¨å¼€å§‹äº‹ä»¶
     * @param coordinate
     */

  }, {
    key: "startPressedOtherMove",
    value: function startPressedOtherMove(coordinate) {
      var dataIndex = this._xAxis.convertFromPixel(coordinate.x);

      var value = this._yAxis.convertFromPixel(coordinate.y);

      this._prevPressPoint = {
        dataIndex: dataIndex,
        value: value
      };
      this._prevPoints = clone(this._points);
    }
    /**
     * æŒ‰ä½éç‚¹æ‹–åŠ¨æ—¶äº‹ä»¶
     * @param coordinate
     */

  }, {
    key: "mousePressedOtherMove",
    value: function mousePressedOtherMove(coordinate, event) {
      var _this3 = this;

      if (this._prevPressPoint) {
        var dataIndex = this._xAxis.convertFromPixel(coordinate.x);

        var value = this._yAxis.convertFromPixel(coordinate.y);

        var difDataIndex = dataIndex - this._prevPressPoint.dataIndex;
        var difValue = value - this._prevPressPoint.value;
        this._points = this._prevPoints.map(function (point) {
          // é˜²æ­¢å› ä¸ºåˆ›å»ºæ—¶ä¼ å…¥è¿›æ¥çš„pointæ²¡æœ‰dataIndexï¼Œå¯¼è‡´æ— æ³•è®¡ç®—æ—¶é—´æˆ³é—®é¢˜
          if (!isValid(point.dataIndex)) {
            point.dataIndex = _this3._chartStore.timeScaleStore().timestampToDataIndex(point.timestamp);
          }

          var dataIndex = point.dataIndex + difDataIndex;
          var value = point.value + difValue;
          return {
            dataIndex: dataIndex,
            value: value,
            timestamp: _this3._chartStore.timeScaleStore().dataIndexToTimestamp(dataIndex)
          };
        });
        this.onPressedMove({
          id: this._id,
          element: ShapeMouseOperateElement.OTHER,
          points: this._points,
          event: event
        });
      }
    } // -------------------- äº‹ä»¶å¼€å§‹ -------------------

    /**
     * å¼€å§‹ç»˜åˆ¶äº‹ä»¶å›è°ƒ
     * @param id
     */

  }, {
    key: "onDrawStart",
    value: function onDrawStart(_ref8) {
      _ref8.id;
    }
    /**
     * ç»˜åˆ¶è¿‡ç¨‹ä¸­äº‹ä»¶å›è°ƒ
     * @param id
     * @param step
     * @param points
     */

  }, {
    key: "onDrawing",
    value: function onDrawing(_ref9) {
      _ref9.id;
          _ref9.step;
          _ref9.points;
    }
    /**
     * ç»˜åˆ¶ç»“æŸäº‹ä»¶å›è°ƒ
     * @param id
     * @param points
     */

  }, {
    key: "onDrawEnd",
    value: function onDrawEnd(_ref10) {
      _ref10.id;
          _ref10.points;
    }
    /**
     * æŒ‰ä½ç§»åŠ¨äº‹ä»¶
     * @param id
     * @param points
     * @param event
     */

  }, {
    key: "onPressedMove",
    value: function onPressedMove(_ref11) {
      _ref11.id;
          _ref11.points;
          _ref11.event;
    }
    /**
     * ç§»é™¤äº‹ä»¶å›è°ƒ
     * @param id
     */

  }, {
    key: "onRemove",
    value: function onRemove(_ref12) {
      _ref12.id;
    } // -------------------- äº‹ä»¶ç»“æŸ -------------------
    // --------------------- è‡ªå®šä¹‰æ—¶éœ€è¦å®ç°çš„ä¸€äº›æ–¹æ³•å¼€å§‹ ----------------------

    /**
     * æ£€æŸ¥äº‹ä»¶åæ ‡æ˜¯å¦åœ¨å›¾å½¢ä¸Š
     * @param key
     * @param type
     * @param points
     * @param mousePoint
     */

  }, {
    key: "checkEventCoordinateOnShape",
    value: function checkEventCoordinateOnShape(_ref13) {
      _ref13.key;
          _ref13.type;
          _ref13.dataSource;
          _ref13.eventCoordinate;
    }
    /**
     * åˆ›å»ºå›¾å½¢é…ç½®
     * @param step
     * @param points
     * @param coordinates
     * @param viewport
     * @param precision
     * @param xAxis
     * @param yAxis
     */

  }, {
    key: "createShapeDataSource",
    value: function createShapeDataSource(_ref14) {
      _ref14.step;
          _ref14.mode;
          _ref14.points;
          _ref14.coordinates;
          _ref14.viewport;
          _ref14.precision;
          _ref14.styles;
          _ref14.xAxis;
          _ref14.yAxis;
          _ref14.data;
    }
    /**
     * å¤„ç†ç»˜åˆ¶è¿‡ç¨‹ä¸­é¼ æ ‡ç§»åŠ¨
     * @param step
     * @param mode
     * @param points
     * @param point
     * @param xAxis
     * @param yAxis
     */

  }, {
    key: "performEventMoveForDrawing",
    value: function performEventMoveForDrawing(_ref15) {
      _ref15.step;
          _ref15.mode;
          _ref15.points;
          _ref15.movePoint;
          _ref15.xAxis;
          _ref15.yAxis;
    }
    /**
     * å¤„ç†é¼ æ ‡æŒ‰ä½ç§»åŠ¨
     * @param mode
     * @param points
     * @param pressPointIndex
     * @param point
     * @param xAxis
     * @param yAxis
     */

  }, {
    key: "performEventPressedMove",
    value: function performEventPressedMove(_ref16) {
      _ref16.mode;
          _ref16.points;
          _ref16.pressPointIndex;
          _ref16.pressPoint;
          _ref16.xAxis;
          _ref16.yAxis;
    } // --------------------- è‡ªå®šä¹‰æ—¶éœ€è¦å®ç°çš„ä¸€äº›æ–¹æ³•ç»“æŸ ----------------------

  }]);

  return Shape;
}(Overlay);

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * åˆ·æ–°å±‚çº§
 * @type {{OVERLAY: number, MAIN: number, NONE: number, FULL: number}}
 */
var InvalidateLevel = {
  NONE: 0,
  OVERLAY: 1,
  MAIN: 2,
  FULL: 3
};

var ShapeStore = /*#__PURE__*/function () {
  function ShapeStore(chartStore) {
    _classCallCheck(this, ShapeStore);

    this._chartStore = chartStore; // å›¾å½¢æ ‡è®°æ˜ å°„

    this._templates = this._createTemplates(); // å›¾å½¢æ ‡è®°é¼ æ ‡æ“ä½œä¿¡æ¯

    this._mouseOperate = {
      click: {
        id: '',
        element: ShapeMouseOperateElement.NONE,
        elementIndex: -1
      },
      hover: {
        id: '',
        element: ShapeMouseOperateElement.NONE,
        elementIndex: -1
      }
    }; // è¿›è¡Œä¸­çš„å®ä¾‹

    this._progressInstance = null; // äº‹ä»¶æŒ‰ä½çš„ç¤ºä¾‹

    this._pressedInstance = null; // å›¾å½¢å®ä¾‹

    this._instances = new Map();
  }
  /**
   * åˆ›å»ºæ¨¡æ¿
   * @returns
   */


  _createClass(ShapeStore, [{
    key: "_createTemplates",
    value: function _createTemplates() {
      var templates = {};
      var extensions = extension.shapeExtensions;

      for (var name in extensions) {
        var TemplateClass = this._createTemplateClass(extensions[name]);

        if (TemplateClass) {
          templates[name] = TemplateClass;
        }
      }

      return templates;
    }
    /**
     * åˆ›å»ºæ¨¡æ¿ç±»
     * @param name
     * @param totalStep
     * @param checkEventCoordinateOnShape
     * @param createShapeDataSource
     * @param performEventPressedMove
     * @param performEventMoveForDrawing
     * @param drawExtend
     * @return
     */

  }, {
    key: "_createTemplateClass",
    value: function _createTemplateClass(_ref) {
      var name = _ref.name,
          totalStep = _ref.totalStep,
          checkEventCoordinateOnShape = _ref.checkEventCoordinateOnShape,
          createShapeDataSource = _ref.createShapeDataSource,
          performEventPressedMove = _ref.performEventPressedMove,
          performEventMoveForDrawing = _ref.performEventMoveForDrawing,
          drawExtend = _ref.drawExtend;

      if (!name || !isNumber(totalStep) || !isFunction(checkEventCoordinateOnShape) || !isFunction(createShapeDataSource)) {
        logWarn('', '', 'Required attribute "name" and "totalStep", method "checkEventCoordinateOnShape" and "createShapeDataSource", new shape cannot be generated!!!');
        return null;
      }

      var Template = /*#__PURE__*/function (_Shape) {
        _inherits(Template, _Shape);

        var _super = _createSuper(Template);

        function Template(_ref2) {
          var id = _ref2.id,
              chartStore = _ref2.chartStore,
              xAxis = _ref2.xAxis,
              yAxis = _ref2.yAxis,
              points = _ref2.points,
              styles = _ref2.styles,
              lock = _ref2.lock,
              data = _ref2.data;

          _classCallCheck(this, Template);

          return _super.call(this, {
            id: id,
            name: name,
            totalStep: totalStep,
            chartStore: chartStore,
            xAxis: xAxis,
            yAxis: yAxis,
            points: points,
            styles: styles,
            lock: lock,
            data: data
          });
        }

        return _createClass(Template);
      }(Shape);

      Template.prototype.checkEventCoordinateOnShape = checkEventCoordinateOnShape;
      Template.prototype.createShapeDataSource = createShapeDataSource;

      if (isFunction(performEventPressedMove)) {
        Template.prototype.performEventPressedMove = performEventPressedMove;
      }

      if (isFunction(performEventMoveForDrawing)) {
        Template.prototype.performEventMoveForDrawing = performEventMoveForDrawing;
      }

      if (isFunction(drawExtend)) {
        Template.prototype.drawExtend = drawExtend;
      }

      return Template;
    }
    /**
     * æ·»åŠ è‡ªå®šä¹‰æ ‡è®°å›¾å½¢
     * @param templates
     */

  }, {
    key: "addTemplate",
    value: function addTemplate(templates) {
      var _this = this;

      templates.forEach(function (tmp) {
        var Template = _this._createTemplateClass(tmp);

        if (Template) {
          _this._templates[tmp.name] = Template;
        }
      });
    }
    /**
     * è·å–å›¾å½¢æ ‡è®°æ¨¡æ¿ç±»
     * @param name
     * @return {*}
     */

  }, {
    key: "getTemplate",
    value: function getTemplate(name) {
      return this._templates[name];
    }
    /**
     * è·å–å®ä¾‹
     * @param shapeId
     * @returns
     */

  }, {
    key: "getInstance",
    value: function getInstance(shapeId) {
      var _iterator = _createForOfIteratorHelper(this._instances),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var entry = _step.value;
          var shape = (entry[1] || []).find(function (s) {
            return s.id() === shapeId;
          });

          if (shape) {
            return shape;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return null;
    }
    /**
     * æ˜¯å¦æœ‰å®ä¾‹
     * @param shapeId
     * @returns
     */

  }, {
    key: "hasInstance",
    value: function hasInstance(shapeId) {
      return !!this.getInstance(shapeId);
    }
    /**
     * æ·»åŠ æ ‡è®°å®ä¾‹
     * @param instance
     * @param paneId
     */

  }, {
    key: "addInstance",
    value: function addInstance(instance, paneId) {
      if (instance.isDrawing()) {
        this._progressInstance = {
          paneId: paneId,
          instance: instance,
          fixed: isValid(paneId)
        };
      } else {
        if (!this._instances.has(paneId)) {
          this._instances.set(paneId, []);
        }

        this._instances.get(paneId).push(instance);
      }

      this._chartStore.invalidate(InvalidateLevel.OVERLAY);
    }
    /**
     * è·å–è¿›è¡Œä¸­çš„å®ä¾‹
     * @returns
     */

  }, {
    key: "progressInstance",
    value: function progressInstance() {
      return this._progressInstance || {};
    }
    /**
     * è¿›è¡Œä¸­çš„å®ä¾‹å®Œæˆ
     */

  }, {
    key: "progressInstanceComplete",
    value: function progressInstanceComplete() {
      var _this$progressInstanc = this.progressInstance(),
          instance = _this$progressInstanc.instance,
          paneId = _this$progressInstanc.paneId;

      if (instance && !instance.isDrawing()) {
        if (!this._instances.has(paneId)) {
          this._instances.set(paneId, []);
        }

        this._instances.get(paneId).push(instance);

        this._progressInstance = null;
      }
    }
    /**
     * æ›´æ–°è¿›è¡Œä¸­çš„å®ä¾‹
     * @param yAxis
     * @param paneId
     */

  }, {
    key: "updateProgressInstance",
    value: function updateProgressInstance(yAxis, paneId) {
      var _this$progressInstanc2 = this.progressInstance(),
          instance = _this$progressInstanc2.instance,
          fixed = _this$progressInstanc2.fixed;

      if (instance && !fixed) {
        instance.setYAxis(yAxis);
        this._progressInstance.paneId = paneId;
      }
    }
    /**
     * è·å–æŒ‰ä½çš„å®ä¾‹
     * @returns
     */

  }, {
    key: "pressedInstance",
    value: function pressedInstance() {
      return this._pressedInstance || {};
    }
    /**
     * æ›´æ–°äº‹ä»¶æŒ‰ä½çš„å®ä¾‹
     * @param instance
     * @param paneId
     * @param element
     */

  }, {
    key: "updatePressedInstance",
    value: function updatePressedInstance(instance, paneId, element) {
      if (instance) {
        this._pressedInstance = {
          instance: instance,
          paneId: paneId,
          element: element
        };
      } else {
        this._pressedInstance = null;
      }
    }
    /**
     * è·å–å›¾å½¢æ ‡è®°çš„æ•°æ®
     * @param paneId
     * @returns {{}}
     */

  }, {
    key: "instances",
    value: function instances(paneId) {
      return this._instances.get(paneId) || [];
    }
    /**
     * è®¾ç½®å›¾å½¢æ ‡è®°å®ä¾‹é…ç½®
     * @param options
     */

  }, {
    key: "setInstanceOptions",
    value: function setInstanceOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var id = options.id,
          styles = options.styles,
          lock = options.lock,
          mode = options.mode,
          data = options.data;

      var defaultStyles = this._chartStore.styleOptions().shape;

      var shouldInvalidate = false;

      if (isValid(id)) {
        var instance = this.getInstance(id);

        if (instance) {
          instance.setLock(lock);
          instance.setMode(mode);

          if (instance.setStyles(styles, defaultStyles) || instance.setData(data)) {
            shouldInvalidate = true;
          }
        }
      } else {
        this._instances.forEach(function (shapes) {
          shapes.forEach(function (instance) {
            instance.setLock(lock);
            instance.setMode(mode);

            if (instance.setStyles(styles, defaultStyles) || instance.setData(data)) {
              shouldInvalidate = true;
            }
          });
        });
      }

      if (shouldInvalidate) {
        this._chartStore.invalidate(InvalidateLevel.OVERLAY);
      }
    }
    /**
     * è·å–å›¾å½¢æ ‡è®°ä¿¡æ¯
     * @param id
     * @return {{name, lock: *, styles, id, points: (*|*[])}[]|{name, lock: *, styles, id, points: (*|*[])}}
     */

  }, {
    key: "getInstanceInfo",
    value: function getInstanceInfo(shapeId) {
      var create = function create(instance) {
        return {
          name: instance.name(),
          id: instance.id(),
          totalStep: instance.totalStep(),
          lock: instance.lock(),
          mode: instance.mode(),
          points: instance.points(),
          styles: instance.styles(),
          data: instance.data()
        };
      };

      var progressInstance = this.progressInstance();

      if (isValid(shapeId)) {
        if (progressInstance.instance && progressInstance.instance.id() === shapeId) {
          return create(progressInstance.instance);
        }

        var shape = this.getInstance(shapeId);

        if (shape) {
          return create(shape);
        }
      } else {
        var infos = {};

        this._instances.forEach(function (shapes, paneId) {
          infos[paneId] = shapes.map(function (shape) {
            return create(shape);
          });

          if (progressInstance.paneId === paneId && progressInstance.instance) {
            infos[paneId].push(create(progressInstance.instance));
          }
        });

        return infos;
      }

      return null;
    }
    /**
     * ç§»é™¤å›¾å½¢å®ä¾‹
     * @param shapeId å‚æ•°
     * @param isProgress
     */

  }, {
    key: "removeInstance",
    value: function removeInstance(shapeId) {
      var shouldInvalidate = false;
      var progressInstance = this.progressInstance().instance;

      if (progressInstance && (!isValid(shapeId) || progressInstance.id() === shapeId)) {
        progressInstance.onRemove({
          id: progressInstance.id()
        });
        this._progressInstance = null;
        shouldInvalidate = true;
      }

      if (isValid(shapeId)) {
        var _iterator2 = _createForOfIteratorHelper(this._instances),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var entry = _step2.value;
            var shapes = entry[1] || [];
            var removeIndex = shapes.findIndex(function (shape) {
              return shape.id() === shapeId;
            });

            if (removeIndex > -1) {
              shapes[removeIndex].onRemove({
                id: shapes[removeIndex].id()
              });
              shapes.splice(removeIndex, 1);

              if (shapes.length === 0) {
                this._instances.delete(entry[0]);
              }

              shouldInvalidate = true;
              break;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } else {
        this._instances.forEach(function (shapes) {
          if (shapes.length > 0) {
            shapes.forEach(function (shape) {
              shape.onRemove({
                id: shape.id()
              });
            });
          }
        });

        this._instances.clear();

        shouldInvalidate = true;
      }

      if (shouldInvalidate) {
        this._chartStore.invalidate(InvalidateLevel.OVERLAY);
      }
    }
    /**
     * è·å–å›¾å½¢æ ‡è®°é¼ æ ‡æ“ä½œä¿¡æ¯
     * @return {{hover: {id: string, elementIndex: number, element: string}, click: {id: string, elementIndex: number, element: string}}}
     */

  }, {
    key: "mouseOperate",
    value: function mouseOperate() {
      return this._mouseOperate;
    }
    /**
     * è®¾ç½®é¼ æ ‡æ“ä½œä¿¡æ¯
     * @param mouseOperate
     * @return
     */

  }, {
    key: "setMouseOperate",
    value: function setMouseOperate(mouseOperate) {
      var _this$_mouseOperate = this._mouseOperate,
          hover = _this$_mouseOperate.hover,
          click = _this$_mouseOperate.click;

      if (mouseOperate.hover && (hover.id !== mouseOperate.hover.id || hover.element !== mouseOperate.hover.element || hover.elementIndex !== mouseOperate.hover.elementIndex)) {
        this._mouseOperate.hover = _objectSpread2({}, mouseOperate.hover);
      }

      if (mouseOperate.click && (click.id !== mouseOperate.click.id || click.element !== mouseOperate.click.element || click.elementIndex !== mouseOperate.click.elementIndex)) {
        this._mouseOperate.click = _objectSpread2({}, mouseOperate.click);
      }
    }
    /**
     * æ˜¯å¦ä¸ºç©º
     * @returns
     */

  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this._instances.size === 0 && !this.progressInstance().instance;
    }
    /**
     * æ˜¯å¦æ­£åœ¨ç»˜åˆ¶
     * @return
     */

  }, {
    key: "isDrawing",
    value: function isDrawing() {
      var instance = this.progressInstance().instance;
      return instance && instance.isDrawing();
    }
    /**
     * æ˜¯å¦æŒ‰ä½
     * @returns
     */

  }, {
    key: "isPressed",
    value: function isPressed() {
      return !!this.pressedInstance().instance;
    }
  }]);

  return ShapeStore;
}();

var AnnotationStore = /*#__PURE__*/function () {
  function AnnotationStore(chartStore) {
    _classCallCheck(this, AnnotationStore);

    this._chartStore = chartStore; // æ³¨è§£æ ‡è®°

    this._annotations = new Map(); // æ³¨è§£æ ‡è®°

    this._visibleAnnotations = new Map(); // æ³¨è§£é¼ æ ‡æ“ä½œä¿¡æ¯

    this._mouseOperate = {
      id: ''
    };
  }
  /**
   * è·å–æ³¨è§£é¼ æ ‡æ“ä½œä¿¡æ¯
   * @return {null}
   */


  _createClass(AnnotationStore, [{
    key: "mouseOperate",
    value: function mouseOperate() {
      return this._mouseOperate;
    }
    /**
     * è®¾ç½®é¼ æ ‡æ“ä½œ
     * @param operate
     */

  }, {
    key: "setMouseOperate",
    value: function setMouseOperate(operate) {
      var id = this._mouseOperate.id;

      if (operate && id !== operate.id) {
        this._mouseOperate = _objectSpread2({}, operate);
      }
    }
    /**
     * åˆ›å»ºå¯è§çš„æ³¨è§£æ•°æ®
     */

  }, {
    key: "createVisibleAnnotations",
    value: function createVisibleAnnotations() {
      var _this = this;

      this._visibleAnnotations.clear();

      if (this._annotations.size > 0) {
        this._chartStore.visibleDataList().forEach(function (_ref) {
          var data = _ref.data,
              x = _ref.x;

          _this._annotations.forEach(function (annotations, paneId) {
            if (annotations.size > 0) {
              var annotation = annotations.get(data.timestamp) || [];

              if (annotation.length > 0) {
                var _iterator = _createForOfIteratorHelper(annotation),
                    _step;

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var an = _step.value;
                    an.createSymbolCoordinate(x);

                    if (_this._visibleAnnotations.has(paneId)) {
                      _this._visibleAnnotations.get(paneId).push(an);
                    } else {
                      _this._visibleAnnotations.set(paneId, [an]);
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
            }
          });
        });
      }
    }
    /**
     * åˆ›å»ºæ³¨è§£
     * @param annotations
     * @param paneId
     */

  }, {
    key: "add",
    value: function add(annotations, paneId) {
      var _this2 = this;

      if (!this._annotations.has(paneId)) {
        this._annotations.set(paneId, new Map());
      }

      annotations.forEach(function (annotation) {
        var idAnnotations = _this2._annotations.get(paneId);

        if (idAnnotations.has(annotation.id())) {
          idAnnotations.get(annotation.id()).push(annotation);
        } else {
          idAnnotations.set(annotation.id(), [annotation]);
        }
      });
      this.createVisibleAnnotations();

      this._chartStore.invalidate(InvalidateLevel.OVERLAY);
    }
    /**
     * è·å–æ³¨è§£
     * @param paneId
     * @returns
     */

  }, {
    key: "get",
    value: function get(paneId) {
      return this._visibleAnnotations.get(paneId);
    }
    /**
     * ç§»é™¤æ³¨è§£
     * @param paneId
     * @param point
     */

  }, {
    key: "remove",
    value: function remove(paneId, point) {
      var shouldAdjust = false;

      if (isValid(paneId)) {
        if (this._annotations.has(paneId)) {
          if (isValid(point)) {
            var paneAnnotations = this._annotations.get(paneId);

            var points = [].concat(point);
            points.forEach(function (_ref2) {
              var timestamp = _ref2.timestamp;

              if (paneAnnotations.has(timestamp)) {
                shouldAdjust = true;
                paneAnnotations.delete(timestamp);
              }
            });

            if (paneAnnotations.size === 0) {
              this._annotations.delete(paneId);
            }

            if (shouldAdjust) {
              this.createVisibleAnnotations();
            }
          } else {
            shouldAdjust = true;

            this._annotations.delete(paneId);

            this._visibleAnnotations.delete(paneId);
          }
        }
      } else {
        shouldAdjust = true;

        this._annotations.clear();

        this._visibleAnnotations.clear();
      }

      if (shouldAdjust) {
        this._chartStore.invalidate(InvalidateLevel.OVERLAY);
      }
    }
    /**
     * æ˜¯å¦ä¸ºç©º
     * @returns
     */

  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this._visibleAnnotations.size === 0;
    }
  }]);

  return AnnotationStore;
}();

var TagStore = /*#__PURE__*/function () {
  function TagStore(chartStore) {
    _classCallCheck(this, TagStore);

    // åˆ·æ–°å›è°ƒ
    this._chartStore = chartStore; // æ ‡ç­¾

    this._tags = new Map();
  }
  /**
   * æ ¹æ®idè·å–tagå®ä¾‹
   * @param id
   * @param paneId
   * @returns
   */


  _createClass(TagStore, [{
    key: "_getById",
    value: function _getById(id, paneId) {
      var tags = this.get(paneId);

      if (tags) {
        return tags.get(id);
      }

      return null;
    }
    /**
     * æ˜¯å¦åŒ…å«æŸä¸€ä¸ªæ ‡ç­¾
     * @param id
     * @param paneId
     * @returns
     */

  }, {
    key: "has",
    value: function has(id, paneId) {
      return !!this._getById(id, paneId);
    }
    /**
     * æ›´æ–°tag
     * @param id
     * @param paneId
     * @param options
     */

  }, {
    key: "update",
    value: function update(id, paneId, options) {
      var tag = this._getById(id, paneId);

      if (tag) {
        return tag.update(options);
      }

      return false;
    }
    /**
    * æ ¹æ®idè·å–æ ‡ç­¾å®ä¾‹
    * @param tagId
    * @param paneId
    * @return
    */

  }, {
    key: "get",
    value: function get(paneId) {
      return this._tags.get(paneId);
    }
    /**
    * æ·»åŠ æ ‡ç­¾
    * @param tags
    * @param paneId
    */

  }, {
    key: "add",
    value: function add(tags, paneId) {
      if (!this._tags.has(paneId)) {
        this._tags.set(paneId, new Map());
      }

      var idTags = this._tags.get(paneId);

      tags.forEach(function (tag) {
        idTags.set(tag.id(), tag);
      });

      this._chartStore.invalidate(InvalidateLevel.OVERLAY);
    }
    /**
    * ç§»é™¤æ ‡ç­¾
    * @param paneId
    * @param tagId
    */

  }, {
    key: "remove",
    value: function remove(paneId, tagId) {
      var shouldInvalidate = false;

      if (isValid(paneId)) {
        if (this._tags.has(paneId)) {
          if (isValid(tagId)) {
            var paneTags = this._tags.get(paneId);

            var ids = [].concat(tagId);
            ids.forEach(function (id) {
              if (paneTags.has(id)) {
                shouldInvalidate = true;
                paneTags.delete(id);
              }
            });

            if (paneTags.size === 0) {
              this._tags.delete(paneId);
            }
          } else {
            shouldInvalidate = true;

            this._tags.delete(paneId);
          }
        }
      } else {
        shouldInvalidate = true;

        this._tags.clear();
      }

      if (shouldInvalidate) {
        this._chartStore.invalidate(InvalidateLevel.OVERLAY);
      }
    }
  }]);

  return TagStore;
}();

var CrosshairStore = /*#__PURE__*/function () {
  function CrosshairStore(chartStore) {
    _classCallCheck(this, CrosshairStore);

    this._chartStore = chartStore; // åå­—å…‰æ ‡ä¿¡æ¯

    this._crosshair = {};
  }
  /**
     * è®¾ç½®åå­—å…‰æ ‡ç‚¹ä¿¡æ¯
     * @param crosshair
     * @param notInvalidate
     */


  _createClass(CrosshairStore, [{
    key: "set",
    value: function set(crosshair, notInvalidate) {
      var dataList = this._chartStore.dataList();

      var cr = crosshair || {};
      var realDataIndex;
      var dataIndex;

      if (isValid(cr.x)) {
        realDataIndex = this._chartStore.timeScaleStore().coordinateToDataIndex(cr.x);

        if (realDataIndex < 0) {
          dataIndex = 0;
        } else if (realDataIndex > dataList.length - 1) {
          dataIndex = dataList.length - 1;
        } else {
          dataIndex = realDataIndex;
        }
      } else {
        realDataIndex = dataList.length - 1;
        dataIndex = realDataIndex;
      }

      var kLineData = dataList[dataIndex];

      var realX = this._chartStore.timeScaleStore().dataIndexToCoordinate(realDataIndex);

      var prevCrosshair = {
        x: this._crosshair.x,
        y: this._crosshair.y,
        paneId: this._crosshair.paneId
      };
      this._crosshair = _objectSpread2(_objectSpread2({}, cr), {}, {
        realX: realX,
        kLineData: kLineData,
        realDataIndex: realDataIndex,
        dataIndex: dataIndex
      });

      if (kLineData) {
        this._chartStore.crosshairChange({
          crosshair: cr,
          realDataIndex: realDataIndex,
          dataIndex: dataIndex,
          kLineData: kLineData,
          x: cr.x,
          y: cr.y
        });
      }

      if ((prevCrosshair.x !== cr.x || prevCrosshair.y !== cr.y || prevCrosshair.paneId !== cr.paneId) && !notInvalidate) {
        this._chartStore.invalidate(InvalidateLevel.OVERLAY);
      }
    }
    /**
     * é‡æ–°è®¡ç®—åå­—å…‰æ ‡
     * @param notInvalidate
     */

  }, {
    key: "recalculate",
    value: function recalculate(notInvalidate) {
      this.set(this._crosshair, notInvalidate);
    }
    /**
     * è·å–crosshairä¿¡æ¯
     * @returns
     */

  }, {
    key: "get",
    value: function get() {
      return this._crosshair;
    }
  }]);

  return CrosshairStore;
}();

var Delegate = /*#__PURE__*/function () {
  function Delegate() {
    _classCallCheck(this, Delegate);

    this._observers = [];
  }

  _createClass(Delegate, [{
    key: "subscribe",
    value: function subscribe(observer) {
      if (this._observers.indexOf(observer) < 0) {
        this._observers.push(observer);
      }
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(observer) {
      var index = this._observers.indexOf(observer);

      if (index > -1) {
        this._observers.splice(index, 1);
      } else {
        this._observers = [];
      }
    }
  }, {
    key: "execute",
    value: function execute(data) {
      this._observers.forEach(function (observer) {
        observer(data);
      });
    }
  }, {
    key: "hasObservers",
    value: function hasObservers() {
      return this._observers.length > 0;
    }
  }]);

  return Delegate;
}();

var ActionStore = /*#__PURE__*/function () {
  function ActionStore() {
    _classCallCheck(this, ActionStore);

    // äº‹ä»¶ä»£ç†
    this._delegates = new Map();
  }
  /**
   * äº‹ä»¶æ‰§è¡Œ
   * @param type
   * @param data
   */


  _createClass(ActionStore, [{
    key: "execute",
    value: function execute(type, data) {
      if (this.has(type)) {
        this._delegates.get(type).execute(data);
      }
    }
    /**
     * æ˜¯å¦æœ‰äº‹ä»¶ç›‘å¬
     * @param type
     * @return {boolean}
     */

  }, {
    key: "has",
    value: function has(type) {
      return this._delegates.has(type) && this._delegates.get(type).hasObservers();
    }
    /**
     * è®¢é˜…äº‹ä»¶
     * @param type
     * @param callback
     * @return {boolean}
     */

  }, {
    key: "subscribe",
    value: function subscribe(type, callback) {
      if (hasAction(type)) {
        if (!this._delegates.has(type)) {
          this._delegates.set(type, new Delegate());
        }

        this._delegates.get(type).subscribe(callback);

        return true;
      }

      return false;
    }
    /**
     * å–æ¶ˆäº‹ä»¶è®¢é˜…
     * @param type
     * @param callback
     * @return {boolean}
     */

  }, {
    key: "unsubscribe",
    value: function unsubscribe(type, callback) {
      if (hasAction(type)) {
        var delegate = this._delegates.get(type);

        delegate.unsubscribe(callback);

        if (!delegate.hasObservers()) {
          this._delegates.delete(type);
        }

        return true;
      }

      return false;
    }
  }]);

  return ActionStore;
}();

var ChartStore = /*#__PURE__*/function () {
  function ChartStore(styleOptions, handler) {
    _classCallCheck(this, ChartStore);

    // æŒæœ‰è€…
    this._handler = handler; // æ ·å¼é…ç½®

    this._styleOptions = clone(defaultStyleOptions);
    merge(this._styleOptions, styleOptions); // ä»·æ ¼ç²¾åº¦

    this._pricePrecision = 2; // æ•°é‡ç²¾åº¦

    this._volumePrecision = 0; // æ•°æ®æº

    this._dataList = []; // å¯è§çš„æ•°æ®(éœ€è¦ç»˜åˆ¶çš„æ•°æ®)

    this._visibleDataList = []; // è°ƒæ•´paneæ ‡è®°

    this._dragPaneFlag = false; // æ—¶é—´è½´ç¼©æ”¾æ•°æ®å­˜å‚¨

    this._timeScaleStore = new TimeScaleStore(this); // æŠ€æœ¯æŒ‡æ ‡æ•°æ®å­˜å‚¨

    this._technicalIndicatorStore = new TechnicalIndicatorStore(this); // å›¾å½¢æ•°æ®å­˜å‚¨

    this._shapeStore = new ShapeStore(this); // æ³¨è§£æ•°æ®å­˜å‚¨

    this._annotationStore = new AnnotationStore(this); // æ ‡ç­¾æ•°æ®å­˜å‚¨

    this._tagStore = new TagStore(this); // åå­—å…‰æ ‡æ•°æ®å­˜å‚¨

    this._crosshairStore = new CrosshairStore(this); // äº‹ä»¶å­˜å‚¨

    this._actionStore = new ActionStore();
  }
  /**
   * è°ƒæ•´å¯è§æ•°æ®
   */


  _createClass(ChartStore, [{
    key: "adjustVisibleDataList",
    value: function adjustVisibleDataList() {
      // å¤„ç†éœ€è¦ç»˜åˆ¶çš„æ•°æ®
      this._visibleDataList = [];

      var from = this._timeScaleStore.from();

      var to = this._timeScaleStore.to();

      for (var i = from; i < to; i++) {
        var kLineData = this._dataList[i];

        var x = this._timeScaleStore.dataIndexToCoordinate(i);

        this._visibleDataList.push({
          index: i,
          x: x,
          data: kLineData
        });
      }

      this._annotationStore.createVisibleAnnotations();
    }
    /**
     * è·å–æ ·å¼é…ç½®
     * @return {{}}
     */

  }, {
    key: "styleOptions",
    value: function styleOptions() {
      return this._styleOptions;
    }
    /**
     * è®¾ç½®æ ·å¼é…ç½®
     * @param options
     */

  }, {
    key: "applyStyleOptions",
    value: function applyStyleOptions(options) {
      merge(this._styleOptions, options);
    }
    /**
     * ä»·æ ¼ç²¾åº¦
     * @returns {number}
     */

  }, {
    key: "pricePrecision",
    value: function pricePrecision() {
      return this._pricePrecision;
    }
    /**
     * æ•°é‡ç²¾åº¦
     * @returns {number}
     */

  }, {
    key: "volumePrecision",
    value: function volumePrecision() {
      return this._volumePrecision;
    }
    /**
     * è®¾ç½®ä»·æ ¼å’Œæ•°é‡ç²¾åº¦
     * @param pricePrecision
     * @param volumePrecision
     */

  }, {
    key: "setPriceVolumePrecision",
    value: function setPriceVolumePrecision(pricePrecision, volumePrecision) {
      this._pricePrecision = pricePrecision;
      this._volumePrecision = volumePrecision;

      this._technicalIndicatorStore.setSeriesPrecision(pricePrecision, volumePrecision);
    }
    /**
     * è·å–æ•°æ®æº
     * @returns {[]|*[]}
     */

  }, {
    key: "dataList",
    value: function dataList() {
      return this._dataList;
    }
    /**
     * è·å–å¯è§æ•°æ®æº
     * @returns {[]|*[]}
     */

  }, {
    key: "visibleDataList",
    value: function visibleDataList() {
      return this._visibleDataList;
    }
    /**
     * æ·»åŠ æ•°æ®
     * @param data
     * @param pos
     * @param more
     */

  }, {
    key: "addData",
    value: function addData(data, pos, more) {
      if (isObject(data)) {
        if (isArray(data)) {
          this._timeScaleStore.setLoading(false);

          this._timeScaleStore.setMore(isBoolean(more) ? more : true);

          var isFirstAdd = this._dataList.length === 0;
          this._dataList = data.concat(this._dataList);

          if (isFirstAdd) {
            this._timeScaleStore.resetOffsetRightSpace();
          }

          this._timeScaleStore.adjustFromTo();
        } else {
          var dataSize = this._dataList.length;

          if (pos >= dataSize) {
            this._dataList.push(data);

            var offsetRightBarCount = this._timeScaleStore.offsetRightBarCount();

            if (offsetRightBarCount < 0) {
              this._timeScaleStore.setOffsetRightBarCount(--offsetRightBarCount);
            }

            this._timeScaleStore.adjustFromTo();
          } else {
            this._dataList[pos] = data;
            this.adjustVisibleDataList();
          }
        }

        this._crosshairStore.recalculate(true);
      }
    }
    /**
     * æ¸…ç©ºæ•°æ®æº
     */

  }, {
    key: "clearDataList",
    value: function clearDataList() {
      this._dataList = [];
      this._visibleDataList = [];

      this._timeScaleStore.clear();
    }
    /**
     * è·å–æ—¶é—´ç¼©æ”¾å­˜å‚¨
     * @returns
     */

  }, {
    key: "timeScaleStore",
    value: function timeScaleStore() {
      return this._timeScaleStore;
    }
    /**
     * è·å–æŠ€æœ¯æŒ‡æ ‡å­˜å‚¨
     * @returns
     */

  }, {
    key: "technicalIndicatorStore",
    value: function technicalIndicatorStore() {
      return this._technicalIndicatorStore;
    }
    /**
     * è·å–å›¾å½¢å­˜å‚¨
     * @returns
     */

  }, {
    key: "shapeStore",
    value: function shapeStore() {
      return this._shapeStore;
    }
    /**
     * è·å–æ³¨è§£å­˜å‚¨
     * @returns
     */

  }, {
    key: "annotationStore",
    value: function annotationStore() {
      return this._annotationStore;
    }
    /**
     * è·å–æ ‡ç­¾æ•°æ®å­˜å‚¨
     * @returns
     */

  }, {
    key: "tagStore",
    value: function tagStore() {
      return this._tagStore;
    }
    /**
     * è·å–åå­—å…‰æ ‡æ•°æ®å­˜å‚¨
     * @returns
     */

  }, {
    key: "crosshairStore",
    value: function crosshairStore() {
      return this._crosshairStore;
    }
    /**
     * è·å–äº‹ä»¶æ•°æ®å­˜å‚¨
     * @returns
     */

  }, {
    key: "actionStore",
    value: function actionStore() {
      return this._actionStore;
    }
    /**
     * åˆ·æ–°
     * @param invalidateLevel
     */

  }, {
    key: "invalidate",
    value: function invalidate(invalidateLevel) {
      this._handler.invalidate(invalidateLevel);
    }
    /**
     * åå­—å…‰æ ‡å˜åŒ–
     * @param data
     */

  }, {
    key: "crosshairChange",
    value: function crosshairChange(data) {
      this._handler.crosshair(data);
    }
    /**
     * è·å–æ‹–æ‹½Paneæ ‡è®°
     * @return {boolean}
     */

  }, {
    key: "dragPaneFlag",
    value: function dragPaneFlag() {
      return this._dragPaneFlag;
    }
    /**
     * è®¾ç½®æ‹–æ‹½Paneæ ‡è®°
     * @param flag
     */

  }, {
    key: "setDragPaneFlag",
    value: function setDragPaneFlag(flag) {
      this._dragPaneFlag = flag;
    }
  }]);

  return ChartStore;
}();

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * åˆ›å»ºä¸€ä¸ªå…ƒç´ 
 * @param name
 * @param styles
 * @return {*}
 */
function createElement(name) {
  var styles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var element = document.createElement(name);

  for (var key in styles) {
    if (Object.prototype.hasOwnProperty.call(styles, key)) {
      element.style[key] = styles[key];
    }
  }

  return element;
}

var Pane = /*#__PURE__*/function () {
  function Pane(props) {
    _classCallCheck(this, Pane);

    this._height = -1;
    this._container = props.container;
    this._chartStore = props.chartStore;

    this._initBefore(props);

    this._initElement();

    this._mainWidget = this._createMainWidget(this._element, props);
    this._yAxisWidget = this._createYAxisWidget(this._element, props);
  }

  _createClass(Pane, [{
    key: "_initBefore",
    value: function _initBefore(props) {}
  }, {
    key: "_initElement",
    value: function _initElement() {
      this._element = createElement('div', {
        width: '100%',
        margin: '0',
        padding: '0',
        position: 'relative',
        overflow: 'hidden',
        boxSizing: 'border-box'
      });
      var lastElement = this._container.lastChild;

      if (lastElement) {
        this._container.insertBefore(this._element, lastElement);
      } else {
        this._container.appendChild(this._element);
      }
    }
    /**
     * åˆ›å»ºä¸»ç»„ä»¶
     * @param container
     * @param props
     * @private
     */

  }, {
    key: "_createMainWidget",
    value: function _createMainWidget(container, props) {}
    /**
     * åˆ›å»ºyè½´ç»„ä»¶
     * @param container
     * @param props
     * @private
     */

  }, {
    key: "_createYAxisWidget",
    value: function _createYAxisWidget(container, props) {}
    /**
     * è·å–å®½åº¦
     * @returns {number}
     */

  }, {
    key: "width",
    value: function width() {
      return this._element.offsetWidth;
    }
  }, {
    key: "setWidth",
    value: function setWidth(mainWidgetWidth, yAxisWidgetWidth) {
      this._mainWidget.setWidth(mainWidgetWidth);

      this._yAxisWidget && this._yAxisWidget.setWidth(yAxisWidgetWidth);
    }
    /**
     * è·å–é«˜åº¦
     */

  }, {
    key: "height",
    value: function height() {
      return this._height;
    }
    /**
     * è®¾ç½®ä¸´æ—¶é«˜åº¦
     * @param height
     */

  }, {
    key: "setHeight",
    value: function setHeight(height) {
      this._height = height;

      this._mainWidget.setHeight(height);

      this._yAxisWidget && this._yAxisWidget.setHeight(height);
    }
  }, {
    key: "setOffsetLeft",
    value: function setOffsetLeft(mainWidgetOffsetLeft, yAxisWidgetOffsetLeft) {
      this._mainWidget.setOffsetLeft(mainWidgetOffsetLeft);

      this._yAxisWidget && this._yAxisWidget.setOffsetLeft(yAxisWidgetOffsetLeft);
    }
  }, {
    key: "layout",
    value: function layout() {
      if (this._element.offsetHeight !== this._height) {
        this._element.style.height = "".concat(this._height, "px");
      }

      this._mainWidget.layout();

      this._yAxisWidget && this._yAxisWidget.layout();
    }
    /**
     * åˆ·æ–°
     * @param level
     */

  }, {
    key: "invalidate",
    value: function invalidate(level) {
      this._yAxisWidget && this._yAxisWidget.invalidate(level);

      this._mainWidget.invalidate(level);
    }
    /**
     * åˆ›å»ºhtmlå…ƒç´ 
     */

  }, {
    key: "createHtml",
    value: function createHtml(_ref) {
      var id = _ref.id,
          content = _ref.content,
          style = _ref.style,
          position = _ref.position;
      var htmlId;

      if (position === 'yAxis') {
        htmlId = this._yAxisWidget && this._yAxisWidget.createHtml({
          id: id,
          content: content,
          style: style
        });
      } else {
        htmlId = this._mainWidget.createHtml({
          id: id,
          content: content,
          style: style
        });
      }

      return htmlId;
    }
    /**
     * ç§»é™¤htmlå…ƒç´ 
     * @param id
     */

  }, {
    key: "removeHtml",
    value: function removeHtml(id) {
      this._yAxisWidget && this._yAxisWidget.removeHtml(id);

      this._mainWidget.removeHtml(id);
    }
    /**
     * å°†canvasè½¬æ¢æˆå›¾ç‰‡
     * @param includeOverlay
     * @return {HTMLCanvasElement}
     */

  }, {
    key: "getImage",
    value: function getImage(includeOverlay) {
      var width = this._element.offsetWidth;
      var height = this._element.offsetHeight;
      var canvas = createElement('canvas', {
        width: "".concat(width, "px"),
        height: "".concat(height, "px"),
        boxSizing: 'border-box'
      });
      var ctx = canvas.getContext('2d');
      var pixelRatio = getPixelRatio(canvas);
      canvas.width = width * pixelRatio;
      canvas.height = height * pixelRatio;
      ctx.scale(pixelRatio, pixelRatio);

      var mainWidgetElement = this._mainWidget.getElement();

      var mainWidgetWidth = mainWidgetElement.offsetWidth;
      var mainWidgetHeight = mainWidgetElement.offsetHeight;
      var mainWidgetOffsetLeft = parseInt(mainWidgetElement.style.left, 10);
      ctx.drawImage(this._mainWidget.getImage(includeOverlay), mainWidgetOffsetLeft, 0, mainWidgetWidth, mainWidgetHeight);

      if (this._yAxisWidget) {
        var yAxisWidgetElement = this._yAxisWidget.getElement();

        var yAxisWidgetWidth = yAxisWidgetElement.offsetWidth;
        var yAxisWidgetHeight = yAxisWidgetElement.offsetHeight;
        var yAxisWidgetOffsetLeft = parseInt(yAxisWidgetElement.style.left, 10);
        ctx.drawImage(this._yAxisWidget.getImage(includeOverlay), yAxisWidgetOffsetLeft, 0, yAxisWidgetWidth, yAxisWidgetHeight);
      }

      return canvas;
    }
    /**
     * é”€æ¯
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._container.removeChild(this._element);
    }
  }]);

  return Pane;
}();

var Widget = /*#__PURE__*/function () {
  function Widget(props) {
    _classCallCheck(this, Widget);

    this._width = 0;
    this._height = 0;

    this._initElement(props.container);

    this._mainView = this._createMainView(this._element, props);
    this._overlayView = this._createOverlayView(this._element, props);
    this._htmlBaseId = 0;
    this._htmls = new Map();
  }
  /**
   * åˆå§‹åŒ–element
   * @param container
   * @private
   */


  _createClass(Widget, [{
    key: "_initElement",
    value: function _initElement(container) {
      this._element = createElement('div', {
        margin: '0',
        padding: '0',
        position: 'absolute',
        top: '0',
        overflow: 'hidden',
        boxSizing: 'border-box'
      });
      container.appendChild(this._element);
    }
    /**
     * åˆ›å»ºä¸»view
     * @param container
     * @param props
     * @private
     */

  }, {
    key: "_createMainView",
    value: function _createMainView(container, props) {}
    /**
     * åˆ›å»ºæµ®å±‚view
     * @param container
     * @param props
     * @private
     */

  }, {
    key: "_createOverlayView",
    value: function _createOverlayView(container, props) {}
    /**
     * åˆ›å»ºhtmlå…ƒç´ 
     * @param id æ ‡è¯†
     * @param content å†…å®¹
     * @param style æ ·å¼
     */

  }, {
    key: "createHtml",
    value: function createHtml(_ref) {
      var id = _ref.id,
          content = _ref.content,
          _ref$style = _ref.style,
          style = _ref$style === void 0 ? {} : _ref$style;
      var html = createElement('div', _objectSpread2({
        boxSizing: 'border-box',
        position: 'absolute',
        zIndex: 12
      }, style));

      if (isString(content)) {
        var str = content.replace(/(^\s*)|(\s*$)/g, '');
        html.innerHTML = str;
      } else {
        html.appendChild(content);
      }

      var htmlId = id || "html_".concat(++this._htmlBaseId);

      if (this._htmls.has(htmlId)) {
        this._element.replaceChild(html, this._htmls.get(htmlId));
      } else {
        this._element.appendChild(html);
      }

      this._htmls.set(htmlId, html);

      return htmlId;
    }
    /**
     * ç§»é™¤htmlå…ƒç´ 
     * @param id
     */

  }, {
    key: "removeHtml",
    value: function removeHtml(id) {
      var _this = this;

      if (id) {
        var ids = [].concat(id);
        ids.forEach(function (htmlId) {
          var html = _this._htmls.get(htmlId);

          if (html) {
            _this._element.removeChild(html);

            _this._htmls.delete(htmlId);
          }
        });
      } else {
        this._htmls.forEach(function (html) {
          _this._element.removeChild(html);
        });

        this._htmls.clear();
      }
    }
  }, {
    key: "getElement",
    value: function getElement() {
      return this._element;
    }
  }, {
    key: "setWidth",
    value: function setWidth(width) {
      this._width = width;

      this._mainView.setWidth(width);

      this._overlayView.setWidth(width);
    }
  }, {
    key: "setHeight",
    value: function setHeight(height) {
      this._height = height;

      this._mainView.setHeight(height);

      this._overlayView.setHeight(height);
    }
  }, {
    key: "setOffsetLeft",
    value: function setOffsetLeft(offsetLeft) {
      this._element.style.left = "".concat(offsetLeft, "px");
    }
  }, {
    key: "layout",
    value: function layout() {
      if (this._element.offsetWidth !== this._width) {
        this._element.style.width = "".concat(this._width, "px");
      }

      if (this._element.offsetHeight !== this._height) {
        this._element.style.height = "".concat(this._height, "px");
      }

      this._mainView.layout();

      this._overlayView.layout();
    }
    /**
     * æ›´æ–°
     * @param level
     */

  }, {
    key: "invalidate",
    value: function invalidate(level) {
      switch (level) {
        case InvalidateLevel.OVERLAY:
          {
            this._overlayView.flush();

            break;
          }

        case InvalidateLevel.MAIN:
        case InvalidateLevel.FULL:
          {
            this._mainView.flush();

            this._overlayView.flush();

            break;
          }
      }
    }
    /**
     * å°†widgetè½¬æ¢æˆå›¾ç‰‡
     * @param includeOverlay
     * @returns {HTMLCanvasElement}
     */

  }, {
    key: "getImage",
    value: function getImage(includeOverlay) {
      var canvas = createElement('canvas', {
        width: "".concat(this._width, "px"),
        height: "".concat(this._height, "px"),
        boxSizing: 'border-box'
      });
      var ctx = canvas.getContext('2d');
      var pixelRatio = getPixelRatio(canvas);
      canvas.width = this._width * pixelRatio;
      canvas.height = this._height * pixelRatio;
      ctx.scale(pixelRatio, pixelRatio);
      ctx.drawImage(this._mainView.getImage(), 0, 0, this._width, this._height);

      if (includeOverlay && this._overlayView) {
        ctx.drawImage(this._overlayView.getImage(), 0, 0, this._width, this._height);
      }

      return canvas;
    }
  }]);

  return Widget;
}();

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * requestAnimationFrameå…¼å®¹
 * @param fn
 */
function requestAnimationFrame(fn) {
  if (!window.requestAnimationFrame) {
    return window.setTimeout(fn, 20);
  }

  return window.requestAnimationFrame(fn);
}
/**
 * cancelAnimationFrameå…¼å®¹
 * @param id
 */

function cancelAnimationFrame(id) {
  if (!window.cancelAnimationFrame) {
    clearTimeout(id);
  }

  window.cancelAnimationFrame(id);
}

var View = /*#__PURE__*/function () {
  function View(container, chartStore) {
    _classCallCheck(this, View);

    this._chartStore = chartStore;

    this._initCanvas(container);
  }
  /**
   * åˆå§‹åŒ–ç”»å¸ƒ
   * @param container
   * @private
   */


  _createClass(View, [{
    key: "_initCanvas",
    value: function _initCanvas(container) {
      this._canvas = createElement('canvas', {
        position: 'absolute',
        top: '0',
        left: '0',
        zIndex: '2',
        boxSizing: 'border-box'
      });
      this._ctx = this._canvas.getContext('2d');
      container.appendChild(this._canvas);
    }
    /**
     * é‡æ–°ç»˜åˆ¶
     * @param extendFun
     * @private
     */

  }, {
    key: "_redraw",
    value: function _redraw(extendFun) {
      this._ctx.clearRect(0, 0, this._canvas.offsetWidth, this._canvas.offsetHeight);

      extendFun && extendFun();

      this._draw();
    }
    /**
     * ç»˜åˆ¶
     */

  }, {
    key: "_draw",
    value: function _draw() {}
  }, {
    key: "setWidth",
    value: function setWidth(width) {
      this._width = width;
    }
  }, {
    key: "setHeight",
    value: function setHeight(height) {
      this._height = height;
    }
  }, {
    key: "layout",
    value: function layout() {
      var _this = this;

      if (this._height !== this._canvas.offsetHeight || this._width !== this._canvas.offsetWidth) {
        this._redraw(function () {
          var pixelRatio = getPixelRatio(_this._canvas);
          _this._canvas.style.width = "".concat(_this._width, "px");
          _this._canvas.style.height = "".concat(_this._height, "px");
          _this._canvas.width = Math.floor(_this._width * pixelRatio);
          _this._canvas.height = Math.floor(_this._height * pixelRatio);

          _this._ctx.scale(pixelRatio, pixelRatio);
        });
      } else {
        this.flush();
      }
    }
    /**
     * åˆ·æ–°
     */

  }, {
    key: "flush",
    value: function flush() {
      var _this2 = this;

      if (this.requestAnimationId) {
        cancelAnimationFrame(this.requestAnimationId);
        this.requestAnimationId = null;
      }

      this.requestAnimationId = requestAnimationFrame(function () {
        _this2._redraw();
      });
    }
    /**
     * è·å–å›¾ç‰‡
     * @returns {HTMLCanvasElement}
     */

  }, {
    key: "getImage",
    value: function getImage() {
      return this._canvas;
    }
  }]);

  return View;
}();

var TechnicalIndicatorView = /*#__PURE__*/function (_View) {
  _inherits(TechnicalIndicatorView, _View);

  var _super = _createSuper(TechnicalIndicatorView);

  function TechnicalIndicatorView(container, chartStore, xAxis, yAxis, paneId) {
    var _this;

    _classCallCheck(this, TechnicalIndicatorView);

    _this = _super.call(this, container, chartStore);
    _this._xAxis = xAxis;
    _this._yAxis = yAxis;
    _this._paneId = paneId;
    return _this;
  }

  _createClass(TechnicalIndicatorView, [{
    key: "_draw",
    value: function _draw() {
      this._ctx.globalCompositeOperation = 'destination-over';

      this._drawContent();
    }
  }, {
    key: "_drawContent",
    value: function _drawContent() {
      this._drawTechs();

      this._drawGrid();
    }
    /**
     * ç»˜åˆ¶ç½‘æ ¼
     */

  }, {
    key: "_drawGrid",
    value: function _drawGrid() {
      var _this2 = this;

      var gridOptions = this._chartStore.styleOptions().grid;

      if (!gridOptions.show) {
        return;
      }

      var gridHorizontalOptions = gridOptions.horizontal;

      this._ctx.save();

      if (gridHorizontalOptions.show) {
        this._ctx.strokeStyle = gridHorizontalOptions.color;
        this._ctx.lineWidth = gridHorizontalOptions.size;

        if (gridHorizontalOptions.style === LineStyle.DASH) {
          this._ctx.setLineDash(gridHorizontalOptions.dashValue);
        } else {
          this._ctx.setLineDash([]);
        }

        this._yAxis.ticks().forEach(function (tick) {
          renderHorizontalLine(_this2._ctx, tick.y, 0, _this2._width);
        });
      }

      var gridVerticalOptions = gridOptions.vertical;

      if (gridVerticalOptions.show) {
        this._ctx.strokeStyle = gridVerticalOptions.color;
        this._ctx.lineWidth = gridVerticalOptions.size;

        if (gridVerticalOptions.style === LineStyle.DASH) {
          this._ctx.setLineDash(gridVerticalOptions.dashValue);
        } else {
          this._ctx.setLineDash([]);
        }

        this._xAxis.ticks().forEach(function (tick) {
          renderVerticalLine(_this2._ctx, tick.x, 0, _this2._height);
        });
      }

      this._ctx.restore();
    }
    /**
     * ç»˜åˆ¶æŒ‡æ ‡
     */

  }, {
    key: "_drawTechs",
    value: function _drawTechs() {
      var _this3 = this;

      this._ctx.globalCompositeOperation = 'source-over';

      var techOptions = this._chartStore.styleOptions().technicalIndicator;

      var techs = this._chartStore.technicalIndicatorStore().instances(this._paneId);

      techs.forEach(function (tech) {
        var plots = tech.plots;
        var lines = [];

        var dataList = _this3._chartStore.dataList();

        var techResult = tech.result;
        var styles = tech.styles || techOptions; // æŠ€æœ¯æŒ‡æ ‡è‡ªå®šä¹‰ç»˜åˆ¶

        if (tech.render) {
          _this3._ctx.save();

          tech.render({
            ctx: _this3._ctx,
            dataSource: {
              from: _this3._chartStore.timeScaleStore().from(),
              to: _this3._chartStore.timeScaleStore().to(),
              kLineDataList: _this3._chartStore.dataList(),
              technicalIndicatorDataList: techResult
            },
            viewport: {
              width: _this3._width,
              height: _this3._height,
              dataSpace: _this3._chartStore.timeScaleStore().dataSpace(),
              barSpace: _this3._chartStore.timeScaleStore().barSpace()
            },
            styles: styles,
            xAxis: _this3._xAxis,
            yAxis: _this3._yAxis
          });

          _this3._ctx.restore();
        }

        var lineColors = techOptions.line.colors || [];
        var lineColorSize = lineColors.length;

        var isCandleYAxis = _this3._yAxis.isCandleYAxis();

        _this3._ctx.lineWidth = 1;

        _this3._drawGraphics(function (x, i, kLineData, halfBarSpace, barSpace) {
          var techData = techResult[i] || {};
          var lineCount = 0;

          if (tech.shouldOhlc && !isCandleYAxis) {
            _this3._drawCandleBar(x, halfBarSpace, barSpace, i, kLineData, styles.bar, CandleType.OHLC);
          }

          plots.forEach(function (plot) {
            var value = techData[plot.key];

            var valueY = _this3._yAxis.convertToPixel(value);

            switch (plot.type) {
              case TechnicalIndicatorPlotType.CIRCLE:
                {
                  if (isValid(value)) {
                    var plotStyle = getTechnicalIndicatorPlotStyle(dataList, techResult, i, plot, styles, {
                      color: styles.circle.noChangeColor,
                      isStroke: true
                    });

                    _this3._drawCircle({
                      x: x,
                      y: valueY,
                      radius: halfBarSpace,
                      color: plotStyle.color,
                      isStroke: plotStyle.isStroke
                    });
                  }

                  break;
                }

              case TechnicalIndicatorPlotType.BAR:
                {
                  if (isValid(value)) {
                    var baseValue;

                    if (isValid(plot.baseValue)) {
                      baseValue = plot.baseValue;
                    } else {
                      baseValue = _this3._yAxis.min();
                    }

                    var baseValueY = _this3._yAxis.convertToPixel(baseValue);

                    var height = Math.abs(baseValueY - valueY);
                    var bar = {
                      x: x - halfBarSpace,
                      width: halfBarSpace * 2,
                      height: Math.max(1, height)
                    };

                    if (valueY > baseValueY) {
                      bar.y = baseValueY;
                    } else {
                      bar.y = height < 1 ? baseValueY - 1 : valueY;
                    }

                    var _plotStyle = getTechnicalIndicatorPlotStyle(dataList, techResult, i, plot, styles, {
                      color: styles.bar.noChangeColor
                    });

                    bar.color = _plotStyle.color;
                    bar.isStroke = _plotStyle.isStroke;

                    _this3._drawBar(bar);
                  }

                  break;
                }

              case TechnicalIndicatorPlotType.LINE:
                {
                  var coordinate = null;

                  if (isValid(value)) {
                    coordinate = {
                      x: x,
                      y: valueY
                    };
                  }

                  if (lines[lineCount]) {
                    lines[lineCount].coordinates.push(coordinate);
                  } else {
                    var _plotStyle2 = getTechnicalIndicatorPlotStyle(dataList, techResult, i, plot, styles, {
                      color: lineColors[lineCount % lineColorSize]
                    });

                    lines[lineCount] = {
                      color: _plotStyle2.color,
                      coordinates: [coordinate]
                    };
                  }

                  lineCount++;
                  break;
                }
            }
          });
        }, function () {
          _this3._drawLines(lines, styles);
        });
      });
      this._ctx.globalCompositeOperation = 'destination-over';
    }
    /**
     * ç»˜åˆ¶å›¾å½¢
     * @param onDrawing
     * @param onDrawEnd
     */

  }, {
    key: "_drawGraphics",
    value: function _drawGraphics(onDrawing, onDrawEnd) {
      var visibleDataList = this._chartStore.visibleDataList();

      var barSpace = this._chartStore.timeScaleStore().barSpace();

      var halfBarSpace = this._chartStore.timeScaleStore().halfBarSpace();

      visibleDataList.forEach(function (_ref, n) {
        var x = _ref.x,
            index = _ref.index,
            data = _ref.data;
        onDrawing(x, index, data, halfBarSpace, barSpace, n);
      });
      onDrawEnd && onDrawEnd();
    }
    /**
     * ç»˜åˆ¶çº¿
     * @param lines
     * @param techOptions
     */

  }, {
    key: "_drawLines",
    value: function _drawLines(lines, techOptions) {
      var _this4 = this;

      this._ctx.lineWidth = techOptions.line.size;
      lines.forEach(function (line) {
        _this4._ctx.strokeStyle = line.color;
        renderLine(_this4._ctx, line.coordinates);
      });
    }
    /**
     * ç»˜åˆ¶æŸ±
     */

  }, {
    key: "_drawBar",
    value: function _drawBar(bar) {
      if (bar.isStroke) {
        this._ctx.strokeStyle = bar.color;

        this._ctx.strokeRect(bar.x + 0.5, bar.y, bar.width - 1, bar.height);
      } else {
        this._ctx.fillStyle = bar.color;

        this._ctx.fillRect(bar.x, bar.y, bar.width, bar.height);
      }
    }
    /**
     * ç»˜åˆ¶åœ†ç‚¹
     * @param circle
     * @private
     */

  }, {
    key: "_drawCircle",
    value: function _drawCircle(circle) {
      this._ctx.strokeStyle = circle.color;
      this._ctx.fillStyle = circle.color;

      this._ctx.beginPath();

      this._ctx.arc(circle.x, circle.y, circle.radius, Math.PI * 2, 0, true);

      if (circle.isStroke) {
        this._ctx.stroke();
      } else {
        this._ctx.fill();
      }

      this._ctx.closePath();
    }
    /**
     * ç»˜åˆ¶èœ¡çƒ›æŸ±
     * @param x
     * @param halfBarSpace
     * @param barSpace
     * @param dataIndex
     * @param kLineData
     * @param barOptions
     * @param barStyle
     */

  }, {
    key: "_drawCandleBar",
    value: function _drawCandleBar(x, halfBarSpace, barSpace, dataIndex, kLineData, barOptions, barStyle) {
      var open = kLineData.open,
          close = kLineData.close,
          high = kLineData.high,
          low = kLineData.low;

      if (close > open) {
        this._ctx.strokeStyle = barOptions.upColor;
        this._ctx.fillStyle = barOptions.upColor;
      } else if (close < open) {
        this._ctx.strokeStyle = barOptions.downColor;
        this._ctx.fillStyle = barOptions.downColor;
      } else {
        this._ctx.strokeStyle = barOptions.noChangeColor;
        this._ctx.fillStyle = barOptions.noChangeColor;
      }

      var openY = this._yAxis.convertToPixel(open);

      var closeY = this._yAxis.convertToPixel(close);

      var highY = this._yAxis.convertToPixel(high);

      var lowY = this._yAxis.convertToPixel(low);

      var highEndY = Math.min(openY, closeY);
      var lowStartY = Math.max(openY, closeY);

      this._ctx.fillRect(x - 0.5, highY, 1, highEndY - highY);

      this._ctx.fillRect(x - 0.5, lowStartY, 1, lowY - lowStartY);

      var barHeight = Math.max(1, lowStartY - highEndY);

      switch (barStyle) {
        case CandleType.CANDLE_SOLID:
          {
            this._ctx.fillRect(x - halfBarSpace, highEndY, barSpace, barHeight);

            break;
          }

        case CandleType.CANDLE_STROKE:
          {
            this._ctx.strokeRect(x - halfBarSpace + 0.5, highEndY, barSpace - 1, barHeight);

            break;
          }

        case CandleType.CANDLE_UP_STROKE:
          {
            if (close > open) {
              this._ctx.strokeRect(x - halfBarSpace + 0.5, highEndY, barSpace - 1, barHeight);
            } else {
              this._ctx.fillRect(x - halfBarSpace, highEndY, barSpace, barHeight);
            }

            break;
          }

        case CandleType.CANDLE_DOWN_STROKE:
          {
            if (close > open) {
              this._ctx.fillRect(x - halfBarSpace, highEndY, barSpace, barHeight);
            } else {
              this._ctx.strokeRect(x - halfBarSpace + 0.5, highEndY, barSpace - 1, barHeight);
            }

            break;
          }

        default:
          {
            this._ctx.fillRect(x - 0.5, highY, 1, lowY - highY);

            this._ctx.fillRect(x - halfBarSpace, openY - 0.5, halfBarSpace, 1);

            this._ctx.fillRect(x, closeY - 0.5, halfBarSpace, 1);

            break;
          }
      }
    }
  }]);

  return TechnicalIndicatorView;
}(View);

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * ç»˜åˆ¶æ–‡å­—
 * @param ctx
 * @param color
 * @param x
 * @param y
 * @param text
 */
function renderText(ctx, color, x, y, text) {
  ctx.fillStyle = color;
  ctx.fillText(text, x, y);
}

var TechnicalIndicatorOverlayView = /*#__PURE__*/function (_View) {
  _inherits(TechnicalIndicatorOverlayView, _View);

  var _super = _createSuper(TechnicalIndicatorOverlayView);

  function TechnicalIndicatorOverlayView(container, chartStore, xAxis, yAxis, paneId) {
    var _this;

    _classCallCheck(this, TechnicalIndicatorOverlayView);

    _this = _super.call(this, container, chartStore);
    _this._xAxis = xAxis;
    _this._yAxis = yAxis;
    _this._paneId = paneId;
    return _this;
  }

  _createClass(TechnicalIndicatorOverlayView, [{
    key: "_draw",
    value: function _draw() {
      this._ctx.textBaseline = 'alphabetic';

      this._drawTag();

      this._drawShape();

      this._drawAnnotation();

      var crosshair = this._chartStore.crosshairStore().get();

      if (crosshair.kLineData) {
        var styleOptions = this._chartStore.styleOptions();

        var crosshairOptions = styleOptions.crosshair;

        if (crosshair.paneId === this._paneId) {
          // ç»˜åˆ¶åå­—å…‰æ ‡æ°´å¹³çº¿
          this._drawCrosshairLine(crosshairOptions, 'horizontal', crosshair.y, 0, this._width, renderHorizontalLine);
        }

        if (crosshair.paneId) {
          // ç»˜åˆ¶åå­—å…‰æ ‡å‚ç›´çº¿
          this._drawCrosshairLine(crosshairOptions, 'vertical', crosshair.realX, 0, this._height, renderVerticalLine);
        }

        this._drawTooltip(crosshair, this._chartStore.technicalIndicatorStore().instances(this._paneId));
      }
    }
    /**
     * ç»˜åˆ¶æ³¨è§£
     */

  }, {
    key: "_drawAnnotation",
    value: function _drawAnnotation() {
      var _this2 = this;

      var annotations = this._chartStore.annotationStore().get(this._paneId);

      if (annotations) {
        annotations.forEach(function (annotation) {
          annotation.draw(_this2._ctx);
        });
      }
    }
    /**
     * ç»˜åˆ¶æ ‡ç­¾
     */

  }, {
    key: "_drawTag",
    value: function _drawTag() {
      var _this3 = this;

      var tags = this._chartStore.tagStore().get(this._paneId);

      if (tags) {
        tags.forEach(function (tag) {
          tag.drawMarkLine(_this3._ctx);
        });
      }
    }
    /**
     * ç»˜åˆ¶å›¾å½¢æ ‡è®°
     * @private
     */

  }, {
    key: "_drawShape",
    value: function _drawShape() {
      var _this4 = this;

      this._chartStore.shapeStore().instances(this._paneId).forEach(function (shape) {
        shape.draw(_this4._ctx);
      });

      var progressShape = this._chartStore.shapeStore().progressInstance();

      if (progressShape.paneId === this._paneId) {
        progressShape.instance.draw(this._ctx);
      }
    }
    /**
     * ç»˜åˆ¶å›¾ä¾‹
     * @param crosshair
     * @param techs
     * @private
     */

  }, {
    key: "_drawTooltip",
    value: function _drawTooltip(crosshair, techs) {
      var techOptions = this._chartStore.styleOptions().technicalIndicator;

      this._drawBatchTechToolTip(crosshair, techs, techOptions, 0, this._shouldDrawTooltip(crosshair, techOptions.tooltip));
    }
    /**
     * ç»˜åˆ¶åå­—å…‰æ ‡çº¿
     * @param crosshairOptions
     * @param optionsKey
     * @param fixed
     * @param start
     * @param end
     * @param drawLine
     * @private
     */

  }, {
    key: "_drawCrosshairLine",
    value: function _drawCrosshairLine(crosshairOptions, optionsKey, fixed, start, end, drawLine) {
      var crosshairDirectionOptions = crosshairOptions[optionsKey];
      var crosshairLineOptions = crosshairDirectionOptions.line;

      if (!crosshairOptions.show || !crosshairDirectionOptions.show || !crosshairLineOptions.show) {
        return;
      }

      this._ctx.save();

      this._ctx.lineWidth = crosshairLineOptions.size;
      this._ctx.strokeStyle = crosshairLineOptions.color;

      if (crosshairLineOptions.style === LineStyle.DASH) {
        this._ctx.setLineDash(crosshairLineOptions.dashValue);
      }

      drawLine(this._ctx, fixed, start, end);

      this._ctx.restore();
    }
    /**
     * æ‰¹é‡ç»˜åˆ¶æŠ€æœ¯æŒ‡æ ‡æç¤º
     * @param crosshair
     * @param techs
     * @param techOptions
     * @param offsetTop
     * @param isDrawTechTooltip
     */

  }, {
    key: "_drawBatchTechToolTip",
    value: function _drawBatchTechToolTip(crosshair, techs, techOptions) {
      var _this5 = this;

      var offsetTop = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var isDrawTechTooltip = arguments.length > 4 ? arguments[4] : undefined;

      if (!isDrawTechTooltip) {
        return;
      }

      var techTooltipOptions = techOptions.tooltip;
      var top = offsetTop;
      techs.forEach(function (tech) {
        _this5._drawTechTooltip(crosshair, tech, techOptions, top);

        top += techTooltipOptions.text.marginTop + techTooltipOptions.text.size + techTooltipOptions.text.marginBottom;
      });
    }
    /**
     * ç»˜åˆ¶æŒ‡æ ‡å›¾ä¾‹
     * @param crosshair
     * @param tech
     * @param techOptions
     * @param offsetTop
     * @private
     */

  }, {
    key: "_drawTechTooltip",
    value: function _drawTechTooltip(crosshair, tech, techOptions) {
      var _this6 = this;

      var offsetTop = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var techTooltipOptions = techOptions.tooltip;
      var techTooltipTextOptions = techTooltipOptions.text;
      var textMarginLeft = techTooltipTextOptions.marginLeft;
      var textMarginRight = techTooltipTextOptions.marginRight;
      var textSize = techTooltipTextOptions.size;
      var textColor = techTooltipTextOptions.color;
      var labelX = 0;
      var labelY = techTooltipTextOptions.marginTop + offsetTop;

      var tooltipData = this._getTechTooltipData(crosshair, tech, techOptions);

      this._ctx.textBaseline = 'top';
      this._ctx.font = createFont(textSize, techTooltipTextOptions.weight, techTooltipTextOptions.family);

      if (techTooltipOptions.showName) {
        var nameText = tooltipData.name;
        var nameTextWidth = calcTextWidth(this._ctx, nameText);
        labelX += textMarginLeft;
        renderText(this._ctx, textColor, labelX, labelY, nameText);
        labelX += nameTextWidth;

        if (!techTooltipOptions.showParams) {
          labelX += textMarginRight;
        }
      }

      if (techTooltipOptions.showParams) {
        var calcParamText = tooltipData.calcParamText;
        var calcParamTextWidth = calcTextWidth(this._ctx, calcParamText);

        if (!techTooltipOptions.showName) {
          labelX += textMarginLeft;
        }

        renderText(this._ctx, textColor, labelX, labelY, calcParamText);
        labelX += calcParamTextWidth + textMarginRight;
      }

      tooltipData.values.forEach(function (v) {
        labelX += textMarginLeft;
        var text = "".concat(v.title).concat(v.value);
        var textWidth = calcTextWidth(_this6._ctx, text);
        renderText(_this6._ctx, v.color, labelX, labelY, text);
        labelX += textWidth + textMarginRight;
      });
    }
    /**
     * æ˜¯å¦éœ€è¦ç»˜åˆ¶å›¾ä¾‹
     * @param crosshair
     * @param tooltipOptions
     * @return {boolean|boolean|*}
     */

  }, {
    key: "_shouldDrawTooltip",
    value: function _shouldDrawTooltip(crosshair, tooltipOptions) {
      var showRule = tooltipOptions.showRule;
      return showRule === TooltipShowRule.ALWAYS || showRule === TooltipShowRule.FOLLOW_CROSS && !!crosshair.paneId;
    }
    /**
     * è·å–æŠ€æœ¯æŒ‡æ ‡æç¤ºæ•°æ®
     * @param techData
     * @param tech
     * @returns
     */

  }, {
    key: "_getTechTooltipData",
    value: function _getTechTooltipData(crosshair, tech, techOptions) {
      var dataIndex = crosshair.dataIndex;
      var styles = tech.styles || techOptions;
      var techResult = tech.result;
      var techData = techResult[dataIndex];

      var dataList = this._chartStore.dataList();

      var calcParams = tech.calcParams;
      var plots = tech.plots;
      var precision = tech.precision;
      var shouldFormatBigNumber = tech.shouldFormatBigNumber;
      var name = '';
      var calcParamText = '';

      if (plots.length > 0) {
        name = tech.shortName || tech.name;
      }

      if (calcParams.length > 0) {
        var params = calcParams.map(function (param) {
          if (isObject(param)) {
            return param.value;
          }

          return param;
        });
        calcParamText = "(".concat(params.join(','), ")");
      }

      var lineColors = styles.line.colors || [];
      var colorSize = lineColors.length;
      var lineCount = 0;
      var values = [];
      plots.forEach(function (plot) {
        var defaultStyle = {};

        switch (plot.type) {
          case TechnicalIndicatorPlotType.CIRCLE:
            {
              defaultStyle = {
                color: styles.circle.noChangeColor
              };
              break;
            }

          case TechnicalIndicatorPlotType.BAR:
            {
              defaultStyle = {
                color: styles.bar.noChangeColor
              };
              break;
            }

          case TechnicalIndicatorPlotType.LINE:
            {
              defaultStyle = {
                color: lineColors[lineCount % colorSize] || techOptions.tooltip.text.color
              };
              lineCount++;
              break;
            }
        }

        var plotStyle = getTechnicalIndicatorPlotStyle(dataList, techResult, crosshair.dataIndex, plot, styles, defaultStyle);
        var data = {};

        if (isValid(plot.title)) {
          var value = (techData || {})[plot.key];

          if (isValid(value)) {
            value = formatPrecision(value, precision);

            if (shouldFormatBigNumber) {
              value = formatBigNumber(value);
            }
          }

          data.title = plot.title;
          data.value = value || techOptions.tooltip.defaultValue;
          data.color = plotStyle.color;
        }

        values.push(data);
      });
      return {
        values: values,
        name: name,
        calcParamText: calcParamText
      };
    }
  }]);

  return TechnicalIndicatorOverlayView;
}(View);

var TechnicalIndicatorWidget = /*#__PURE__*/function (_Widget) {
  _inherits(TechnicalIndicatorWidget, _Widget);

  var _super = _createSuper(TechnicalIndicatorWidget);

  function TechnicalIndicatorWidget() {
    _classCallCheck(this, TechnicalIndicatorWidget);

    return _super.apply(this, arguments);
  }

  _createClass(TechnicalIndicatorWidget, [{
    key: "_createMainView",
    value: function _createMainView(container, props) {
      return new TechnicalIndicatorView(container, props.chartStore, props.xAxis, props.yAxis, props.paneId);
    }
  }, {
    key: "_createOverlayView",
    value: function _createOverlayView(container, props) {
      return new TechnicalIndicatorOverlayView(container, props.chartStore, props.xAxis, props.yAxis, props.paneId);
    }
  }]);

  return TechnicalIndicatorWidget;
}(Widget);

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * ç»˜åˆ¶å¸¦è¾¹æ¡†çš„åœ†è§’å¡«å……çŸ©å½¢
 * @param ctx
 * @param fillColor
 * @param borderColor
 * @param borderSize
 * @param x
 * @param y
 * @param width
 * @param height
 * @param borderRadius
 */
function renderStrokeFillRoundRect(ctx, fillColor, borderColor, borderSize, x, y, width, height, borderRadius) {
  renderFillRoundRect(ctx, fillColor, x, y, width, height, borderRadius);
  renderStrokeRoundRect(ctx, borderColor, borderSize, x, y, width, height, borderRadius);
}
/**
 * ç»˜åˆ¶å¡«å……çš„çŸ©å½¢
 * @param ctx
 * @param color
 * @param x
 * @param y
 * @param width
 * @param height
 */

function renderFillRect(ctx, color, x, y, width, height) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, width, height);
}
/**
 * ç»˜åˆ¶åœ†è§’ç©ºå¿ƒçŸ©å½¢
 * @param ctx
 * @param borderColor
 * @param borderSize
 * @param x
 * @param y
 * @param w
 * @param h
 * @param r
 */

function renderStrokeRoundRect(ctx, borderColor, borderSize, x, y, w, h, r) {
  ctx.lineWidth = borderSize;
  ctx.strokeStyle = borderColor;
  renderRoundRect(ctx, x, y, w, h, r);
  ctx.stroke();
}
/**
 * ç»˜åˆ¶å¡«å……åœ†è§’çŸ©å½¢
 * @param ctx
 * @param color
 * @param x
 * @param y
 * @param w
 * @param h
 * @param r
 */

function renderFillRoundRect(ctx, color, x, y, w, h, r) {
  ctx.fillStyle = color;
  renderRoundRect(ctx, x, y, w, h, r);
  ctx.fill();
}
/**
 * ç»˜åˆ¶åœ†è§’çŸ©å½¢
 * @param ctx
 * @param x
 * @param y
 * @param w
 * @param h
 * @param r
 */

function renderRoundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}

var YAxisView = /*#__PURE__*/function (_View) {
  _inherits(YAxisView, _View);

  var _super = _createSuper(YAxisView);

  function YAxisView(container, chartStore, yAxis, paneId) {
    var _this;

    _classCallCheck(this, YAxisView);

    _this = _super.call(this, container, chartStore);
    _this._yAxis = yAxis;
    _this._paneId = paneId;
    return _this;
  }

  _createClass(YAxisView, [{
    key: "_draw",
    value: function _draw() {
      var yAxisOptions = this._chartStore.styleOptions().yAxis;

      if (yAxisOptions.show) {
        this._drawAxisLine(yAxisOptions);

        this._drawTickLines(yAxisOptions);

        this._drawTickLabels(yAxisOptions);

        this._drawTechLastValue();

        this._drawLastPriceLabel();
      }
    }
  }, {
    key: "_drawAxisLine",
    value: function _drawAxisLine(yAxisOptions) {
      var axisLine = yAxisOptions.axisLine;

      if (!axisLine.show) {
        return;
      }

      this._ctx.strokeStyle = axisLine.color;
      this._ctx.lineWidth = axisLine.size;
      var x;

      if (this._yAxis.isFromYAxisZero()) {
        x = 0;
      } else {
        x = this._width - 1;
      }

      renderVerticalLine(this._ctx, x, 0, this._height);
    }
  }, {
    key: "_drawTickLines",
    value: function _drawTickLines(yAxisOptions) {
      var _this2 = this;

      var tickLine = yAxisOptions.tickLine;

      if (!tickLine.show) {
        return;
      }

      this._ctx.lineWidth = tickLine.size;
      this._ctx.strokeStyle = tickLine.color;
      var tickLineLength = tickLine.length;
      var startX;
      var endX;

      if (this._yAxis.isFromYAxisZero()) {
        startX = 0;

        if (yAxisOptions.axisLine.show) {
          startX += yAxisOptions.axisLine.size;
        }

        endX = startX + tickLineLength;
      } else {
        startX = this._width;

        if (yAxisOptions.axisLine.show) {
          startX -= yAxisOptions.axisLine.size;
        }

        endX = startX - tickLineLength;
      }

      this._yAxis.ticks().forEach(function (tick) {
        renderHorizontalLine(_this2._ctx, tick.y, startX, endX);
      });
    }
  }, {
    key: "_drawTickLabels",
    value: function _drawTickLabels(yAxisOptions) {
      var _this3 = this;

      var tickText = yAxisOptions.tickText;

      if (!tickText.show) {
        return;
      }

      var tickLine = yAxisOptions.tickLine;
      var tickLineShow = tickLine.show;
      var tickLineLength = tickLine.length;
      var labelX;

      if (this._yAxis.isFromYAxisZero()) {
        labelX = tickText.paddingLeft;

        if (yAxisOptions.axisLine.show) {
          labelX += yAxisOptions.axisLine.size;
        }

        if (tickLineShow) {
          labelX += tickLineLength;
        }

        this._ctx.textAlign = 'left';
      } else {
        labelX = this._width - tickText.paddingRight;

        if (yAxisOptions.axisLine.show) {
          labelX -= yAxisOptions.axisLine.size;
        }

        if (tickLineShow) {
          labelX -= tickLineLength;
        }

        this._ctx.textAlign = 'right';
      }

      this._ctx.textBaseline = 'middle';
      this._ctx.font = createFont(tickText.size, tickText.weight, tickText.family);
      this._ctx.fillStyle = tickText.color;

      this._yAxis.ticks().forEach(function (tick) {
        _this3._ctx.fillText(tick.v, labelX, tick.y);
      });

      this._ctx.textAlign = 'left';
    }
    /**
     * ç»˜åˆ¶æŠ€æœ¯æŒ‡æ ‡æœ€åå€¼
     * @private
     */

  }, {
    key: "_drawTechLastValue",
    value: function _drawTechLastValue() {
      var _this4 = this;

      var techOptions = this._chartStore.styleOptions().technicalIndicator;

      var lastValueMarkOptions = techOptions.lastValueMark;

      if (!lastValueMarkOptions.show || !lastValueMarkOptions.text.show) {
        return;
      }

      var techs = this._chartStore.technicalIndicatorStore().instances(this._paneId);

      var dataList = this._chartStore.dataList();

      techs.forEach(function (tech) {
        var techResult = tech.result || [];
        var dataSize = techResult.length;
        var techData = techResult[dataSize - 1] || {};
        var plots = tech.plots;
        var cbData = {
          prev: {
            kLineData: dataList[dataSize - 2],
            technicalIndicatorData: techResult[dataSize - 2]
          },
          current: {
            kLineData: dataList[dataSize - 1],
            technicalIndicatorData: techData
          },
          next: {
            kLineData: null,
            technicalIndicatorData: null
          }
        };
        var precision = tech.precision;
        var styles = tech.styles || techOptions;
        var colors = styles.line.colors || [];
        var colorSize = colors.length;
        var lineCount = 0;
        plots.forEach(function (plot) {
          var value = techData[plot.key];
          var backgroundColor;

          switch (plot.type) {
            case TechnicalIndicatorPlotType.CIRCLE:
              {
                backgroundColor = plot.color && plot.color(cbData, styles) || styles.circle.noChangeColor;
                break;
              }

            case TechnicalIndicatorPlotType.BAR:
              {
                backgroundColor = plot.color && plot.color(cbData, styles) || styles.bar.noChangeColor;
                break;
              }

            case TechnicalIndicatorPlotType.LINE:
              {
                backgroundColor = colors[lineCount % colorSize];
                lineCount++;
                break;
              }
          }

          if (isValid(value)) {
            _this4._drawMarkLabel(value, precision, tech.shouldFormatBigNumber, _objectSpread2(_objectSpread2({}, lastValueMarkOptions.text), {}, {
              backgroundColor: backgroundColor
            }));
          }
        });
      });
    }
    /**
     * ç»˜åˆ¶æœ€æ–°ä»·æ–‡å­—
     * @private
     */

  }, {
    key: "_drawLastPriceLabel",
    value: function _drawLastPriceLabel() {
      if (!this._yAxis.isCandleYAxis()) {
        return;
      }

      var priceMarkOptions = this._chartStore.styleOptions().candle.priceMark;

      var lastPriceMarkOptions = priceMarkOptions.last;

      if (!priceMarkOptions.show || !lastPriceMarkOptions.show || !lastPriceMarkOptions.text.show) {
        return;
      }

      var dataList = this._chartStore.dataList();

      var kLineData = dataList[dataList.length - 1];

      if (!kLineData) {
        return;
      }

      var close = kLineData.close;
      var open = kLineData.open;
      var backgroundColor;

      if (close > open) {
        backgroundColor = lastPriceMarkOptions.upColor;
      } else if (close < open) {
        backgroundColor = lastPriceMarkOptions.downColor;
      } else {
        backgroundColor = lastPriceMarkOptions.noChangeColor;
      }

      this._drawMarkLabel(close, this._chartStore.pricePrecision(), false, _objectSpread2(_objectSpread2({}, lastPriceMarkOptions.text), {}, {
        backgroundColor: backgroundColor
      }));
    }
    /**
     * ç»˜åˆ¶æ ‡è®°label
     * @param value
     * @param precision
     * @param shouldFormatBigNumber
     * @param size
     * @param weight
     * @param family
     * @param color
     * @param backgroundColor
     * @param borderRadius
     * @param paddingLeft
     * @param paddingTop
     * @param paddingRight
     * @param paddingBottom
     * @private
     */

  }, {
    key: "_drawMarkLabel",
    value: function _drawMarkLabel(value, precision, shouldFormatBigNumber, _ref) {
      var size = _ref.size,
          weight = _ref.weight,
          family = _ref.family,
          color = _ref.color,
          backgroundColor = _ref.backgroundColor,
          borderRadius = _ref.borderRadius,
          paddingLeft = _ref.paddingLeft,
          paddingTop = _ref.paddingTop,
          paddingRight = _ref.paddingRight,
          paddingBottom = _ref.paddingBottom;

      var valueY = this._yAxis.convertToNicePixel(value);

      var text;

      if (this._yAxis.yAxisType() === YAxisType.PERCENTAGE) {
        var fromData = (this._chartStore.visibleDataList()[0] || {}).data || {};
        var fromClose = fromData.close;
        text = "".concat(((value - fromClose) / fromClose * 100).toFixed(2), "%");
      } else {
        text = formatPrecision(value, precision);

        if (shouldFormatBigNumber) {
          text = formatBigNumber(text);
        }
      }

      this._ctx.font = createFont(size, weight, family);
      var rectWidth = calcTextWidth(this._ctx, text) + paddingLeft + paddingRight;
      var rectHeight = paddingTop + size + paddingBottom;
      var rectStartX;

      if (this._yAxis.isFromYAxisZero()) {
        rectStartX = 0;
      } else {
        rectStartX = this._width - rectWidth;
      }

      renderFillRoundRect(this._ctx, backgroundColor, rectStartX, valueY - paddingTop - size / 2, rectWidth, rectHeight, borderRadius);
      this._ctx.textBaseline = 'middle';
      renderText(this._ctx, color, rectStartX + paddingLeft, valueY, text);
    }
  }]);

  return YAxisView;
}(View);

var YAxisOverlayView = /*#__PURE__*/function (_View) {
  _inherits(YAxisOverlayView, _View);

  var _super = _createSuper(YAxisOverlayView);

  function YAxisOverlayView(container, chartStore, yAxis, paneId) {
    var _this;

    _classCallCheck(this, YAxisOverlayView);

    _this = _super.call(this, container, chartStore);
    _this._yAxis = yAxis;
    _this._paneId = paneId;
    return _this;
  }

  _createClass(YAxisOverlayView, [{
    key: "_draw",
    value: function _draw() {
      this._ctx.textBaseline = 'middle';

      this._drawTag();

      this._drawCrossHairLabel();
    }
    /**
     * ç»˜åˆ¶æ ‡ç­¾
     * @private
     */

  }, {
    key: "_drawTag",
    value: function _drawTag() {
      var _this2 = this;

      var tags = this._chartStore.tagStore().get(this._paneId);

      if (tags) {
        tags.forEach(function (tag) {
          tag.drawText(_this2._ctx);
        });
      }
    }
  }, {
    key: "_drawCrossHairLabel",
    value: function _drawCrossHairLabel() {
      var crosshair = this._chartStore.crosshairStore().get();

      if (crosshair.paneId !== this._paneId || this._chartStore.dataList().length === 0) {
        return;
      }

      var styleOptions = this._chartStore.styleOptions();

      var crosshairOptions = styleOptions.crosshair;
      var crosshairHorizontalOptions = crosshairOptions.horizontal;
      var crosshairHorizontalTextOptions = crosshairHorizontalOptions.text;

      if (!crosshairOptions.show || !crosshairHorizontalOptions.show || !crosshairHorizontalTextOptions.show) {
        return;
      }

      var value = this._yAxis.convertFromPixel(crosshair.y);

      var text;

      if (this._yAxis.yAxisType() === YAxisType.PERCENTAGE) {
        var fromData = (this._chartStore.visibleDataList()[0] || {}).data || {};
        text = "".concat(((value - fromData.close) / fromData.close * 100).toFixed(2), "%");
      } else {
        var techs = this._chartStore.technicalIndicatorStore().instances(this._paneId);

        var precision = 0;
        var shouldFormatBigNumber = false;

        if (this._yAxis.isCandleYAxis()) {
          precision = this._chartStore.pricePrecision();
        } else {
          techs.forEach(function (tech) {
            precision = Math.max(tech.precision, precision);

            if (!shouldFormatBigNumber) {
              shouldFormatBigNumber = tech.shouldFormatBigNumber;
            }
          });
        }

        text = formatPrecision(value, precision);

        if (shouldFormatBigNumber) {
          text = formatBigNumber(text);
        }
      }

      var rectStartX;
      var borderSize = crosshairHorizontalTextOptions.borderSize;
      var rectWidth = getTextRectWidth(this._ctx, text, crosshairHorizontalTextOptions);
      var rectHeight = getTextRectHeight(crosshairHorizontalTextOptions);

      if (this._yAxis.isFromYAxisZero()) {
        rectStartX = 0;
      } else {
        rectStartX = this._width - rectWidth;
      }

      var rectY = crosshair.y - borderSize - crosshairHorizontalTextOptions.paddingTop - crosshairHorizontalTextOptions.size / 2; // ç»˜åˆ¶yè½´æ–‡å­—å¤–çš„è¾¹æ¡†

      renderStrokeFillRoundRect(this._ctx, crosshairHorizontalTextOptions.backgroundColor, crosshairHorizontalTextOptions.borderColor, borderSize, rectStartX, rectY, rectWidth, rectHeight, crosshairHorizontalTextOptions.borderRadius);
      renderText(this._ctx, crosshairHorizontalTextOptions.color, rectStartX + borderSize + crosshairHorizontalTextOptions.paddingLeft, crosshair.y, text);
    }
  }]);

  return YAxisOverlayView;
}(View);

var YAxisWidget = /*#__PURE__*/function (_Widget) {
  _inherits(YAxisWidget, _Widget);

  var _super = _createSuper(YAxisWidget);

  function YAxisWidget() {
    _classCallCheck(this, YAxisWidget);

    return _super.apply(this, arguments);
  }

  _createClass(YAxisWidget, [{
    key: "_createMainView",
    value: function _createMainView(container, props) {
      return new YAxisView(container, props.chartStore, props.yAxis, props.paneId);
    }
  }, {
    key: "_createOverlayView",
    value: function _createOverlayView(container, props) {
      return new YAxisOverlayView(container, props.chartStore, props.yAxis, props.paneId);
    }
  }]);

  return YAxisWidget;
}(Widget);

var Axis = /*#__PURE__*/function () {
  function Axis(chartStore) {
    _classCallCheck(this, Axis);

    this._chartStore = chartStore;
    this._width = 0;
    this._height = 0;
    this._cacheMinValue = 0;
    this._cacheMaxValue = 0;
    this._minValue = 0;
    this._maxValue = 0;
    this._range = 0;
    this._ticks = [];

    this._initMeasureCanvas();
  }

  _createClass(Axis, [{
    key: "_initMeasureCanvas",
    value: function _initMeasureCanvas() {
      var measureCanvas = createElement('canvas');
      var pixelRatio = getPixelRatio(measureCanvas);
      this._measureCtx = measureCanvas.getContext('2d');

      this._measureCtx.scale(pixelRatio, pixelRatio);
    }
  }, {
    key: "min",
    value: function min() {
      return this._minValue;
    }
  }, {
    key: "max",
    value: function max() {
      return this._maxValue;
    }
  }, {
    key: "width",
    value: function width() {
      return this._width;
    }
  }, {
    key: "height",
    value: function height() {
      return this._height;
    }
  }, {
    key: "setWidth",
    value: function setWidth(width) {
      this._width = width;
    }
  }, {
    key: "setHeight",
    value: function setHeight(height) {
      this._height = height;
    }
    /**
     * è·å–ticks
     * @returns {[]|*[]}
     */

  }, {
    key: "ticks",
    value: function ticks() {
      return this._ticks;
    }
    /**
     * è®¡ç®—è½´
     * @param forceCompute
     */

  }, {
    key: "computeAxis",
    value: function computeAxis(forceCompute) {
      var minMax = this._optimalMinMax(this._computeMinMax());

      this._minValue = minMax.min;
      this._maxValue = minMax.max;
      this._range = minMax.range;

      if (this._cacheMinValue !== minMax.min || this._cacheMaxValue !== minMax.max || forceCompute) {
        this._cacheMinValue = minMax.min;
        this._cacheMaxValue = minMax.max;
        this._ticks = this._optimalTicks(this._computeTicks());
        return true;
      }

      return false;
    }
    /**
     * è®¡ç®—æœ€å¤§æœ€å°å€¼
     * @private
     */

  }, {
    key: "_computeMinMax",
    value: function _computeMinMax() {}
    /**
     * ä¼˜åŒ–æœ€å¤§æœ€å°å€¼
     * @param minMax
     * @private
     */

  }, {
    key: "_optimalMinMax",
    value: function _optimalMinMax(minMax) {}
    /**
     * è®¡ç®—è½´ä¸Šçš„tickå€¼
     */

  }, {
    key: "_computeTicks",
    value: function _computeTicks() {
      var ticks = [];

      if (this._range >= 0) {
        var intervalPrecision = this._computeInterval(this._range);

        var interval = intervalPrecision.interval;
        var precision = intervalPrecision.precision;
        var first = round(Math.ceil(this._minValue / interval) * interval, precision);
        var last = round(Math.floor(this._maxValue / interval) * interval, precision);
        var n = 0;
        var f = first;

        if (interval !== 0) {
          while (f <= last) {
            ticks[n] = {
              v: f.toFixed(precision)
            };
            ++n;
            f += interval;
          }
        }
      }

      return ticks;
    }
    /**
     * è®¡ç®—æœ€ä½³çš„tick
     * @param ticks
     */

  }, {
    key: "_optimalTicks",
    value: function _optimalTicks(ticks) {}
    /**
     * è®¡ç®—é—´éš”
     * @private
     */

  }, {
    key: "_computeInterval",
    value: function _computeInterval(range) {
      var interval = nice(range / 8.0);
      var precision = getPrecision(interval);
      return {
        interval: interval,
        precision: precision
      };
    }
  }]);

  return Axis;
}();

var YAxis = /*#__PURE__*/function (_Axis) {
  _inherits(YAxis, _Axis);

  var _super = _createSuper(YAxis);

  function YAxis(chartStore, isCandleYAxis, paneId) {
    var _this;

    _classCallCheck(this, YAxis);

    _this = _super.call(this, chartStore);
    _this._realRange = 0;
    _this._isCandleYAxis = isCandleYAxis;
    _this._paneId = paneId;
    return _this;
  }

  _createClass(YAxis, [{
    key: "_computeMinMax",
    value: function _computeMinMax() {
      var _this2 = this;

      var minMaxArray = [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER];
      var plotsResult = [];
      var shouldOhlc = false;
      var minValue = Number.MAX_SAFE_INTEGER;
      var maxValue = Number.MIN_SAFE_INTEGER;
      var techPrecision = Number.MAX_SAFE_INTEGER;

      var techs = this._chartStore.technicalIndicatorStore().instances(this._paneId);

      var techGap;
      techs.forEach(function (tech) {
        if (!shouldOhlc) {
          shouldOhlc = tech.shouldOhlc;
        }

        techPrecision = Math.min(techPrecision, tech.precision);

        if (isNumber(tech.minValue)) {
          minValue = Math.min(minValue, tech.minValue);
        }

        if (isNumber(tech.maxValue)) {
          maxValue = Math.max(maxValue, tech.maxValue);
        }

        if (tech.styles) {
          if (!techGap) {
            techGap = {
              top: 0,
              bottom: 0
            };
          }

          var margin = tech.styles.margin;

          if (isNumber(margin.top)) {
            if (margin.top < 1) {
              techGap.top = Math.max(margin.top, techGap.top);
            } else {
              techGap.top = Math.max(margin.top / _this2._height, techGap.top);
            }
          }

          if (isNumber(margin.bottom)) {
            if (margin.bottom < 1) {
              techGap.bottom = Math.max(margin.bottom, techGap.bottom);
            } else {
              techGap.bottom = Math.max(margin.bottom / _this2._height, techGap.bottom);
            }
          }
        }

        plotsResult.push({
          plots: tech.plots,
          result: tech.result
        });
      });
      var precision = 4;

      if (this._isCandleYAxis) {
        var pricePrecision = this._chartStore.pricePrecision();

        if (techPrecision !== Number.MAX_SAFE_INTEGER) {
          precision = Math.min(techPrecision, pricePrecision);
        } else {
          precision = pricePrecision;
        }
      } else {
        if (techPrecision !== Number.MAX_SAFE_INTEGER) {
          precision = techPrecision;
        }
      }

      var visibleDataList = this._chartStore.visibleDataList();

      var candleOptions = this._chartStore.styleOptions().candle;

      var isArea = candleOptions.type === CandleType.AREA;
      var areaValueKey = candleOptions.area.value;
      var shouldCompareHighLow = this._isCandleYAxis && !isArea || !this._isCandleYAxis && shouldOhlc;
      visibleDataList.forEach(function (_ref) {
        var index = _ref.index,
            data = _ref.data;

        if (shouldCompareHighLow) {
          minMaxArray[0] = Math.min(minMaxArray[0], data.low);
          minMaxArray[1] = Math.max(minMaxArray[1], data.high);
        }

        if (_this2._isCandleYAxis && isArea) {
          minMaxArray[0] = Math.min(minMaxArray[0], data[areaValueKey]);
          minMaxArray[1] = Math.max(minMaxArray[1], data[areaValueKey]);
        }

        plotsResult.forEach(function (_ref2) {
          var plots = _ref2.plots,
              result = _ref2.result;
          var techData = result[index] || {};
          plots.forEach(function (plot) {
            var value = techData[plot.key];

            if (isValid(value)) {
              minMaxArray[0] = Math.min(minMaxArray[0], value);
              minMaxArray[1] = Math.max(minMaxArray[1], value);
            }
          });
        });
      });

      if (minMaxArray[0] !== Number.MAX_SAFE_INTEGER && minMaxArray[1] !== Number.MIN_SAFE_INTEGER) {
        minMaxArray[0] = Math.min(minValue, minMaxArray[0]);
        minMaxArray[1] = Math.max(maxValue, minMaxArray[1]);
      } else {
        minMaxArray[0] = 0;
        minMaxArray[1] = 10;
      }

      return {
        min: minMaxArray[0],
        max: minMaxArray[1],
        precision: precision,
        specifyMin: minValue,
        specifyMax: maxValue,
        techGap: techGap
      };
    }
  }, {
    key: "_optimalMinMax",
    value: function _optimalMinMax(_ref3) {
      var min = _ref3.min,
          max = _ref3.max,
          precision = _ref3.precision,
          specifyMin = _ref3.specifyMin,
          specifyMax = _ref3.specifyMax,
          techGap = _ref3.techGap;
      var minValue = min;
      var maxValue = max;
      var yAxisType = this.yAxisType();
      var dif;

      switch (yAxisType) {
        case YAxisType.PERCENTAGE:
          {
            var fromData = (this._chartStore.visibleDataList()[0] || {}).data || {};

            if (isNumber(fromData.close)) {
              minValue = (minValue - fromData.close) / fromData.close * 100;
              maxValue = (maxValue - fromData.close) / fromData.close * 100;
            }

            dif = Math.pow(10, -2);
            break;
          }

        case YAxisType.LOG:
          {
            minValue = log10(minValue);
            maxValue = log10(maxValue);
            dif = 0.05 * index10(-precision);
            break;
          }

        default:
          {
            dif = index10(-precision);
          }
      }

      if (minValue === maxValue || Math.abs(minValue - maxValue) < dif) {
        var minCheck = specifyMin === minValue;
        var maxCheck = specifyMax === maxValue;
        minValue = minCheck ? minValue : maxCheck ? minValue - 8 * dif : minValue - 4 * dif;
        maxValue = maxCheck ? maxValue : minCheck ? maxValue + 8 * dif : maxValue + 4 * dif;
      }

      var marginOptions;

      if (this._isCandleYAxis) {
        marginOptions = this._chartStore.styleOptions().candle.margin;
      } else {
        // å¦‚æœæ˜¯å‰¯å›¾ï¼Œç›´æ¥å–æŒ‡æ ‡çš„æ ·å¼é…ç½®
        marginOptions = techGap ? {
          top: 0,
          bottom: 0
        } : this._chartStore.styleOptions().technicalIndicator.margin;
      }

      var topRate = 0.2;

      if (isNumber(marginOptions.top)) {
        var rate;

        if (marginOptions.top < 1) {
          rate = marginOptions.top;
        } else {
          rate = marginOptions.top / this._height;
        }

        topRate = techGap ? Math.max(techGap.top, rate) : rate;
      }

      var bottomRate = 0.1;

      if (isNumber(marginOptions.bottom)) {
        var _rate;

        if (marginOptions.bottom < 1) {
          _rate = marginOptions.bottom;
        } else {
          _rate = marginOptions.bottom / this._height;
        }

        bottomRate = techGap ? Math.max(techGap.bottom, _rate) : _rate;
      }

      var range = Math.abs(maxValue - minValue); // ä¿è¯æ¯æ¬¡å›¾å½¢ç»˜åˆ¶ä¸Šä¸‹éƒ½ç•™é—´éš™

      minValue = minValue - range * bottomRate;
      maxValue = maxValue + range * topRate;
      range = Math.abs(maxValue - minValue);

      if (yAxisType === YAxisType.LOG) {
        this._realRange = Math.abs(index10(maxValue) - index10(minValue));
      } else {
        this._realRange = range;
      }

      return {
        min: minValue,
        max: maxValue,
        range: range
      };
    }
  }, {
    key: "_optimalTicks",
    value: function _optimalTicks(ticks) {
      var _this3 = this;

      var optimalTicks = [];
      var yAxisType = this.yAxisType();

      var techs = this._chartStore.technicalIndicatorStore().instances(this._paneId);

      var precision = 0;
      var shouldFormatBigNumber = false;

      if (this._isCandleYAxis) {
        precision = this._chartStore.pricePrecision();
      } else {
        techs.forEach(function (tech) {
          precision = Math.max(precision, tech.precision);

          if (!shouldFormatBigNumber) {
            shouldFormatBigNumber = tech.shouldFormatBigNumber;
          }
        });
      }

      var textHeight = this._chartStore.styleOptions().xAxis.tickText.size;

      var intervalPrecision;

      if (yAxisType === YAxisType.LOG) {
        intervalPrecision = this._computeInterval(this._realRange);
      }

      var validY;
      ticks.forEach(function (_ref4) {
        var v = _ref4.v;
        var value;

        var y = _this3._innerConvertToPixel(+v);

        switch (yAxisType) {
          case YAxisType.PERCENTAGE:
            {
              value = "".concat(formatPrecision(v, 2), "%");
              break;
            }

          case YAxisType.LOG:
            {
              value = round(index10(v), intervalPrecision.precision);
              y = _this3._innerConvertToPixel(log10(value));
              value = formatPrecision(value, precision);
              break;
            }

          default:
            {
              value = formatPrecision(v, precision);

              if (shouldFormatBigNumber) {
                value = formatBigNumber(value);
              }

              break;
            }
        }

        if (y > textHeight && y < _this3._height - textHeight && (validY && validY - y > textHeight * 2 || !validY)) {
          optimalTicks.push({
            v: value,
            y: y
          });
          validY = y;
        }
      });
      return optimalTicks;
    }
    /**
     * å†…éƒ¨å€¼è½¬æ¢æˆåæ ‡
     * @param value
     * @return {number}
     * @private
     */

  }, {
    key: "_innerConvertToPixel",
    value: function _innerConvertToPixel(value) {
      return Math.round((1.0 - (value - this._minValue) / this._range) * this._height);
    }
    /**
     * æ˜¯å¦æ˜¯èœ¡çƒ›å›¾è½´
     * @return {*}
     */

  }, {
    key: "isCandleYAxis",
    value: function isCandleYAxis() {
      return this._isCandleYAxis;
    }
    /**
     * yè½´ç±»å‹
     * @return {string|*}
     */

  }, {
    key: "yAxisType",
    value: function yAxisType() {
      if (this._isCandleYAxis) {
        return this._chartStore.styleOptions().yAxis.type;
      }

      return YAxisType.NORMAL;
    }
    /**
     * æ˜¯å¦ä»yè½´0å¼€å§‹
     * @return {boolean|*|boolean}
     */

  }, {
    key: "isFromYAxisZero",
    value: function isFromYAxisZero() {
      var yAxisOptions = this._chartStore.styleOptions().yAxis;

      return yAxisOptions.position === YAxisPosition.LEFT && yAxisOptions.inside || yAxisOptions.position === YAxisPosition.RIGHT && !yAxisOptions.inside;
    }
    /**
     * è·å–è‡ªèº«å®½åº¦
     * @return {number}
     */

  }, {
    key: "getSelfWidth",
    value: function getSelfWidth() {
      var _this4 = this;

      var styleOptions = this._chartStore.styleOptions();

      var yAxisOptions = styleOptions.yAxis;
      var width = yAxisOptions.width;

      if (isNumber(width)) {
        return width;
      }

      var yAxisWidth = 0;

      if (yAxisOptions.show) {
        if (yAxisOptions.axisLine.show) {
          yAxisWidth += yAxisOptions.axisLine.size;
        }

        if (yAxisOptions.tickLine.show) {
          yAxisWidth += yAxisOptions.tickLine.length;
        }

        if (yAxisOptions.tickText.show) {
          var textWidth = 0;
          this._measureCtx.font = createFont(yAxisOptions.tickText.size, yAxisOptions.tickText.weight, yAxisOptions.tickText.family);

          this._ticks.forEach(function (tick) {
            textWidth = Math.max(textWidth, calcTextWidth(_this4._measureCtx, tick.v));
          });

          yAxisWidth += yAxisOptions.tickText.paddingLeft + yAxisOptions.tickText.paddingRight + textWidth;
        }
      }

      var crosshairOptions = styleOptions.crosshair;
      var crosshairVerticalTextWidth = 0;

      if (crosshairOptions.show && crosshairOptions.horizontal.show && crosshairOptions.horizontal.text.show) {
        var techs = this._chartStore.technicalIndicatorStore().instances(this._paneId);

        var techPrecision = 0;
        var shouldFormatBigNumber = false;
        techs.forEach(function (tech) {
          techPrecision = Math.max(tech.precision, techPrecision);

          if (!shouldFormatBigNumber) {
            shouldFormatBigNumber = tech.shouldFormatBigNumber;
          }
        });
        this._measureCtx.font = createFont(crosshairOptions.horizontal.text.size, crosshairOptions.horizontal.text.weight, crosshairOptions.horizontal.text.family);
        var precision = 2;

        if (this.yAxisType() !== YAxisType.PERCENTAGE) {
          if (this._isCandleYAxis) {
            var pricePrecision = this._chartStore.pricePrecision();

            var lastValueMarkOptions = styleOptions.technicalIndicator.lastValueMark;

            if (lastValueMarkOptions.show && lastValueMarkOptions.text.show) {
              precision = Math.max(techPrecision, pricePrecision);
            } else {
              precision = pricePrecision;
            }
          } else {
            precision = techPrecision;
          }
        }

        var valueText = formatPrecision(this._maxValue, precision);

        if (shouldFormatBigNumber) {
          valueText = formatBigNumber(valueText);
        }

        crosshairVerticalTextWidth += crosshairOptions.horizontal.text.paddingLeft + crosshairOptions.horizontal.text.paddingRight + crosshairOptions.horizontal.text.borderSize * 2 + calcTextWidth(this._measureCtx, valueText);
      }

      return Math.max(yAxisWidth, crosshairVerticalTextWidth);
    }
  }, {
    key: "convertFromPixel",
    value: function convertFromPixel(pixel) {
      var value = (1.0 - pixel / this._height) * this._range + this._minValue;

      switch (this.yAxisType()) {
        case YAxisType.PERCENTAGE:
          {
            var fromData = (this._chartStore.visibleDataList()[0] || {}).data || {};

            if (isNumber(fromData.close)) {
              return fromData.close * value / 100 + fromData.close;
            }

            break;
          }

        case YAxisType.LOG:
          {
            return index10(value);
          }

        default:
          {
            return value;
          }
      }
    }
  }, {
    key: "convertToPixel",
    value: function convertToPixel(value) {
      var v;

      switch (this.yAxisType()) {
        case YAxisType.PERCENTAGE:
          {
            var fromData = (this._chartStore.visibleDataList()[0] || {}).data || {};

            if (isNumber(fromData.close)) {
              v = (value - fromData.close) / fromData.close * 100;
            }

            break;
          }

        case YAxisType.LOG:
          {
            v = log10(value);
            break;
          }

        default:
          {
            v = value;
          }
      }

      return this._innerConvertToPixel(v);
    }
    /**
     * å°†å€¼è½¬æ¢æˆåæ ‡ï¼Œå³ä½¿åæ ‡ä¸åœ¨èŒƒå›´å†…ï¼Œä¹Ÿä¼šæ˜¾ç¤ºåœ¨é¡¶éƒ¨æˆ–è€…åº•éƒ¨
     * @param value
     * @return {number}
     */

  }, {
    key: "convertToNicePixel",
    value: function convertToNicePixel(value) {
      var y = this.convertToPixel(value);
      return Math.round(Math.max(this._height * 0.05, Math.min(y, this._height * 0.98)));
    }
  }]);

  return YAxis;
}(Axis);

var TechnicalIndicatorPane = /*#__PURE__*/function (_Pane) {
  _inherits(TechnicalIndicatorPane, _Pane);

  var _super = _createSuper(TechnicalIndicatorPane);

  function TechnicalIndicatorPane(props) {
    var _this;

    _classCallCheck(this, TechnicalIndicatorPane);

    _this = _super.call(this, props);

    if ('height' in props) {
      _this.setHeight(props.height);
    }

    return _this;
  }

  _createClass(TechnicalIndicatorPane, [{
    key: "_initBefore",
    value: function _initBefore(props) {
      this._id = props.id;
      this._yAxis = this._createYAxis(props);
    }
  }, {
    key: "_createYAxis",
    value: function _createYAxis(props) {
      return new YAxis(props.chartStore, false, props.id);
    }
  }, {
    key: "_createMainWidget",
    value: function _createMainWidget(container, props) {
      return new TechnicalIndicatorWidget({
        container: container,
        chartStore: props.chartStore,
        xAxis: props.xAxis,
        yAxis: this._yAxis,
        paneId: props.id
      });
    }
  }, {
    key: "_createYAxisWidget",
    value: function _createYAxisWidget(container, props) {
      return new YAxisWidget({
        container: container,
        chartStore: props.chartStore,
        yAxis: this._yAxis,
        paneId: props.id
      });
    }
  }, {
    key: "setHeight",
    value: function setHeight(height) {
      _get(_getPrototypeOf(TechnicalIndicatorPane.prototype), "setHeight", this).call(this, height);

      this._yAxis.setHeight(height);
    }
  }, {
    key: "setWidth",
    value: function setWidth(mainWidgetWidth, yAxisWidgetWidth) {
      _get(_getPrototypeOf(TechnicalIndicatorPane.prototype), "setWidth", this).call(this, mainWidgetWidth, yAxisWidgetWidth);

      this._yAxis.setWidth(yAxisWidgetWidth);
    }
    /**
     * è·å–id
     * @returns {string}
     */

  }, {
    key: "id",
    value: function id() {
      return this._id;
    }
  }, {
    key: "yAxis",
    value: function yAxis() {
      return this._yAxis;
    }
  }]);

  return TechnicalIndicatorPane;
}(Pane);

var CandleView = /*#__PURE__*/function (_TechnicalIndicatorVi) {
  _inherits(CandleView, _TechnicalIndicatorVi);

  var _super = _createSuper(CandleView);

  function CandleView() {
    _classCallCheck(this, CandleView);

    return _super.apply(this, arguments);
  }

  _createClass(CandleView, [{
    key: "_drawContent",
    value: function _drawContent() {
      var candleOptions = this._chartStore.styleOptions().candle;

      this._drawLastPriceLine(candleOptions.priceMark);

      if (candleOptions.type === CandleType.AREA) {
        this._drawArea(candleOptions);
      } else {
        this._drawLowHighPrice(candleOptions.priceMark, 'high', 'high', Number.MIN_SAFE_INTEGER, [-2, -5], function (price, comparePrice) {
          if (price > comparePrice) {
            return price;
          }
        });

        this._drawLowHighPrice(candleOptions.priceMark, 'low', 'low', Number.MAX_SAFE_INTEGER, [2, 5], function (price, comparePrice) {
          if (price < comparePrice) {
            return price;
          }
        });

        this._drawCandle(candleOptions);
      }

      this._drawTechs();

      this._drawGrid();
    }
    /**
     * ç»˜åˆ¶é¢ç§¯å›¾
     * @param candleOptions
     * @private
     */

  }, {
    key: "_drawArea",
    value: function _drawArea(candleOptions) {
      var _this = this;

      var lineCoordinates = [];
      var areaCoordinates = [];
      var minY = Number.MAX_SAFE_INTEGER;
      var areaOptions = candleOptions.area;

      var onDrawing = function onDrawing(x, i, kLineData, halfBarSpace, barSpace, n) {
        var value = kLineData[areaOptions.value];

        if (isNumber(value)) {
          var y = _this._yAxis.convertToPixel(value);

          if (n === 0) {
            var startX = x - halfBarSpace;
            areaCoordinates.push({
              x: startX,
              y: _this._height
            });
            areaCoordinates.push({
              x: startX,
              y: y
            });
            lineCoordinates.push({
              x: startX,
              y: y
            });
          }

          lineCoordinates.push({
            x: x,
            y: y
          });
          areaCoordinates.push({
            x: x,
            y: y
          });
          minY = Math.min(minY, y);
        }
      };

      var onDrawEnd = function onDrawEnd() {
        var areaCoordinateLength = areaCoordinates.length;

        if (areaCoordinateLength > 0) {
          var lastCoordinate = areaCoordinates[areaCoordinateLength - 1];

          var halfBarSpace = _this._chartStore.timeScaleStore().halfBarSpace();

          var endX = lastCoordinate.x + halfBarSpace;
          lineCoordinates.push({
            x: endX,
            y: lastCoordinate.y
          });
          areaCoordinates.push({
            x: endX,
            y: lastCoordinate.y
          });
          areaCoordinates.push({
            x: endX,
            y: _this._height
          });
        }

        if (lineCoordinates.length > 0) {
          // ç»˜åˆ¶åˆ†æ—¶çº¿
          _this._ctx.lineWidth = areaOptions.lineSize;
          _this._ctx.strokeStyle = areaOptions.lineColor;
          renderLine(_this._ctx, lineCoordinates);
        }

        if (areaCoordinates.length > 0) {
          // ç»˜åˆ¶åˆ†æ—¶çº¿å¡«å……åŒºåŸŸ
          var backgroundColor = areaOptions.backgroundColor;

          if (isArray(backgroundColor)) {
            var gradient = _this._ctx.createLinearGradient(0, _this._height, 0, minY);

            try {
              backgroundColor.forEach(function (_ref) {
                var offset = _ref.offset,
                    color = _ref.color;
                gradient.addColorStop(offset, color);
              });
            } catch (e) {}

            _this._ctx.fillStyle = gradient;
          } else {
            _this._ctx.fillStyle = backgroundColor;
          }

          renderFillPath(_this._ctx, areaCoordinates);
        }
      };

      this._drawGraphics(onDrawing, onDrawEnd);
    }
    /**
     * ç»˜åˆ¶èœ¡çƒ›
     * @param candleOptions
     * @private
     */

  }, {
    key: "_drawCandle",
    value: function _drawCandle(candleOptions) {
      var _this2 = this;

      this._drawGraphics(function (x, i, kLineData, halfBarSpace, barSpace) {
        _this2._drawCandleBar(x, halfBarSpace, barSpace, i, kLineData, candleOptions.bar, candleOptions.type);
      });
    }
    /**
     * æ¸²æŸ“æœ€é«˜æœ€ä½ä»·æ ¼
     * @param priceMarkOptions
     * @param optionKey
     * @param priceKey
     * @param initPriceValue
     * @param offsets
     * @param compare
     * @private
     */

  }, {
    key: "_drawLowHighPrice",
    value: function _drawLowHighPrice(priceMarkOptions, optionKey, priceKey, initPriceValue, offsets, compare) {
      var lowHighPriceMarkOptions = priceMarkOptions[optionKey];

      if (!priceMarkOptions.show || !lowHighPriceMarkOptions.show) {
        return;
      }

      var visibleDataList = this._chartStore.visibleDataList();

      var price = initPriceValue;
      var pos = -1;
      visibleDataList.forEach(function (_ref2) {
        var index = _ref2.index,
            data = _ref2.data;
        var comparePrice = compare(formatValue(data, priceKey, initPriceValue), price);

        if (comparePrice) {
          price = comparePrice;
          pos = index;
        }
      });

      var pricePrecision = this._chartStore.pricePrecision();

      var priceY = this._yAxis.convertToPixel(price);

      var startX = this._xAxis.convertToPixel(pos);

      var startY = priceY + offsets[0];
      this._ctx.textAlign = 'left';
      this._ctx.lineWidth = 1;
      this._ctx.strokeStyle = lowHighPriceMarkOptions.color;
      this._ctx.fillStyle = lowHighPriceMarkOptions.color;
      renderLine(this._ctx, [{
        x: startX - 2,
        y: startY + offsets[0]
      }, {
        x: startX,
        y: startY
      }, {
        x: startX + 2,
        y: startY + offsets[0]
      }]); // ç»˜åˆ¶ç«–çº¿

      var y = startY + offsets[1];
      renderLine(this._ctx, [{
        x: startX,
        y: startY
      }, {
        x: startX,
        y: y
      }, {
        x: startX + 5,
        y: y
      }]);
      this._ctx.font = createFont(lowHighPriceMarkOptions.textSize, lowHighPriceMarkOptions.textWeight, lowHighPriceMarkOptions.textFamily);
      var text = formatPrecision(price, pricePrecision);
      this._ctx.textBaseline = 'middle';

      this._ctx.fillText(text, startX + 5 + lowHighPriceMarkOptions.textMargin, y);
    }
    /**
     * ç»˜åˆ¶æœ€æ–°ä»·çº¿
     * @param priceMarkOptions
     * @private
     */

  }, {
    key: "_drawLastPriceLine",
    value: function _drawLastPriceLine(priceMarkOptions) {
      var lastPriceMarkOptions = priceMarkOptions.last;

      if (!priceMarkOptions.show || !lastPriceMarkOptions.show || !lastPriceMarkOptions.line.show) {
        return;
      }

      var dataList = this._chartStore.dataList();

      var kLineData = dataList[dataList.length - 1];

      if (!kLineData) {
        return;
      }

      var close = kLineData.close;
      var open = kLineData.open;

      var priceY = this._yAxis.convertToNicePixel(close);

      var color;

      if (close > open) {
        color = lastPriceMarkOptions.upColor;
      } else if (close < open) {
        color = lastPriceMarkOptions.downColor;
      } else {
        color = lastPriceMarkOptions.noChangeColor;
      }

      this._ctx.save();

      this._ctx.strokeStyle = color;
      this._ctx.lineWidth = lastPriceMarkOptions.line.size;

      if (lastPriceMarkOptions.line.style === LineStyle.DASH) {
        this._ctx.setLineDash(lastPriceMarkOptions.line.dashValue);
      }

      renderHorizontalLine(this._ctx, priceY, 0, this._width);

      this._ctx.restore();
    }
  }]);

  return CandleView;
}(TechnicalIndicatorView);

var CandleOverlayView = /*#__PURE__*/function (_TechnicalIndicatorOv) {
  _inherits(CandleOverlayView, _TechnicalIndicatorOv);

  var _super = _createSuper(CandleOverlayView);

  function CandleOverlayView() {
    _classCallCheck(this, CandleOverlayView);

    return _super.apply(this, arguments);
  }

  _createClass(CandleOverlayView, [{
    key: "_drawTooltip",
    value: function _drawTooltip(crosshair, techs) {
      var styleOptions = this._chartStore.styleOptions();

      var candleOptions = styleOptions.candle;
      var candleTooltipOptions = candleOptions.tooltip;
      var techOptions = styleOptions.technicalIndicator;
      var techTooltipOptions = techOptions.tooltip;

      var isDrawCandleTooltip = this._shouldDrawTooltip(crosshair, candleTooltipOptions);

      var isDrawTechTooltip = this._shouldDrawTooltip(crosshair, techTooltipOptions);

      if (candleTooltipOptions.showType === TooltipShowType.RECT && techTooltipOptions.showType === TooltipShowType.RECT) {
        this._drawCandleTooltipWithRect(crosshair, techs, candleOptions, isDrawCandleTooltip, techOptions, isDrawTechTooltip);
      } else {
        if (candleTooltipOptions.showType === TooltipShowType.STANDARD) {
          this._drawCandleTooltipWithStandard(crosshair.kLineData, candleOptions, isDrawCandleTooltip);

          if (techTooltipOptions.showType === TooltipShowType.STANDARD) {
            var offsetTop = isDrawCandleTooltip ? candleTooltipOptions.text.size + candleTooltipOptions.text.marginTop : 0;

            this._drawBatchTechToolTip(crosshair, techs, techOptions, offsetTop, isDrawTechTooltip);
          } else {
            this._drawCandleTooltipWithRect(crosshair, techs, candleOptions, false, techOptions, isDrawTechTooltip);
          }
        } else {
          this._drawCandleTooltipWithRect(crosshair, techs, candleOptions, isDrawCandleTooltip, techOptions, false);

          this._drawBatchTechToolTip(crosshair, techs, techOptions, 0, isDrawTechTooltip);
        }
      }
    }
    /**
     * ç»˜åˆ¶èœ¡çƒ›é»˜è®¤çš„å›¾ä¾‹
     * @param kLineData
     * @param candleOptions
     * @param isDrawCandleTooltip
     * @private
     */

  }, {
    key: "_drawCandleTooltipWithStandard",
    value: function _drawCandleTooltipWithStandard(kLineData, candleOptions, isDrawCandleTooltip) {
      var _this = this;

      if (!isDrawCandleTooltip) {
        return;
      }

      var values = this._getCandleTooltipData(kLineData, candleOptions);

      var candleTooltipOptions = candleOptions.tooltip;
      var textMarginLeft = candleTooltipOptions.text.marginLeft;
      var textMarginRight = candleTooltipOptions.text.marginRight;
      var textSize = candleTooltipOptions.text.size;
      var textColor = candleTooltipOptions.text.color;
      var labels = candleTooltipOptions.labels;
      this._ctx.textBaseline = 'top';
      this._ctx.font = createFont(textSize, candleTooltipOptions.text.weight, candleTooltipOptions.text.family);
      var labelX = textMarginLeft;
      var labelY = candleTooltipOptions.text.marginTop;
      labels.forEach(function (label, i) {
        var labelWidth = calcTextWidth(_this._ctx, label);
        renderText(_this._ctx, textColor, labelX, labelY, label);
        labelX += labelWidth;
        var value = values[i] || candleTooltipOptions.defaultValue;
        var valueText;
        var valueColor;

        if (isObject(value)) {
          valueText = value.value || candleTooltipOptions.defaultValue;
          valueColor = value.color || textColor;
        } else {
          valueColor = textColor;
          valueText = value;
        }

        var textWidth = calcTextWidth(_this._ctx, valueText);
        renderText(_this._ctx, valueColor, labelX, labelY, valueText);
        labelX += textWidth + textMarginLeft + textMarginRight;
      });
    }
    /**
     * ç»˜åˆ¶èœ¡çƒ›å›¾çŸ©å½¢ç±»å‹å›¾ä¾‹
     * @param crosshair
     * @param techs
     * @param candleOptions
     * @param isDrawCandleTooltip
     * @param techOptions
     * @param isDrawTechTooltip
     * @private
     */

  }, {
    key: "_drawCandleTooltipWithRect",
    value: function _drawCandleTooltipWithRect(crosshair, techs, candleOptions, isDrawCandleTooltip, techOptions, isDrawTechTooltip) {
      var _this2 = this;

      if (!isDrawCandleTooltip && !isDrawTechTooltip) {
        return;
      }

      var candleTooltipOptions = candleOptions.tooltip;
      var baseLabels = candleTooltipOptions.labels;

      var baseValues = this._getCandleTooltipData(crosshair.kLineData, candleOptions);

      var baseTextMarginLeft = candleTooltipOptions.text.marginLeft;
      var baseTextMarginRight = candleTooltipOptions.text.marginRight;
      var baseTextMarginTop = candleTooltipOptions.text.marginTop;
      var baseTextMarginBottom = candleTooltipOptions.text.marginBottom;
      var baseTextSize = candleTooltipOptions.text.size;
      var baseTextColor = candleTooltipOptions.text.color;
      var rectOptions = candleTooltipOptions.rect;
      var rectBorderSize = rectOptions.borderSize;
      var rectPaddingLeft = rectOptions.paddingLeft;
      var rectPaddingRight = rectOptions.paddingRight;
      var rectPaddingTop = rectOptions.paddingTop;
      var rectPaddingBottom = rectOptions.paddingBottom;
      var rectLeft = rectOptions.offsetLeft;
      var rectRight = rectOptions.offsetRight;
      var maxLabelWidth = 0;
      var rectWidth = 0;
      var rectHeight = 0;

      this._ctx.save();

      this._ctx.textBaseline = 'top';

      if (isDrawCandleTooltip) {
        this._ctx.font = createFont(baseTextSize, candleTooltipOptions.text.weight, candleTooltipOptions.text.family);
        baseLabels.forEach(function (label, i) {
          var value = baseValues[i];
          var v;

          if (isObject(value)) {
            v = value.value || candleTooltipOptions.defaultValue;
          } else {
            v = value;
          }

          var text = "".concat(label).concat(v);
          var labelWidth = calcTextWidth(_this2._ctx, text) + baseTextMarginLeft + baseTextMarginRight;
          maxLabelWidth = Math.max(maxLabelWidth, labelWidth);
        });
        rectHeight += (baseTextMarginBottom + baseTextMarginTop + baseTextSize) * baseLabels.length;
      }

      var techTooltipOptions = techOptions.tooltip;
      var techTooltipTextMarginLeft = techTooltipOptions.text.marginLeft;
      var techTooltipTextMarginRight = techTooltipOptions.text.marginRight;
      var techTooltipTextMarginTop = techTooltipOptions.text.marginTop;
      var techTooltipTextMarginBottom = techTooltipOptions.text.marginBottom;
      var techTooltipTextSize = techTooltipOptions.text.size;
      var techTooltipDataList = techs.map(function (tech) {
        return _this2._getTechTooltipData(crosshair, tech, techOptions);
      });

      if (isDrawTechTooltip) {
        this._ctx.font = createFont(techTooltipTextSize, techTooltipOptions.text.weight, techTooltipOptions.text.family);
        techTooltipDataList.forEach(function (tooltipData) {
          tooltipData.values.forEach(function (_ref) {
            var title = _ref.title,
                value = _ref.value;

            if (isValid(title)) {
              var text = "".concat(title).concat(value);
              var labelWidth = calcTextWidth(_this2._ctx, text) + techTooltipTextMarginLeft + techTooltipTextMarginRight;
              maxLabelWidth = Math.max(maxLabelWidth, labelWidth);
              rectHeight += techTooltipTextMarginTop + techTooltipTextMarginBottom + techTooltipTextSize;
            }
          });
        });
      }

      rectWidth += maxLabelWidth;

      if (rectWidth === 0 || rectHeight === 0) {
        return;
      }

      rectWidth += rectBorderSize * 2 + rectPaddingLeft + rectPaddingRight;
      rectHeight += rectBorderSize * 2 + rectPaddingTop + rectPaddingBottom;
      var centerX = this._width / 2;
      var rectX;

      if (crosshair.realX < centerX) {
        rectX = this._width - rectRight - rectWidth;
      } else {
        rectX = rectLeft;
      }

      var rectY = rectOptions.offsetTop;
      var radius = rectOptions.borderRadius;
      renderFillRoundRect(this._ctx, rectOptions.backgroundColor, rectX, rectY, rectWidth, rectHeight, radius);
      renderStrokeRoundRect(this._ctx, rectOptions.borderColor, rectBorderSize, rectX, rectY, rectWidth, rectHeight, radius);
      var baseLabelX = rectX + rectBorderSize + rectPaddingLeft + baseTextMarginLeft;
      var labelY = rectY + rectBorderSize + rectPaddingTop;

      if (isDrawCandleTooltip) {
        // å¼€å§‹æ¸²æŸ“åŸºç¡€æ•°æ®æ–‡å­—
        this._ctx.font = createFont(baseTextSize, candleTooltipOptions.text.weight, candleTooltipOptions.text.family);
        baseLabels.forEach(function (label, i) {
          labelY += baseTextMarginTop;
          _this2._ctx.textAlign = 'left';
          renderText(_this2._ctx, baseTextColor, baseLabelX, labelY, label);
          var value = baseValues[i];
          var text;
          var color;

          if (isObject(value)) {
            color = value.color || baseTextColor;
            text = value.value || candleTooltipOptions.defaultValue;
          } else {
            color = baseTextColor;
            text = value || candleTooltipOptions.defaultValue;
          }

          _this2._ctx.textAlign = 'right';
          renderText(_this2._ctx, color, rectX + rectWidth - rectBorderSize - baseTextMarginRight - rectPaddingRight, labelY, text);
          labelY += baseTextSize + baseTextMarginBottom;
        });
      }

      if (isDrawTechTooltip) {
        // å¼€å§‹æ¸²æŸ“æŒ‡æ ‡æ•°æ®æ–‡å­—
        var indicatorLabelX = rectX + rectBorderSize + rectPaddingLeft + techTooltipTextMarginLeft;
        this._ctx.font = createFont(techTooltipTextSize, techTooltipOptions.text.weight, techTooltipOptions.text.family);
        techTooltipDataList.forEach(function (tooltipData) {
          tooltipData.values.forEach(function (v) {
            labelY += techTooltipTextMarginTop;
            _this2._ctx.textAlign = 'left';
            _this2._ctx.fillStyle = v.color;

            _this2._ctx.fillText(v.title, indicatorLabelX, labelY);

            _this2._ctx.textAlign = 'right';

            _this2._ctx.fillText(v.value, rectX + rectWidth - rectBorderSize - techTooltipTextMarginRight - rectPaddingRight, labelY);

            labelY += techTooltipTextSize + techTooltipTextMarginBottom;
          });
        });
      }

      this._ctx.restore();
    }
    /**
     * è·å–èœ¡çƒ›æç¤ºæ•°æ®
     * @param kLineData
     * @param candleOptions
     * @returns {*}
     * @private
     */

  }, {
    key: "_getCandleTooltipData",
    value: function _getCandleTooltipData(kLineData, candleOptions) {
      var _this3 = this;

      var baseValues = candleOptions.tooltip.values;
      var values = [];

      if (baseValues) {
        if (isFunction(baseValues)) {
          values = baseValues(kLineData, candleOptions) || [];
        } else if (isArray(baseValues)) {
          values = baseValues;
        }
      } else {
        var pricePrecision = this._chartStore.pricePrecision();

        var volumePrecision = this._chartStore.volumePrecision();

        values = [formatValue(kLineData, 'timestamp'), formatValue(kLineData, 'open'), formatValue(kLineData, 'close'), formatValue(kLineData, 'high'), formatValue(kLineData, 'low'), formatValue(kLineData, 'volume')];
        values.forEach(function (value, index) {
          switch (index) {
            case 0:
              {
                values[index] = formatDate(_this3._chartStore.timeScaleStore().dateTimeFormat(), value, 'YYYY-MM-DD hh:mm');
                break;
              }

            case values.length - 1:
              {
                values[index] = formatBigNumber(formatPrecision(value, volumePrecision));
                break;
              }

            default:
              {
                values[index] = formatPrecision(value, pricePrecision);
                break;
              }
          }
        });
      }

      return values;
    }
  }]);

  return CandleOverlayView;
}(TechnicalIndicatorOverlayView);

var CandleWidget = /*#__PURE__*/function (_TechnicalIndicatorWi) {
  _inherits(CandleWidget, _TechnicalIndicatorWi);

  var _super = _createSuper(CandleWidget);

  function CandleWidget() {
    _classCallCheck(this, CandleWidget);

    return _super.apply(this, arguments);
  }

  _createClass(CandleWidget, [{
    key: "_createMainView",
    value: function _createMainView(container, props) {
      return new CandleView(container, props.chartStore, props.xAxis, props.yAxis, props.paneId);
    }
  }, {
    key: "_createOverlayView",
    value: function _createOverlayView(container, props) {
      return new CandleOverlayView(container, props.chartStore, props.xAxis, props.yAxis, props.paneId);
    }
  }]);

  return CandleWidget;
}(TechnicalIndicatorWidget);

var CandlePane = /*#__PURE__*/function (_TechnicalIndicatorPa) {
  _inherits(CandlePane, _TechnicalIndicatorPa);

  var _super = _createSuper(CandlePane);

  function CandlePane() {
    _classCallCheck(this, CandlePane);

    return _super.apply(this, arguments);
  }

  _createClass(CandlePane, [{
    key: "_createYAxis",
    value: function _createYAxis(props) {
      return new YAxis(props.chartStore, true, props.id);
    }
  }, {
    key: "_createMainWidget",
    value: function _createMainWidget(container, props) {
      return new CandleWidget({
        container: container,
        chartStore: props.chartStore,
        xAxis: props.xAxis,
        yAxis: this._yAxis,
        paneId: props.id
      });
    }
  }]);

  return CandlePane;
}(TechnicalIndicatorPane);

var XAxisView = /*#__PURE__*/function (_View) {
  _inherits(XAxisView, _View);

  var _super = _createSuper(XAxisView);

  function XAxisView(container, chartStore, xAxis) {
    var _this;

    _classCallCheck(this, XAxisView);

    _this = _super.call(this, container, chartStore);
    _this._xAxis = xAxis;
    return _this;
  }

  _createClass(XAxisView, [{
    key: "_draw",
    value: function _draw() {
      var xAxisOptions = this._chartStore.styleOptions().xAxis;

      if (xAxisOptions.show) {
        this._drawAxisLine(xAxisOptions);

        this._drawTickLines(xAxisOptions);

        this._drawTickLabels(xAxisOptions);
      }
    }
  }, {
    key: "_drawAxisLine",
    value: function _drawAxisLine(xAxisOptions) {
      var xAxisLine = xAxisOptions.axisLine;

      if (!xAxisLine.show) {
        return;
      }

      this._ctx.strokeStyle = xAxisLine.color;
      this._ctx.lineWidth = xAxisLine.size;
      renderHorizontalLine(this._ctx, 0, 0, this._width);
    }
  }, {
    key: "_drawTickLines",
    value: function _drawTickLines(xAxisOptions) {
      var _this2 = this;

      var tickLine = xAxisOptions.tickLine;

      if (!tickLine.show) {
        return;
      }

      this._ctx.lineWidth = tickLine.size;
      this._ctx.strokeStyle = tickLine.color;
      var startY = xAxisOptions.axisLine.show ? xAxisOptions.axisLine.size : 0;
      var endY = startY + tickLine.length;

      this._xAxis.ticks().forEach(function (tick) {
        renderVerticalLine(_this2._ctx, tick.x, startY, endY);
      });
    }
  }, {
    key: "_drawTickLabels",
    value: function _drawTickLabels(xAxisOptions) {
      var tickText = xAxisOptions.tickText;

      if (!tickText.show) {
        return;
      }

      var tickLine = xAxisOptions.tickLine;
      this._ctx.textBaseline = 'top';
      this._ctx.font = createFont(tickText.size, tickText.weight, tickText.family);
      this._ctx.textAlign = 'center';
      this._ctx.fillStyle = tickText.color;
      var labelY = tickText.paddingTop;

      if (xAxisOptions.axisLine.show) {
        labelY += xAxisOptions.axisLine.size;
      }

      if (tickLine.show) {
        labelY += tickLine.length;
      }

      var ticks = this._xAxis.ticks();

      var tickLength = ticks.length;

      for (var i = 0; i < tickLength; i++) {
        this._ctx.fillText(ticks[i].v, ticks[i].x, labelY);
      }
    }
  }]);

  return XAxisView;
}(View);

var XAxisOverlayView = /*#__PURE__*/function (_View) {
  _inherits(XAxisOverlayView, _View);

  var _super = _createSuper(XAxisOverlayView);

  function XAxisOverlayView(container, chartStore, xAxis) {
    var _this;

    _classCallCheck(this, XAxisOverlayView);

    _this = _super.call(this, container, chartStore);
    _this._xAxis = xAxis;
    return _this;
  }

  _createClass(XAxisOverlayView, [{
    key: "_draw",
    value: function _draw() {
      this._drawCrosshairLabel();
    }
  }, {
    key: "_drawCrosshairLabel",
    value: function _drawCrosshairLabel() {
      var crosshair = this._chartStore.crosshairStore().get();

      if (!crosshair.paneId) {
        return;
      }

      var crosshairOptions = this._chartStore.styleOptions().crosshair;

      var crosshairVerticalOptions = crosshairOptions.vertical;
      var crosshairVerticalTextOptions = crosshairVerticalOptions.text;

      if (!crosshairOptions.show || !crosshairVerticalOptions.show || !crosshairVerticalTextOptions.show || crosshair.dataIndex !== crosshair.realDataIndex) {
        return;
      }

      var timestamp = crosshair.kLineData.timestamp;
      var text = formatDate(this._chartStore.timeScaleStore().dateTimeFormat(), timestamp, 'YYYY-MM-DD hh:mm');
      var paddingLeft = crosshairVerticalTextOptions.paddingLeft;
      var paddingRight = crosshairVerticalTextOptions.paddingRight;
      var paddingTop = crosshairVerticalTextOptions.paddingTop;
      var borderSize = crosshairVerticalTextOptions.borderSize;
      var rectWidth = getTextRectWidth(this._ctx, text, crosshairVerticalTextOptions);
      var rectHeight = getTextRectHeight(crosshairVerticalTextOptions);
      var labelWidth = rectWidth - borderSize * 2 - paddingLeft - paddingRight;
      var labelX = crosshair.realX - labelWidth / 2; // ä¿è¯æ•´ä¸ªxè½´ä¸Šçš„æç¤ºæ–‡å­—æ€»æ˜¯å®Œå…¨æ˜¾ç¤º

      if (labelX < paddingLeft + borderSize) {
        labelX = paddingLeft + borderSize;
      } else if (labelX > this._width - labelWidth - borderSize - paddingRight) {
        labelX = this._width - labelWidth - borderSize - paddingRight;
      }

      var rectX = labelX - borderSize - paddingLeft;
      renderStrokeFillRoundRect(this._ctx, crosshairVerticalTextOptions.backgroundColor, crosshairVerticalTextOptions.borderColor, borderSize, rectX, 0, rectWidth, rectHeight, crosshairVerticalTextOptions.borderRadius); // ç»˜åˆ¶è½´ä¸Šçš„æç¤ºæ–‡å­—

      this._ctx.textBaseline = 'top';
      renderText(this._ctx, crosshairVerticalTextOptions.color, labelX, borderSize + paddingTop, text);
    }
  }]);

  return XAxisOverlayView;
}(View);

var XAxisWidget = /*#__PURE__*/function (_Widget) {
  _inherits(XAxisWidget, _Widget);

  var _super = _createSuper(XAxisWidget);

  function XAxisWidget() {
    _classCallCheck(this, XAxisWidget);

    return _super.apply(this, arguments);
  }

  _createClass(XAxisWidget, [{
    key: "_createMainView",
    value: function _createMainView(container, props) {
      return new XAxisView(container, props.chartStore, props.xAxis);
    }
  }, {
    key: "_createOverlayView",
    value: function _createOverlayView(container, props) {
      return new XAxisOverlayView(container, props.chartStore, props.xAxis);
    }
  }]);

  return XAxisWidget;
}(Widget);

var XAxis = /*#__PURE__*/function (_Axis) {
  _inherits(XAxis, _Axis);

  var _super = _createSuper(XAxis);

  function XAxis() {
    _classCallCheck(this, XAxis);

    return _super.apply(this, arguments);
  }

  _createClass(XAxis, [{
    key: "_computeMinMax",
    value: function _computeMinMax() {
      return {
        min: this._chartStore.timeScaleStore().from(),
        max: this._chartStore.timeScaleStore().to() - 1
      };
    }
  }, {
    key: "_optimalMinMax",
    value: function _optimalMinMax(_ref) {
      var min = _ref.min,
          max = _ref.max;
      return {
        min: min,
        max: max,
        range: max - min + 1
      };
    }
  }, {
    key: "_optimalTicks",
    value: function _optimalTicks(ticks) {
      var optimalTicks = [];
      var tickLength = ticks.length;

      var dataList = this._chartStore.dataList();

      if (tickLength > 0) {
        var dateTimeFormat = this._chartStore.timeScaleStore().dateTimeFormat();

        var tickText = this._chartStore.styleOptions().xAxis.tickText;

        this._measureCtx.font = createFont(tickText.size, tickText.weight, tickText.family);
        var defaultLabelWidth = calcTextWidth(this._measureCtx, '00-00 00:00');
        var pos = parseInt(ticks[0].v, 10);
        var x = this.convertToPixel(pos);
        var tickCountDif = 1;

        if (tickLength > 1) {
          var nextPos = parseInt(ticks[1].v, 10);
          var nextX = this.convertToPixel(nextPos);
          var xDif = Math.abs(nextX - x);

          if (xDif < defaultLabelWidth) {
            tickCountDif = Math.ceil(defaultLabelWidth / xDif);
          }
        }

        for (var i = 0; i < tickLength; i += tickCountDif) {
          var _pos = parseInt(ticks[i].v, 10);

          var kLineData = dataList[_pos];
          var timestamp = kLineData.timestamp;
          var label = formatDate(dateTimeFormat, timestamp, 'hh:mm');

          if (i !== 0) {
            var prePos = parseInt(ticks[i - tickCountDif].v, 10);
            var preKLineData = dataList[prePos];
            var preTimestamp = preKLineData.timestamp;
            label = this._optimalTickLabel(dateTimeFormat, timestamp, preTimestamp) || label;
          }

          var _x = this.convertToPixel(_pos);

          optimalTicks.push({
            v: label,
            x: _x,
            oV: timestamp
          });
        }

        var optimalTickLength = optimalTicks.length;

        if (optimalTickLength === 1) {
          optimalTicks[0].v = formatDate(dateTimeFormat, optimalTicks[0].oV, 'YYYY-MM-DD hh:mm');
        } else {
          var firstTimestamp = optimalTicks[0].oV;
          var secondTimestamp = optimalTicks[1].oV;

          if (optimalTicks[2]) {
            var thirdV = optimalTicks[2].v;

            if (/^[0-9]{2}-[0-9]{2}$/.test(thirdV)) {
              optimalTicks[0].v = formatDate(dateTimeFormat, firstTimestamp, 'MM-DD');
            } else if (/^[0-9]{4}-[0-9]{2}$/.test(thirdV)) {
              optimalTicks[0].v = formatDate(dateTimeFormat, firstTimestamp, 'YYYY-MM');
            } else if (/^[0-9]{4}$/.test(thirdV)) {
              optimalTicks[0].v = formatDate(dateTimeFormat, firstTimestamp, 'YYYY');
            }
          } else {
            optimalTicks[0].v = this._optimalTickLabel(dateTimeFormat, firstTimestamp, secondTimestamp) || optimalTicks[0].v;
          }
        }
      }

      return optimalTicks;
    }
  }, {
    key: "_optimalTickLabel",
    value: function _optimalTickLabel(dateTimeFormat, timestamp, comparedTimestamp) {
      var year = formatDate(dateTimeFormat, timestamp, 'YYYY');
      var month = formatDate(dateTimeFormat, timestamp, 'YYYY-MM');
      var day = formatDate(dateTimeFormat, timestamp, 'MM-DD');

      if (year !== formatDate(dateTimeFormat, comparedTimestamp, 'YYYY')) {
        return year;
      } else if (month !== formatDate(dateTimeFormat, comparedTimestamp, 'YYYY-MM')) {
        return month;
      } else if (day !== formatDate(dateTimeFormat, comparedTimestamp, 'MM-DD')) {
        return day;
      }

      return null;
    }
    /**
     * è·å–è‡ªèº«é«˜åº¦
     */

  }, {
    key: "getSelfHeight",
    value: function getSelfHeight() {
      var stylOptions = this._chartStore.styleOptions();

      var xAxisOptions = stylOptions.xAxis;
      var height = xAxisOptions.height;

      if (isNumber(height)) {
        return height;
      }

      var crosshairOptions = stylOptions.crosshair;
      var xAxisHeight = 0;

      if (xAxisOptions.show) {
        if (xAxisOptions.axisLine.show) {
          xAxisHeight += xAxisOptions.axisLine.size;
        }

        if (xAxisOptions.tickLine.show) {
          xAxisHeight += xAxisOptions.tickLine.length;
        }

        if (xAxisOptions.tickText.show) {
          xAxisHeight += xAxisOptions.tickText.paddingTop + xAxisOptions.tickText.paddingBottom + xAxisOptions.tickText.size;
        }
      }

      var crosshairVerticalTextHeight = 0;

      if (crosshairOptions.show && crosshairOptions.vertical.show && crosshairOptions.vertical.text.show) {
        crosshairVerticalTextHeight += crosshairOptions.vertical.text.paddingTop + crosshairOptions.vertical.text.paddingBottom + crosshairOptions.vertical.text.borderSize * 2 + crosshairOptions.vertical.text.size;
      }

      return Math.max(xAxisHeight, crosshairVerticalTextHeight);
    }
  }, {
    key: "convertFromPixel",
    value: function convertFromPixel(pixel) {
      return this._chartStore.timeScaleStore().coordinateToDataIndex(pixel);
    }
  }, {
    key: "convertToPixel",
    value: function convertToPixel(value) {
      return this._chartStore.timeScaleStore().dataIndexToCoordinate(value);
    }
  }]);

  return XAxis;
}(Axis);

var XAxisPane = /*#__PURE__*/function (_Pane) {
  _inherits(XAxisPane, _Pane);

  var _super = _createSuper(XAxisPane);

  function XAxisPane() {
    _classCallCheck(this, XAxisPane);

    return _super.apply(this, arguments);
  }

  _createClass(XAxisPane, [{
    key: "_initBefore",
    value: function _initBefore() {
      this._xAxis = new XAxis(this._chartStore);
    }
  }, {
    key: "_createMainWidget",
    value: function _createMainWidget(container, props) {
      return new XAxisWidget({
        container: container,
        chartStore: props.chartStore,
        xAxis: this._xAxis
      });
    }
  }, {
    key: "xAxis",
    value: function xAxis() {
      return this._xAxis;
    }
  }, {
    key: "setWidth",
    value: function setWidth(mainWidgetWidth, yAxisWidgetWidth) {
      _get(_getPrototypeOf(XAxisPane.prototype), "setWidth", this).call(this, mainWidgetWidth, yAxisWidgetWidth);

      this._xAxis.setWidth(mainWidgetWidth);
    }
  }, {
    key: "setHeight",
    value: function setHeight(height) {
      _get(_getPrototypeOf(XAxisPane.prototype), "setHeight", this).call(this, height);

      this._xAxis.setHeight(height);
    }
  }]);

  return XAxisPane;
}(Pane);

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var EventType = {
  MOUSE: 'mouse',
  TOUCH: 'touch'
};
function isTouch(event) {
  return event.type === EventType.TOUCH;
}
function isMouse(event) {
  return event.type === EventType.MOUSE;
}

var MouseEventButton = {
  LEFT: 0,
  RIGHT: 2
};
var DELAY_RESET_CLICK = 500;
var DELAY_LONG_TAG = 600;

function getBoundingClientRect(element) {
  return element.getBoundingClientRect() || {
    left: 0,
    top: 0
  };
}

function isTouchEvent(event) {
  return Boolean(event.touches);
}

function preventDefault(event) {
  if (event.cancelable) {
    event.preventDefault();
  }
}

function mobileTouch() {
  var touchEvent;

  if ('ontouchstart' in window) {
    touchEvent = true;
  } else {
    touchEvent = Boolean(window.DocumentTouch && document instanceof window.DocumentTouch);
  }

  return 'onorientationchange' in window && (!!navigator.maxTouchPoints || !!navigator.msMaxTouchPoints || touchEvent);
}

function getDistance(p1, p2) {
  var xDiff = p1.clientX - p2.clientX;
  var yDiff = p1.clientY - p2.clientY;
  return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
}

var EventBase = /*#__PURE__*/function () {
  function EventBase(target, eventHandler, options) {
    _classCallCheck(this, EventBase);

    this._target = target;
    this._handler = eventHandler;
    this._options = options;
    this._clickCount = 0;
    this._clickTimeoutId = null;
    this._longTapTimeoutId = null;
    this._longTapActive = false;
    this._mouseMoveStartPosition = null;
    this._moveExceededManhattanDistance = false;
    this._cancelClick = false;
    this._unsubscribeOutsideEvents = null;
    this._unsubscribeMousemove = null;
    this._unsubscribeRoot = null;
    this._startPinchMiddleCoordinate = null;
    this._startPinchDistance = 0;
    this._pinchPrevented = false;
    this._preventDragProcess = false;
    this._mousePressed = false;

    this._init();
  }

  _createClass(EventBase, [{
    key: "setOptions",
    value: function setOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this._options = _objectSpread2(_objectSpread2({}, this.options), options);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this._unsubscribeOutsideEvents !== null) {
        this._unsubscribeOutsideEvents();

        this._unsubscribeOutsideEvents = null;
      }

      if (this._unsubscribeMousemove !== null) {
        this._unsubscribeMousemove();

        this._unsubscribeMousemove = null;
      }

      if (this._unsubscribeRoot !== null) {
        this._unsubscribeRoot();

        this._unsubscribeRoot = null;
      }

      this._clearLongTapTimeout();

      this._resetClickTimeout();
    }
  }, {
    key: "_mouseEnterHandler",
    value: function _mouseEnterHandler(enterEvent) {
      var _this = this;

      if (this._unsubscribeMousemove) {
        this._unsubscribeMousemove();
      }

      {
        var boundMouseMoveHandler = this._mouseMoveHandler.bind(this);

        var boundMouseWheelHandler = this._mouseWheelHandler.bind(this);

        this._unsubscribeMousemove = function () {
          _this._target.removeEventListener('mousemove', boundMouseMoveHandler);

          _this._target.removeEventListener('wheel', boundMouseWheelHandler);
        };

        this._target.addEventListener('mousemove', boundMouseMoveHandler);

        this._target.addEventListener('wheel', boundMouseWheelHandler, {
          passive: false
        });
      }

      if (isTouchEvent(enterEvent)) {
        this._mouseMoveHandler(enterEvent);
      }

      var compatEvent = this._makeCompatEvent(enterEvent);

      this._processEvent(compatEvent, this._handler.mouseEnterEvent);
    }
  }, {
    key: "_resetClickTimeout",
    value: function _resetClickTimeout() {
      if (this._clickTimeoutId !== null) {
        clearTimeout(this._clickTimeoutId);
      }

      this._clickCount = 0;
      this._clickTimeoutId = null;
    }
  }, {
    key: "_mouseMoveHandler",
    value: function _mouseMoveHandler(moveEvent) {
      if (this._mousePressed && !isTouchEvent(moveEvent)) {
        return;
      }

      var compatEvent = this._makeCompatEvent(moveEvent);

      this._processEvent(compatEvent, this._handler.mouseMoveEvent);
    }
  }, {
    key: "_mouseWheelHandler",
    value: function _mouseWheelHandler(wheelEvent) {
      var compatEvent = this._makeCompatEvent(wheelEvent);

      wheelEvent.localX = compatEvent.localX;
      wheelEvent.localY = compatEvent.localY;

      this._processEvent(wheelEvent, this._handler.mouseWheelEvent);
    }
  }, {
    key: "_mouseMoveWithDownHandler",
    value: function _mouseMoveWithDownHandler(moveEvent) {
      if ('button' in moveEvent && moveEvent.button !== MouseEventButton.LEFT) {
        return;
      }

      if (this._startPinchMiddleCoordinate !== null) {
        return;
      }

      var isTouch = isTouchEvent(moveEvent);

      if (this._preventDragProcess && isTouch) {
        return;
      }

      this._pinchPrevented = true;

      var compatEvent = this._makeCompatEvent(moveEvent);

      var startMouseMovePos = this._mouseMoveStartPosition;
      var xOffset = Math.abs(startMouseMovePos.x - compatEvent.pageX);
      var yOffset = Math.abs(startMouseMovePos.y - compatEvent.pageY);
      var moveExceededManhattanDistance = xOffset + yOffset > 5;

      if (!moveExceededManhattanDistance && isTouch) {
        return;
      }

      if (moveExceededManhattanDistance && !this._moveExceededManhattanDistance && isTouch) {
        // vertical drag is more important than horizontal drag
        // because we scroll the page vertically often than horizontally
        var correctedXOffset = xOffset * 0.5; // a drag can be only if touch page scroll isn't allowed

        var isVertDrag = yOffset >= correctedXOffset && !this._options.treatVertTouchDragAsPageScroll;
        var isHorzDrag = correctedXOffset > yOffset && !this._options.treatHorzTouchDragAsPageScroll; // if drag event happened then we should revert preventDefault state to original one
        // and try to process the drag event
        // else we shouldn't prevent default of the event and ignore processing the drag event

        if (!isVertDrag && !isHorzDrag) {
          this._preventDragProcess = true;
        }
      }

      if (moveExceededManhattanDistance) {
        this._moveExceededManhattanDistance = true; // if manhattan distance is more that 5 - we should cancel click event

        this._cancelClick = true;

        if (isTouch) {
          this._clearLongTapTimeout();
        }
      }

      if (!this._preventDragProcess) {
        this._processEvent(compatEvent, this._handler.pressedMouseMoveEvent); // we should prevent default in case of touch only
        // to prevent scroll of the page


        if (isTouch) {
          preventDefault(moveEvent);
        }
      }
    }
  }, {
    key: "_mouseUpHandler",
    value: function _mouseUpHandler(mouseUpEvent) {
      if ('button' in mouseUpEvent && mouseUpEvent.button !== MouseEventButton.LEFT) {
        return;
      }

      var compatEvent = this._makeCompatEvent(mouseUpEvent);

      this._clearLongTapTimeout();

      this._mouseMoveStartPosition = null;
      this._mousePressed = false;

      if (this._unsubscribeRoot) {
        this._unsubscribeRoot();

        this._unsubscribeRoot = null;
      }

      if (isTouchEvent(mouseUpEvent)) {
        this._mouseLeaveHandler(mouseUpEvent);
      }

      this._processEvent(compatEvent, this._handler.mouseUpEvent);

      ++this._clickCount;

      if (this._clickTimeoutId && this._clickCount > 1) {
        this._processEvent(compatEvent, this._handler.mouseDoubleClickEvent);

        this._resetClickTimeout();
      } else {
        if (!this._cancelClick) {
          this._processEvent(compatEvent, this._handler.mouseClickEvent);
        }
      } // prevent safari's dblclick-to-zoom
      // we handle mouseDoubleClickEvent here ourself


      if (isTouchEvent(mouseUpEvent)) {
        preventDefault(mouseUpEvent);

        this._mouseLeaveHandler(mouseUpEvent);

        if (mouseUpEvent.touches.length === 0) {
          this._longTapActive = false;
        }
      }
    }
  }, {
    key: "_clearLongTapTimeout",
    value: function _clearLongTapTimeout() {
      if (this._longTapTimeoutId === null) {
        return;
      }

      clearTimeout(this._longTapTimeoutId);
      this._longTapTimeoutId = null;
    }
  }, {
    key: "_mouseDownHandler",
    value: function _mouseDownHandler(downEvent) {
      if ('button' in downEvent && downEvent.button !== MouseEventButton.LEFT && downEvent.button !== MouseEventButton.RIGHT) {
        return;
      }

      var compatEvent = this._makeCompatEvent(downEvent);

      if ('button' in downEvent && downEvent.button === MouseEventButton.RIGHT) {
        this._processEvent(compatEvent, this._handler.mouseRightDownEvent);

        return;
      }

      this._cancelClick = false;
      this._moveExceededManhattanDistance = false;
      this._preventDragProcess = false;

      if (isTouchEvent(downEvent)) {
        this._mouseEnterHandler(downEvent);
      }

      this._mouseMoveStartPosition = {
        x: compatEvent.pageX,
        y: compatEvent.pageY
      };

      if (this._unsubscribeRoot) {
        this._unsubscribeRoot();

        this._unsubscribeRoot = null;
      }

      {
        var boundMouseMoveWithDownHandler = this._mouseMoveWithDownHandler.bind(this);

        var boundMouseUpHandler = this._mouseUpHandler.bind(this);

        var rootElement = this._target.ownerDocument.documentElement;

        this._unsubscribeRoot = function () {
          rootElement.removeEventListener('touchmove', boundMouseMoveWithDownHandler);
          rootElement.removeEventListener('touchend', boundMouseUpHandler);
          rootElement.removeEventListener('mousemove', boundMouseMoveWithDownHandler);
          rootElement.removeEventListener('mouseup', boundMouseUpHandler);
        };

        rootElement.addEventListener('touchmove', boundMouseMoveWithDownHandler, {
          passive: false
        });
        rootElement.addEventListener('touchend', boundMouseUpHandler, {
          passive: false
        });

        this._clearLongTapTimeout();

        if (isTouchEvent(downEvent) && downEvent.touches.length === 1) {
          this._longTapTimeoutId = setTimeout(this._longTapHandler.bind(this, downEvent), DELAY_LONG_TAG);
        } else {
          rootElement.addEventListener('mousemove', boundMouseMoveWithDownHandler);
          rootElement.addEventListener('mouseup', boundMouseUpHandler);
        }
      }
      this._mousePressed = true;

      this._processEvent(compatEvent, this._handler.mouseDownEvent);

      if (!this._clickTimeoutId) {
        this._clickCount = 0;
        this._clickTimeoutId = setTimeout(this._resetClickTimeout.bind(this), DELAY_RESET_CLICK);
      }
    }
  }, {
    key: "_init",
    value: function _init() {
      var _this2 = this;

      this._target.addEventListener('mouseenter', this._mouseEnterHandler.bind(this));

      this._target.addEventListener('touchcancel', this._clearLongTapTimeout.bind(this));

      {
        var doc = this._target.ownerDocument;

        var outsideHandler = function outsideHandler(event) {
          if (!_this2._handler.mouseDownOutsideEvent) {
            return;
          }

          if (event.target && _this2._target.contains(event.target)) {
            return;
          }

          _this2._handler.mouseDownOutsideEvent();
        };

        this._unsubscribeOutsideEvents = function () {
          doc.removeEventListener('mousedown', outsideHandler);
          doc.removeEventListener('touchstart', outsideHandler);
        };

        doc.addEventListener('mousedown', outsideHandler);
        doc.addEventListener('touchstart', outsideHandler, {
          passive: true
        });
      }

      this._target.addEventListener('mouseleave', this._mouseLeaveHandler.bind(this));

      this._target.addEventListener('touchstart', this._mouseDownHandler.bind(this), {
        passive: true
      });

      if (!mobileTouch()) {
        this._target.addEventListener('mousedown', this._mouseDownHandler.bind(this));
      }

      this._initPinch(); // Hey mobile Safari, what's up?
      // If mobile Safari doesn't have any touchmove handler with passive=false
      // it treats a touchstart and the following touchmove events as cancelable=false,
      // so we can't prevent them (as soon we subscribe on touchmove inside handler of touchstart).
      // And we'll get scroll of the page along with chart's one instead of only chart's scroll.


      this._target.addEventListener('touchmove', function () {}, {
        passive: false
      });
    }
  }, {
    key: "_initPinch",
    value: function _initPinch() {
      var _this3 = this;

      if (this._handler.pinchStartEvent === undefined && this._handler.pinchEvent === undefined && this._handler.pinchEndEvent === undefined) {
        return;
      }

      this._target.addEventListener('touchstart', function (event) {
        return _this3._checkPinchState(event.touches);
      }, {
        passive: true
      });

      this._target.addEventListener('touchmove', function (event) {
        if (event.touches.length !== 2 || _this3._startPinchMiddleCoordinate === null) {
          return;
        }

        if (_this3._handler.pinchEvent !== undefined) {
          var currentDistance = getDistance(event.touches[0], event.touches[1]);
          var scale = currentDistance / _this3._startPinchDistance;

          _this3._handler.pinchEvent(_this3._startPinchMiddleCoordinate, scale);

          preventDefault(event);
        }
      }, {
        passive: false
      });

      this._target.addEventListener('touchend', function (event) {
        _this3._checkPinchState(event.touches);
      });
    }
  }, {
    key: "_checkPinchState",
    value: function _checkPinchState(touches) {
      if (touches.length === 1) {
        this._pinchPrevented = false;
      }

      if (touches.length !== 2 || this._pinchPrevented || this._longTapActive) {
        this._stopPinch();
      } else {
        this._startPinch(touches);
      }
    }
  }, {
    key: "_startPinch",
    value: function _startPinch(touches) {
      var box = getBoundingClientRect(this._target);
      this._startPinchMiddleCoordinate = {
        x: (touches[0].clientX - box.left + (touches[1].clientX - box.left)) / 2,
        y: (touches[0].clientY - box.top + (touches[1].clientY - box.top)) / 2
      };
      this._startPinchDistance = getDistance(touches[0], touches[1]);

      if (this._handler.pinchStartEvent !== undefined) {
        this._handler.pinchStartEvent();
      }

      this._clearLongTapTimeout();
    }
  }, {
    key: "_stopPinch",
    value: function _stopPinch() {
      if (this._startPinchMiddleCoordinate === null) {
        return;
      }

      this._startPinchMiddleCoordinate = null;

      if (this._handler.pinchEndEvent !== undefined) {
        this._handler.pinchEndEvent();
      }
    }
  }, {
    key: "_mouseLeaveHandler",
    value: function _mouseLeaveHandler(event) {
      if (this._unsubscribeMousemove) {
        this._unsubscribeMousemove();
      }

      var compatEvent = this._makeCompatEvent(event);

      this._processEvent(compatEvent, this._handler.mouseLeaveEvent);
    }
  }, {
    key: "_longTapHandler",
    value: function _longTapHandler(event) {
      var compatEvent = this._makeCompatEvent(event);

      this._processEvent(compatEvent, this._handler.longTapEvent);

      this._cancelClick = true; // long tap is active untill touchend event with 0 touches occured

      this._longTapActive = true;
    }
  }, {
    key: "_processEvent",
    value: function _processEvent(event, callback) {
      if (!callback) {
        return;
      }

      callback.call(this._handler, event);
    }
  }, {
    key: "_makeCompatEvent",
    value: function _makeCompatEvent(event) {
      // TouchEvent has no clientX/Y coordinates:
      // We have to use the last Touch instead
      var eventLike;

      if ('touches' in event && event.touches.length) {
        eventLike = event.touches[0];
      } else if ('changedTouches' in event && event.changedTouches.length) {
        eventLike = event.changedTouches[0];
      } else {
        eventLike = event;
      }

      var box = getBoundingClientRect(this._target);
      return {
        clientX: eventLike.clientX,
        clientY: eventLike.clientY,
        pageX: eventLike.pageX,
        pageY: eventLike.pageY,
        screenX: eventLike.screenX,
        screenY: eventLike.screenY,
        localX: eventLike.clientX - box.left,
        localY: eventLike.clientY - box.top,
        ctrlKey: event.ctrlKey,
        altKey: event.altKey,
        shiftKey: event.shiftKey,
        metaKey: event.metaKey,
        type: event.type.startsWith('mouse') ? EventType.MOUSE : EventType.TOUCH,
        target: eventLike.target,
        view: event.view
      };
    }
  }]);

  return EventBase;
}();

var SeparatorPane = /*#__PURE__*/function () {
  function SeparatorPane(container, chartStore, topPaneId, bottomPaneId, dragEnabled, dragEventHandler) {
    _classCallCheck(this, SeparatorPane);

    this._chartStore = chartStore;
    this._topPaneId = topPaneId;
    this._bottomPaneId = bottomPaneId;
    this._dragEnabled = dragEnabled;
    this._width = 0;
    this._offsetLeft = 0;
    this._dragEventHandler = dragEventHandler;
    this._dragFlag = false;

    this._initElement(container);

    this._initEvent(dragEnabled);
  }
  /**
   * åˆå§‹åŒ–domå…ƒç´ 
   * @param container
   * @private
   */


  _createClass(SeparatorPane, [{
    key: "_initElement",
    value: function _initElement(container) {
      this._container = container;
      this._wrapper = createElement('div', {
        margin: '0',
        padding: '0',
        position: 'relative',
        boxSizing: 'border-box'
      });
      this._element = createElement('div', {
        width: '100%',
        height: '7px',
        margin: '0',
        padding: '0',
        position: 'absolute',
        top: '-3px',
        zIndex: '20',
        boxSizing: 'border-box'
      });

      this._wrapper.appendChild(this._element);

      var lastElement = container.lastChild;

      if (lastElement) {
        container.insertBefore(this._wrapper, lastElement);
      } else {
        container.appendChild(this._wrapper);
      }
    }
    /**
     * åˆå§‹åŒ–äº‹ä»¶
     * @param dragEnabled
     * @private
     */

  }, {
    key: "_initEvent",
    value: function _initEvent(dragEnabled) {
      if (dragEnabled) {
        this._element.style.cursor = 'ns-resize';
        this._dragEvent = new EventBase(this._element, {
          mouseDownEvent: this._mouseDownEvent.bind(this),
          mouseUpEvent: this._mouseUpEvent.bind(this),
          pressedMouseMoveEvent: this._pressedMouseMoveEvent.bind(this),
          mouseEnterEvent: this._mouseEnterEvent.bind(this),
          mouseLeaveEvent: this._mouseLeaveEvent.bind(this)
        }, {
          treatVertTouchDragAsPageScroll: false,
          treatHorzTouchDragAsPageScroll: true
        });
      }
    }
  }, {
    key: "_mouseDownEvent",
    value: function _mouseDownEvent(event) {
      this._dragFlag = true;
      this._startY = event.pageY;

      this._dragEventHandler.startDrag(this._topPaneId, this._bottomPaneId);
    }
  }, {
    key: "_mouseUpEvent",
    value: function _mouseUpEvent() {
      this._dragFlag = false;

      this._chartStore.setDragPaneFlag(false);
    }
  }, {
    key: "_pressedMouseMoveEvent",
    value: function _pressedMouseMoveEvent(event) {
      var dragDistance = event.pageY - this._startY;

      this._dragEventHandler.drag(dragDistance, this._topPaneId, this._bottomPaneId);

      this._chartStore.setDragPaneFlag(true);

      this._chartStore.crosshairStore().set();
    }
  }, {
    key: "_mouseEnterEvent",
    value: function _mouseEnterEvent() {
      var separatorOptions = this._chartStore.styleOptions().separator;

      this._element.style.background = separatorOptions.activeBackgroundColor; // this._chartStore.setDragPaneFlag(true)

      this._chartStore.crosshairStore().set();
    }
  }, {
    key: "_mouseLeaveEvent",
    value: function _mouseLeaveEvent() {
      if (!this._dragFlag) {
        this._element.style.background = null;

        this._chartStore.setDragPaneFlag(false);
      }
    }
    /**
     * è·å–é«˜åº¦
     * @returns {number}
     */

  }, {
    key: "height",
    value: function height() {
      return this._wrapper.offsetHeight;
    }
    /**
     * è®¾ç½®å°ºå¯¸
     * ç”¨äºfillå±æ€§
     * @param offsetLeft
     * @param width
     */

  }, {
    key: "setSize",
    value: function setSize(offsetLeft, width) {
      this._offsetLeft = offsetLeft;
      this._width = width;
      this.invalidate();
    }
    /**
     * è®¾ç½®æ˜¯å¦å¯ä»¥æ‹–æ‹½
     * @param dragEnabled
     */

  }, {
    key: "setDragEnabled",
    value: function setDragEnabled(dragEnabled) {
      if (dragEnabled !== this._dragEnabled) {
        this._dragEnabled = dragEnabled;

        if (dragEnabled) {
          !this._dragEvent && this._initEvent(dragEnabled);
        } else {
          this._element.style.cursor = 'default';
          this._dragEvent && this._dragEvent.destroy();
          this._dragEvent = null;
        }
      }
    }
    /**
     * é¡¶éƒ¨paneId
     * @return {*}
     */

  }, {
    key: "topPaneId",
    value: function topPaneId() {
      return this._topPaneId;
    }
    /**
     * åº•éƒ¨paneId
     * @return {*}
     */

  }, {
    key: "bottomPaneId",
    value: function bottomPaneId() {
      return this._bottomPaneId;
    }
    /**
     * æ›´æ–°ä¸Šä¸‹ä¸¤ä¸ªå›¾è¡¨çš„ç´¢å¼•
     * @param topPaneId
     * @param bottomPaneId
     */

  }, {
    key: "updatePaneId",
    value: function updatePaneId(topPaneId, bottomPaneId) {
      if (isValid(topPaneId)) {
        this._topPaneId = topPaneId;
      }

      if (isValid(bottomPaneId)) {
        this._bottomPaneId = bottomPaneId;
      }
    }
    /**
     * åˆ·æ–°
     */

  }, {
    key: "invalidate",
    value: function invalidate() {
      var separatorOptions = this._chartStore.styleOptions().separator;

      this._element.style.top = "".concat(-Math.floor((7 - separatorOptions.size) / 2), "px");
      this._wrapper.style.backgroundColor = separatorOptions.color;
      this._wrapper.style.height = "".concat(separatorOptions.size, "px");
      this._wrapper.style.marginLeft = "".concat(separatorOptions.fill ? 0 : this._offsetLeft, "px");
      this._wrapper.style.width = separatorOptions.fill ? '100%' : "".concat(this._width, "px");
    }
    /**
     * å°†å›¾å½¢è½¬æ¢æˆå›¾ç‰‡
     * @returns {HTMLCanvasElement}
     */

  }, {
    key: "getImage",
    value: function getImage() {
      var separatorOptions = this._chartStore.styleOptions().separator;

      var width = this._wrapper.offsetWidth;
      var height = separatorOptions.size;
      var canvas = createElement('canvas', {
        width: "".concat(width, "px"),
        height: "".concat(height, "px"),
        boxSizing: 'border-box'
      });
      var ctx = canvas.getContext('2d');
      var pixelRatio = getPixelRatio(canvas);
      canvas.width = width * pixelRatio;
      canvas.height = height * pixelRatio;
      ctx.scale(pixelRatio, pixelRatio);
      ctx.fillStyle = separatorOptions.color;
      ctx.fillRect(this._offsetLeft, 0, width, height);
      return canvas;
    }
    /**
     * é”€æ¯
     */

  }, {
    key: "destroy",
    value: function destroy() {
      if (this._dragEvent) {
        this._dragEvent.destroy();
      }

      this._container.removeChild(this._wrapper);
    }
  }]);

  return SeparatorPane;
}();

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var EventHandler = /*#__PURE__*/_createClass(function EventHandler(chartStore) {
  _classCallCheck(this, EventHandler);

  this._chartStore = chartStore;
});

var TOUCH_MIN_RADIUS = 10;

var ZoomScrollEventHandler = /*#__PURE__*/function (_EventHandler) {
  _inherits(ZoomScrollEventHandler, _EventHandler);

  var _super = _createSuper(ZoomScrollEventHandler);

  function ZoomScrollEventHandler(chartStore) {
    var _this;

    _classCallCheck(this, ZoomScrollEventHandler);

    _this = _super.call(this, chartStore); // å¼€å§‹æ»šåŠ¨æ—¶åæ ‡ç‚¹

    _this._startScrollCoordinate = null; // å¼€å§‹è§¦æ‘¸æ—¶åæ ‡

    _this._touchCoordinate = null; // æ˜¯å¦æ˜¯å–æ¶ˆäº†åå­—å…‰æ ‡

    _this._touchCancelCrosshair = false; // æ˜¯å¦ç¼©æ”¾è¿‡

    _this._touchZoomed = false; // ç”¨æ¥è®°å½•æåˆç¼©æ”¾çš„å°ºå¯¸

    _this._pinchScale = 1;
    return _this;
  }

  _createClass(ZoomScrollEventHandler, [{
    key: "pinchStartEvent",
    value: function pinchStartEvent() {
      this._pinchScale = 1;
      this._touchZoomed = true;
    }
  }, {
    key: "pinchEvent",
    value: function pinchEvent(middleCoordinate, scale) {
      var zoomScale = (scale - this._pinchScale) * 5;
      this._pinchScale = scale;

      this._chartStore.timeScaleStore().zoom(zoomScale, middleCoordinate);
    }
  }, {
    key: "mouseUpEvent",
    value: function mouseUpEvent() {
      this._startScrollCoordinate = null;
    }
  }, {
    key: "mouseLeaveEvent",
    value: function mouseLeaveEvent(event) {
      this._startScrollCoordinate = null;

      if (isMouse(event)) {
        this._chartStore.crosshairStore().set();
      }
    }
  }, {
    key: "mouseMoveEvent",
    value: function mouseMoveEvent(event) {
      if (!isMouse(event)) {
        return;
      }

      this._chartStore.crosshairStore().set({
        x: event.localX,
        y: event.paneY,
        paneId: event.paneId
      });
    }
  }, {
    key: "mouseWheelEvent",
    value: function mouseWheelEvent(event) {
      if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {
        if (event.cancelable) {
          event.preventDefault();
        }

        if (Math.abs(event.deltaX) === 0) {
          return;
        }

        this._chartStore.timeScaleStore().startScroll();

        this._chartStore.timeScaleStore().scroll(-event.deltaX);
      } else {
        var deltaY = -(event.deltaY / 100);

        if (deltaY === 0) {
          return;
        }

        if (event.cancelable) {
          event.preventDefault();
        }

        switch (event.deltaMode) {
          case event.DOM_DELTA_PAGE:
            deltaY *= 120;
            break;

          case event.DOM_DELTA_LINE:
            deltaY *= 32;
            break;
        }

        if (deltaY !== 0) {
          var scale = Math.sign(deltaY) * Math.min(1, Math.abs(deltaY));

          this._chartStore.timeScaleStore().zoom(scale, {
            x: event.localX,
            y: event.localY
          });
        }
      }
    }
  }, {
    key: "mouseClickEvent",
    value: function mouseClickEvent(event) {
      if (!isTouch(event)) {
        return;
      }

      if (!this._touchCoordinate && !this._touchCancelCrosshair && !this._touchZoomed) {
        this._touchCoordinate = {
          x: event.localX,
          y: event.localY
        };

        this._chartStore.crosshairStore().set({
          x: event.localX,
          y: event.paneY,
          paneId: event.paneId
        });
      }
    }
  }, {
    key: "mouseDownEvent",
    value: function mouseDownEvent(event) {
      this._startScrollCoordinate = {
        x: event.localX,
        y: event.localY
      };

      this._chartStore.timeScaleStore().startScroll();

      if (isTouch(event)) {
        this._touchZoomed = false;

        if (this._touchCoordinate) {
          var xDif = event.localX - this._touchCoordinate.x;
          var yDif = event.localY - this._touchCoordinate.y;
          var radius = Math.sqrt(xDif * xDif + yDif * yDif);

          if (radius < TOUCH_MIN_RADIUS) {
            this._touchCoordinate = {
              x: event.localX,
              y: event.localY
            };

            this._chartStore.crosshairStore().set({
              x: event.localX,
              y: event.paneY,
              paneId: event.paneId
            });
          } else {
            this._touchCancelCrosshair = true;
            this._touchCoordinate = null;

            this._chartStore.crosshairStore().set();
          }
        } else {
          this._touchCancelCrosshair = false;
        }
      }
    }
  }, {
    key: "pressedMouseMoveEvent",
    value: function pressedMouseMoveEvent(event) {
      var crosshair = {
        x: event.localX,
        y: event.paneY,
        paneId: event.paneId
      };

      if (isTouch(event)) {
        if (this._touchCoordinate) {
          this._touchCoordinate = {
            x: event.localX,
            y: event.localY
          };

          this._chartStore.crosshairStore().set(crosshair);

          return;
        } else {
          crosshair = null;
        }
      }

      if (this._startScrollCoordinate) {
        var distance = event.localX - this._startScrollCoordinate.x;

        this._chartStore.timeScaleStore().scroll(distance, crosshair);
      }
    }
  }, {
    key: "longTapEvent",
    value: function longTapEvent(event) {
      if (!isTouch(event)) {
        return;
      }

      this._touchCoordinate = {
        x: event.localX,
        y: event.localY
      };

      this._chartStore.crosshairStore().set({
        x: event.localX,
        y: event.paneY,
        paneId: event.paneId
      });
    }
  }]);

  return ZoomScrollEventHandler;
}(EventHandler);

var OverlayEventHandler = /*#__PURE__*/function (_EventHandler) {
  _inherits(OverlayEventHandler, _EventHandler);

  var _super = _createSuper(OverlayEventHandler);

  function OverlayEventHandler(chartStore, yAxis) {
    var _this;

    _classCallCheck(this, OverlayEventHandler);

    _this = _super.call(this, chartStore);
    _this._yAxis = yAxis;
    return _this;
  }
  /**
   * å¤„ç†è¦†ç›–ç‰©é¼ æ ‡hoveräº‹ä»¶
   * @param overlays
   * @param preHoverOperate
   * @param coordinate
   * @param event
   * @return {*}
   * @private
   */


  _createClass(OverlayEventHandler, [{
    key: "_performOverlayMouseHover",
    value: function _performOverlayMouseHover(overlays, preHoverOperate, coordinate, event) {
      var hoverOperate;

      if (overlays) {
        var _iterator = _createForOfIteratorHelper(overlays),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var overlay = _step.value;
            hoverOperate = overlay.checkEventCoordinateOn(coordinate);

            if (hoverOperate) {
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (!hoverOperate || preHoverOperate.id !== hoverOperate.id) {
          if (preHoverOperate.id && preHoverOperate.instance && isMouse(event)) {
            preHoverOperate.instance.onMouseLeave({
              id: preHoverOperate.id,
              points: preHoverOperate.instance.points(),
              event: event
            });
          }

          if (hoverOperate && hoverOperate.id !== preHoverOperate.id && hoverOperate.instance && isMouse(event)) {
            hoverOperate.instance.onMouseEnter({
              id: hoverOperate.id,
              points: hoverOperate.instance.points(),
              event: event
            });
          }
        }
      }

      return hoverOperate;
    }
    /**
     * é¼ æ ‡æŠ¬èµ·äº‹ä»¶
     */

  }, {
    key: "mouseUpEvent",
    value: function mouseUpEvent() {
      this._chartStore.shapeStore().updatePressedInstance();
    }
  }, {
    key: "mouseMoveEvent",
    value: function mouseMoveEvent(event) {
      if (this._waitingForMouseMove) {
        return false;
      }

      this._waitingForMouseMove = true;
      var coordinate = {
        x: event.localX,
        y: event.paneY
      };

      var _this$_chartStore$sha = this._chartStore.shapeStore().progressInstance(),
          paneId = _this$_chartStore$sha.paneId,
          instance = _this$_chartStore$sha.instance;

      var shapeHoverOperate;
      var shapeClickOperate;
      var annotationHoverOperate;

      if (instance && instance.isDrawing()) {
        if (event.paneId) {
          if (instance.isStart()) {
            this._chartStore.shapeStore().updateProgressInstance(this._yAxis(event.paneId), event.paneId);
          }

          if (paneId === event.paneId) {
            instance.mouseMoveForDrawing(coordinate, event);
          }

          shapeHoverOperate = instance.checkEventCoordinateOn(coordinate);
        }

        shapeClickOperate = {
          id: '',
          element: ShapeMouseOperateElement.NONE,
          elementIndex: -1
        };
      } else {
        var annotations = this._chartStore.annotationStore().get(event.paneId);

        var shapes = this._chartStore.shapeStore().instances(event.paneId);

        var prevShapeHoverOperate = this._chartStore.shapeStore().mouseOperate().hover;

        var prevAnnotationHoverOperate = this._chartStore.annotationStore().mouseOperate();

        shapeHoverOperate = this._performOverlayMouseHover(shapes, prevShapeHoverOperate, coordinate, event);
        annotationHoverOperate = this._performOverlayMouseHover(annotations, prevAnnotationHoverOperate, coordinate, event);
      }

      this._chartStore.shapeStore().setMouseOperate({
        hover: shapeHoverOperate || {
          id: '',
          element: ShapeMouseOperateElement.NONE,
          elementIndex: -1
        },
        click: shapeClickOperate
      });

      this._chartStore.annotationStore().setMouseOperate(annotationHoverOperate || {
        id: ''
      });

      this._waitingForMouseMove = false;
    }
    /**
     * é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
     * @param event
     */

  }, {
    key: "mouseDownEvent",
    value: function mouseDownEvent(event) {
      var coordinate = {
        x: event.localX,
        y: event.paneY
      };

      var _this$_chartStore$sha2 = this._chartStore.shapeStore().progressInstance(),
          instance = _this$_chartStore$sha2.instance,
          paneId = _this$_chartStore$sha2.paneId;

      var shapeHoverOperate = {
        id: '',
        element: ShapeMouseOperateElement.NONE,
        elementIndex: -1
      };
      var shapeClickOperate;

      if (instance && instance.isDrawing() && paneId === event.paneId) {
        instance.mouseLeftButtonDownForDrawing();
        shapeClickOperate = instance.checkEventCoordinateOn(coordinate);
      } else {
        var shapes = this._chartStore.shapeStore().instances(event.paneId);

        var _iterator2 = _createForOfIteratorHelper(shapes),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var shape = _step2.value;
            shapeClickOperate = shape.checkEventCoordinateOn(coordinate);

            if (shapeClickOperate) {
              this._chartStore.shapeStore().updatePressedInstance(shape, event.paneId, shapeClickOperate.element);

              if (shapeClickOperate.element === ShapeMouseOperateElement.POINT) {
                shapeHoverOperate = _objectSpread2({}, shapeClickOperate);
              } else {
                shape.startPressedOtherMove(coordinate);
              }

              shape.onClick({
                id: shapeClickOperate.id,
                points: shape.points(),
                event: event
              });
              break;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        var visibleAnnotations = this._chartStore.annotationStore().get(event.paneId);

        if (visibleAnnotations) {
          var _iterator3 = _createForOfIteratorHelper(visibleAnnotations),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var an = _step3.value;
              var annotationOperate = an.checkEventCoordinateOn(coordinate);

              if (annotationOperate) {
                an.onClick({
                  id: annotationOperate.id,
                  points: an.points(),
                  event: event
                });
                break;
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      }

      var shapeOperateValid = this._chartStore.shapeStore().setMouseOperate({
        hover: shapeHoverOperate,
        click: shapeClickOperate || {
          id: '',
          element: ShapeMouseOperateElement.NONE,
          elementIndex: -1
        }
      });

      if (shapeOperateValid) {
        this._chartStore.invalidate(InvalidateLevel.OVERLAY);
      }
    }
  }, {
    key: "mouseRightDownEvent",
    value: function mouseRightDownEvent(event) {
      var _this$_chartStore$sha3 = this._chartStore.shapeStore().progressInstance(),
          instance = _this$_chartStore$sha3.instance;

      var removeShape;

      if (instance) {
        removeShape = instance;
      } else {
        var shapes = this._chartStore.shapeStore().instances(event.paneId);

        removeShape = shapes.find(function (s) {
          return s.checkEventCoordinateOn({
            x: event.localX,
            y: event.paneY
          });
        });
      }

      if (removeShape && !removeShape.onRightClick({
        id: removeShape.id(),
        points: removeShape.points(),
        event: event
      })) {
        this._chartStore.shapeStore().removeInstance(removeShape.id());
      }

      var visibleAnnotations = this._chartStore.annotationStore().get(event.paneId);

      if (visibleAnnotations) {
        var annotation = visibleAnnotations.find(function (an) {
          return an.checkEventCoordinateOn({
            x: event.localX,
            y: event.paneY
          });
        });

        if (annotation) {
          annotation.onRightClick({
            id: annotation.id(),
            points: annotation.points(),
            event: event
          });
        }
      }
    }
  }, {
    key: "pressedMouseMoveEvent",
    value: function pressedMouseMoveEvent(event) {
      var _this$_chartStore$sha4 = this._chartStore.shapeStore().pressedInstance(),
          instance = _this$_chartStore$sha4.instance,
          paneId = _this$_chartStore$sha4.paneId,
          element = _this$_chartStore$sha4.element;

      if (instance && paneId === event.paneId) {
        var coordinate = {
          x: event.localX,
          y: event.paneY
        };

        if (element === ShapeMouseOperateElement.POINT) {
          instance.mousePressedPointMove(coordinate, event);
        } else {
          instance.mousePressedOtherMove(coordinate, event);
        }

        this._chartStore.crosshairStore().set({
          x: event.localX,
          y: event.paneY,
          paneId: event.paneId
        });
      }
    }
  }]);

  return OverlayEventHandler;
}(EventHandler);

var KeyBoardCode = {
  EQUAL: 'Equal',
  MINUS: 'Minus',
  ARROW_LEFT: 'ArrowLeft',
  ARROW_RIGHT: 'ArrowRight'
};

var KeyBoardEventHandler = /*#__PURE__*/function (_EventHandler) {
  _inherits(KeyBoardEventHandler, _EventHandler);

  var _super = _createSuper(KeyBoardEventHandler);

  function KeyBoardEventHandler() {
    _classCallCheck(this, KeyBoardEventHandler);

    return _super.apply(this, arguments);
  }

  _createClass(KeyBoardEventHandler, [{
    key: "keyBoardDownEvent",
    value:
    /**
     * é”®ç›˜äº‹ä»¶
     * @param event
     */
    function keyBoardDownEvent(event) {
      if (event.shiftKey) {
        switch (event.code) {
          case KeyBoardCode.EQUAL:
            {
              this._chartStore.timeScaleStore().zoom(0.5);

              break;
            }

          case KeyBoardCode.MINUS:
            {
              this._chartStore.timeScaleStore().zoom(-0.5);

              break;
            }

          case KeyBoardCode.ARROW_LEFT:
            {
              this._chartStore.timeScaleStore().startScroll();

              this._chartStore.timeScaleStore().scroll(-3 * this._chartStore.timeScaleStore().dataSpace());

              break;
            }

          case KeyBoardCode.ARROW_RIGHT:
            {
              this._chartStore.timeScaleStore().startScroll();

              this._chartStore.timeScaleStore().scroll(3 * this._chartStore.timeScaleStore().dataSpace());

              break;
            }
        }
      }
    }
  }]);

  return KeyBoardEventHandler;
}(EventHandler);

var ChartEvent = /*#__PURE__*/function () {
  function ChartEvent(target, chartStore, yAxis) {
    _classCallCheck(this, ChartEvent);

    this._target = target;
    this._chartStore = chartStore;
    this._chartContentLeftRight = {};
    this._chartContentTopBottom = {};
    this._paneContentSize = {};
    this._event = new EventBase(this._target, {
      pinchStartEvent: this._pinchStartEvent.bind(this),
      pinchEvent: this._pinchEvent.bind(this),
      mouseUpEvent: this._mouseUpEvent.bind(this),
      mouseClickEvent: this._mouseClickEvent.bind(this),
      mouseDownEvent: this._mouseDownEvent.bind(this),
      mouseRightDownEvent: this._mouseRightDownEvent.bind(this),
      mouseLeaveEvent: this._mouseLeaveEvent.bind(this),
      mouseMoveEvent: this._mouseMoveEvent.bind(this),
      mouseWheelEvent: this._mouseWheelEvent.bind(this),
      pressedMouseMoveEvent: this._pressedMouseMoveEvent.bind(this),
      longTapEvent: this._longTapEvent.bind(this)
    }, {
      treatVertTouchDragAsPageScroll: true,
      treatHorzTouchDragAsPageScroll: false
    });
    this._boundKeyBoardDownEvent = this._keyBoardDownEvent.bind(this);

    this._target.addEventListener('keydown', this._boundKeyBoardDownEvent);

    this._boundContextMenuEvent = function (e) {
      e.preventDefault();
    };

    this._target.addEventListener('contextmenu', this._boundContextMenuEvent, false);

    this._zoomScrollEventHandler = new ZoomScrollEventHandler(chartStore);
    this._overlayEventHandler = new OverlayEventHandler(chartStore, yAxis);
    this._keyBoardEventHandler = new KeyBoardEventHandler(chartStore);
  }

  _createClass(ChartEvent, [{
    key: "_keyBoardDownEvent",
    value: function _keyBoardDownEvent(event) {
      this._keyBoardEventHandler.keyBoardDownEvent(event);
    }
  }, {
    key: "_pinchStartEvent",
    value: function _pinchStartEvent() {
      this._zoomScrollEventHandler.pinchStartEvent();
    }
  }, {
    key: "_pinchEvent",
    value: function _pinchEvent(middleCoordinate, scale) {
      this._zoomScrollEventHandler.pinchEvent(middleCoordinate, scale);
    }
  }, {
    key: "_mouseUpEvent",
    value: function _mouseUpEvent(event) {
      if (this._checkEventInChartContent(event)) {
        this._target.style.cursor = 'crosshair';
      }

      this._zoomScrollEventHandler.mouseUpEvent(event);

      if (this._shouldPerformOverlayEvent()) {
        this._overlayEventHandler.mouseUpEvent(event);
      }
    }
  }, {
    key: "_mouseLeaveEvent",
    value: function _mouseLeaveEvent(event) {
      this._zoomScrollEventHandler.mouseLeaveEvent(event);
    }
  }, {
    key: "_mouseMoveEvent",
    value: function _mouseMoveEvent(event) {
      // å½“äº‹ä»¶ç›®æ ‡æ˜¯åœ¨å®¹å™¨å†…éƒ¨å…ƒç´ æ—¶ï¼Œä¸å‡ºæ¥moveäº‹ä»¶
      // ç­‰å¾…å¯»æ‰¾æœ€ä¼˜è§£
      if (event.target instanceof HTMLCanvasElement) {
        if (this._checkEventInChartContent(event)) {
          this._target.style.cursor = 'crosshair';

          var compatEvent = this._compatChartEvent(event, true);

          if (this._shouldPerformOverlayEvent()) {
            this._overlayEventHandler.mouseMoveEvent(compatEvent);
          }

          if (!this._chartStore.dragPaneFlag()) {
            this._zoomScrollEventHandler.mouseMoveEvent(compatEvent);
          }
        } else {
          this._target.style.cursor = 'default';

          this._zoomScrollEventHandler.mouseLeaveEvent(event);
        }
      } else {
        this._target.style.cursor = 'default';

        this._chartStore.crosshairStore().set();
      }
    }
  }, {
    key: "_mouseWheelEvent",
    value: function _mouseWheelEvent(event) {
      if (this._checkZoomScroll() && this._checkEventInChartContent(event)) {
        this._zoomScrollEventHandler.mouseWheelEvent(this._compatChartEvent(event));
      }
    }
  }, {
    key: "_mouseClickEvent",
    value: function _mouseClickEvent(event) {
      if (this._checkZoomScroll() && this._checkEventInChartContent(event)) {
        this._zoomScrollEventHandler.mouseClickEvent(this._compatChartEvent(event, true));

        this._modifyEventOptions(event);
      }
    }
  }, {
    key: "_mouseDownEvent",
    value: function _mouseDownEvent(event) {
      if (this._checkEventInChartContent(event)) {
        this._target.style.cursor = 'pointer';

        var compatEvent = this._compatChartEvent(event, true);

        if (this._shouldPerformOverlayEvent()) {
          this._overlayEventHandler.mouseDownEvent(compatEvent);
        }

        if (this._checkZoomScroll()) {
          this._zoomScrollEventHandler.mouseDownEvent(compatEvent);

          this._modifyEventOptions(event);
        }
      }
    }
  }, {
    key: "_mouseRightDownEvent",
    value: function _mouseRightDownEvent(event) {
      if (this._shouldPerformOverlayEvent() && this._checkEventInChartContent(event)) {
        this._overlayEventHandler.mouseRightDownEvent(this._compatChartEvent(event, true));
      }
    }
  }, {
    key: "_pressedMouseMoveEvent",
    value: function _pressedMouseMoveEvent(event) {
      if (this._checkEventInChartContent(event)) {
        var compatEvent = this._compatChartEvent(event, true);

        if (this._checkZoomScroll()) {
          this._zoomScrollEventHandler.pressedMouseMoveEvent(compatEvent);

          this._modifyEventOptions(event);
        } else {
          this._overlayEventHandler.pressedMouseMoveEvent(compatEvent);
        }
      }
    }
  }, {
    key: "_longTapEvent",
    value: function _longTapEvent(event) {
      if (this._checkZoomScroll() && this._checkEventInChartContent(event)) {
        this._zoomScrollEventHandler.longTapEvent(this._compatChartEvent(event, true));

        this._modifyEventOptions(event);
      }
    }
  }, {
    key: "_checkZoomScroll",
    value: function _checkZoomScroll() {
      return !this._chartStore.dragPaneFlag() && !this._chartStore.shapeStore().isPressed() && !this._chartStore.shapeStore().isDrawing();
    }
    /**
     * æ˜¯å¦éœ€è¦å¤„ç†å›¾å½¢æ ‡è®°äº‹ä»¶
     * @return {boolean}
     * @private
     */

  }, {
    key: "_shouldPerformOverlayEvent",
    value: function _shouldPerformOverlayEvent() {
      return !this._chartStore.shapeStore().isEmpty() || !this._chartStore.annotationStore().isEmpty();
    }
    /**
     * ä¿®æ”¹äº‹ä»¶é…ç½®
     * @param event
     */

  }, {
    key: "_modifyEventOptions",
    value: function _modifyEventOptions(event) {
      if (isTouch(event) && this._chartStore.crosshairStore().get().paneId) {
        this._event.setOptions({
          treatVertTouchDragAsPageScroll: false
        });
      } else {
        this._event.setOptions({
          treatVertTouchDragAsPageScroll: true
        });
      }
    }
    /**
     * äº‹ä»¶ä¿¡æ¯å…¼å®¹
     * @param {*} event
     * @param {*} compatY
     * @returns
     */

  }, {
    key: "_compatChartEvent",
    value: function _compatChartEvent(event, compatY) {
      if (compatY) {
        for (var id in this._paneContentSize) {
          if (Object.prototype.hasOwnProperty.call(this._paneContentSize, id)) {
            var size = this._paneContentSize[id];

            if (event.localY > size.contentTop && event.localY < size.contentBottom) {
              event.paneY = event.localY - size.contentTop;
              event.paneId = id;
              break;
            }
          }
        }
      }

      event.localX -= this._chartContentLeftRight.contentLeft;
      return event;
    }
    /**
     * æ£€æŸ¥äº‹ä»¶æ˜¯å¦åœ¨å›¾è¡¨å†…å®¹å†…
     * @param {*} event
     * @returns
     */

  }, {
    key: "_checkEventInChartContent",
    value: function _checkEventInChartContent(event) {
      return event.localX > this._chartContentLeftRight.contentLeft && event.localX < this._chartContentLeftRight.contentRight && event.localY > this._chartContentTopBottom.contentTop && event.localY < this._chartContentTopBottom.contentBottom;
    }
  }, {
    key: "setChartContentLeftRight",
    value: function setChartContentLeftRight(chartContentLeftRight) {
      this._chartContentLeftRight = chartContentLeftRight;
    }
  }, {
    key: "setChartContentTopBottom",
    value: function setChartContentTopBottom(chartContentTopBottom) {
      this._chartContentTopBottom = chartContentTopBottom;
    }
  }, {
    key: "setPaneContentSize",
    value: function setPaneContentSize(paneContentSize) {
      this._paneContentSize = paneContentSize;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._event.destroy();

      this._target.removeEventListener('keydown', this._boundKeyBoardDownEvent);

      this._target.removeEventListener('contextmenu', this._boundContextMenuEvent);
    }
  }]);

  return ChartEvent;
}();

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function throttle(func) {
  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;
  var previous = 0;
  return function () {
    var now = Date.now();
    var context = this;
    var args = arguments;

    if (now - previous > wait) {
      func.apply(context, args);
      previous = now;
    }
  };
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * æ¸²æŸ“å¡«å……è±å½¢
 * @param ctx
 * @param color
 * @param centerCoordinate
 * @param width
 * @param height
 */
function renderFillDiamond(ctx, color, centerCoordinate, width, height) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(centerCoordinate.x - width / 2, centerCoordinate.y);
  ctx.lineTo(centerCoordinate.x, centerCoordinate.y - height / 2);
  ctx.lineTo(centerCoordinate.x + width / 2, centerCoordinate.y);
  ctx.lineTo(centerCoordinate.x, centerCoordinate.y + height / 2);
  ctx.closePath();
  ctx.fill();
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * æ¸²æŸ“å¡«å……è±å½¢
 * @param ctx
 * @param color
 * @param centerCoordinate
 * @param width
 * @param height
 */
function renderFillTriangle(ctx, color, centerCoordinate, width, height) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(centerCoordinate.x - width / 2, centerCoordinate.y + height / 2);
  ctx.lineTo(centerCoordinate.x, centerCoordinate.y - height / 2);
  ctx.lineTo(centerCoordinate.x + width / 2, centerCoordinate.y + height / 2);
  ctx.closePath();
  ctx.fill();
}

/**
 * æ³¨è§£
 */

var Annotation = /*#__PURE__*/function (_Overlay) {
  _inherits(Annotation, _Overlay);

  var _super = _createSuper(Annotation);

  function Annotation(_ref) {
    var _this;

    var id = _ref.id,
        point = _ref.point,
        chartStore = _ref.chartStore,
        xAxis = _ref.xAxis,
        yAxis = _ref.yAxis,
        styles = _ref.styles;

    _classCallCheck(this, Annotation);

    _this = _super.call(this, {
      id: id,
      chartStore: chartStore,
      xAxis: xAxis,
      yAxis: yAxis
    });
    _this._point = point;
    _this._symbolCoordinate = {};

    _this.setStyles(styles, chartStore.styleOptions().annotation);

    return _this;
  }
  /**
   * ç»˜åˆ¶æ ‡è¯†
   * @param ctx
   * @param isActive
   * @param styles
   * @private
   */


  _createClass(Annotation, [{
    key: "_drawSymbol",
    value: function _drawSymbol(ctx, isActive, styles) {
      var barSpace = this._chartStore.timeScaleStore().barSpace();

      var symbolOptions = styles.symbol;
      var styleSize = symbolOptions.size;
      var styleActiveSize = symbolOptions.activeSize;
      var size = isActive ? isNumber(styleActiveSize) ? styleActiveSize : barSpace : isNumber(styleSize) ? styleSize : barSpace;
      var color = isActive ? symbolOptions.activeColor : symbolOptions.color;

      switch (symbolOptions.type) {
        case AnnotationSymbolType.CIRCLE:
          {
            renderFillCircle(ctx, color, this._symbolCoordinate, size / 2);
            break;
          }

        case AnnotationSymbolType.RECT:
          {
            renderFillRect(ctx, color, this._symbolCoordinate.x - size / 2, this._symbolCoordinate.y - size / 2, size, size);
            break;
          }

        case AnnotationSymbolType.DIAMOND:
          {
            renderFillDiamond(ctx, color, this._symbolCoordinate, size, size);
            break;
          }

        case AnnotationSymbolType.TRIANGLE:
          {
            renderFillTriangle(ctx, color, this._symbolCoordinate, size, size);
            break;
          }

        case AnnotationSymbolType.CUSTOM:
          {
            ctx.save();
            this.drawCustomSymbol({
              ctx: ctx,
              point: this._point,
              coordinate: this._symbolCoordinate,
              viewport: {
                width: this._xAxis.width(),
                height: this._yAxis.height(),
                barSpace: barSpace
              },
              styles: symbolOptions,
              isActive: isActive
            });
            ctx.restore();
            break;
          }
      }
    }
  }, {
    key: "draw",
    value: function draw(ctx) {
      var styles = this._styles || this._chartStore.styleOptions().annotation;

      var offset = styles.offset || [0, 0];
      var y = 0;

      switch (styles.position) {
        case OverlayPosition.POINT:
          {
            y = this._yAxis.convertToPixel(this._point.value);
            break;
          }

        case OverlayPosition.TOP:
          {
            y = 0;
            break;
          }

        case OverlayPosition.BOTTOM:
          {
            y = this._yAxis.height();
            break;
          }
      }

      this._symbolCoordinate.y = y + offset[0];

      var isActive = this._id === this._chartStore.annotationStore().mouseOperate().id;

      this._drawSymbol(ctx, isActive, styles);

      if (this.drawExtend) {
        ctx.save();
        this.drawExtend({
          ctx: ctx,
          point: this._point,
          coordinate: this._symbolCoordinate,
          viewport: {
            width: this._xAxis.width(),
            height: this._yAxis.height()
          },
          styles: styles,
          isActive: isActive
        });
        ctx.restore();
      }
    }
  }, {
    key: "checkEventCoordinateOn",
    value: function checkEventCoordinateOn(eventCoordinate) {
      var barSpace = this._chartStore.timeScaleStore().barSpace();

      var styles = this._styles || this._chartStore.styleOptions().annotation;

      var symbolOptions = styles.symbol;
      var size = isNumber(symbolOptions.size) ? symbolOptions.size : barSpace;
      var isOn;

      switch (symbolOptions.type) {
        case AnnotationSymbolType.CIRCLE:
          {
            isOn = checkCoordinateInCircle(this._symbolCoordinate, size / 2, eventCoordinate);
            break;
          }

        case AnnotationSymbolType.RECT:
          {
            var coordinate1 = {
              x: this._symbolCoordinate.x - size / 2,
              y: this._symbolCoordinate.y - size / 2
            };
            var coordinate2 = {
              x: this._symbolCoordinate.x + size / 2,
              y: this._symbolCoordinate.y + size / 2
            };
            isOn = checkCoordinateInRect(coordinate1, coordinate2, eventCoordinate);
            break;
          }

        case AnnotationSymbolType.DIAMOND:
          {
            isOn = checkCoordinateInDiamond(this._symbolCoordinate, size, size, eventCoordinate);
            break;
          }

        case AnnotationSymbolType.TRIANGLE:
          {
            isOn = checkCoordinateInTriangle([{
              x: this._symbolCoordinate.x - size / 2,
              y: this._symbolCoordinate.y + size / 2
            }, {
              x: this._symbolCoordinate.x,
              y: this._symbolCoordinate.y - size / 2
            }, {
              x: this._symbolCoordinate.x + size / 2,
              y: this._symbolCoordinate.y + size / 2
            }], eventCoordinate);
            break;
          }

        case AnnotationSymbolType.CUSTOM:
          {
            isOn = this.checkEventCoordinateOnCustomSymbol({
              eventCoordinate: eventCoordinate,
              coordinate: this._symbolCoordinate,
              size: size
            });
            break;
          }
      }

      if (isOn) {
        return {
          id: this._id,
          instance: this
        };
      }
    }
    /**
     * ç”Ÿæˆæ ‡è¯†åæ ‡
     * @param x
     */

  }, {
    key: "createSymbolCoordinate",
    value: function createSymbolCoordinate(x) {
      var styles = this._styles || this._chartStore.styleOptions().annotation;

      var offset = styles.offset || [0, 0];
      this._symbolCoordinate = {
        x: x + offset[1]
      };
    }
    /**
     * è·å–ç‚¹
     * @return {*}
     */

  }, {
    key: "points",
    value: function points() {
      return this._point;
    }
    /**
     * æ£€æŸ¥é¼ æ ‡ç‚¹æ˜¯å¦åœ¨è‡ªå®šä¹‰æ ‡è¯†å†…
     * @param eventCoordinate
     * @param coordinate
     * @param size
     */

  }, {
    key: "checkEventCoordinateOnCustomSymbol",
    value: function checkEventCoordinateOnCustomSymbol(_ref2) {
      _ref2.eventCoordinate;
          _ref2.coordinate;
          _ref2.size;
    }
    /**
     * ç»˜åˆ¶è‡ªå®šä¹‰æ ‡è¯†
     * @param ctx
     * @param point
     * @param coordinate
     * @param viewport
     * @param styles
     * @param isActive
     */

  }, {
    key: "drawCustomSymbol",
    value: function drawCustomSymbol(_ref3) {
      _ref3.ctx;
          _ref3.point;
          _ref3.coordinate;
          _ref3.viewport;
          _ref3.styles;
          _ref3.isActive;
    }
  }]);

  return Annotation;
}(Overlay);

var Tag = /*#__PURE__*/function (_Overlay) {
  _inherits(Tag, _Overlay);

  var _super = _createSuper(Tag);

  function Tag(_ref) {
    var _this;

    var id = _ref.id,
        point = _ref.point,
        text = _ref.text,
        mark = _ref.mark,
        chartStore = _ref.chartStore,
        xAxis = _ref.xAxis,
        yAxis = _ref.yAxis,
        styles = _ref.styles;

    _classCallCheck(this, Tag);

    _this = _super.call(this, {
      id: id,
      chartStore: chartStore,
      xAxis: xAxis,
      yAxis: yAxis
    });
    _this._point = point || {};
    _this._text = text;
    _this._mark = mark;

    _this.setStyles(styles, chartStore.styleOptions().tag);

    return _this;
  }
  /**
   * æ›´æ–°
   * @param point
   * @param text
   * @param mark
   * @param styles
   * @return {boolean}
   */


  _createClass(Tag, [{
    key: "update",
    value: function update(_ref2) {
      var point = _ref2.point,
          text = _ref2.text,
          mark = _ref2.mark,
          styles = _ref2.styles;
      var success = false;

      if (isObject(point)) {
        this._point = point;
        success = true;
      }

      if (isValid(text)) {
        this._text = text;
        success = true;
      }

      if (isValid(mark)) {
        this._mark = mark;
        success = true;
      }

      if (this.setStyles(styles, this._chartStore.styleOptions().tag)) {
        success = true;
      }

      return success;
    }
    /**
     * ç»˜åˆ¶æ ‡è®°å’Œçº¿
     * @param ctx
     */

  }, {
    key: "drawMarkLine",
    value: function drawMarkLine(ctx) {
      var options = this._chartStore.styleOptions();

      var yAxisOptions = options.yAxis;
      var tagOptions = this._styles || options.tag;

      var y = this._getY(tagOptions);

      ctx.save();

      this._drawLine(ctx, y, tagOptions, yAxisOptions);

      this._drawMark(ctx, y, tagOptions, yAxisOptions);

      ctx.restore();
    }
    /**
     * ç»˜åˆ¶å€¼
     */

  }, {
    key: "drawText",
    value: function drawText(ctx) {
      if (!isValid(this._text)) {
        return;
      }

      var options = this._chartStore.styleOptions();

      var tagOptions = this._styles || options.tag;
      var tagTextOptions = tagOptions.text;
      ctx.save();
      var rectWidth = getTextRectWidth(ctx, this._text, tagTextOptions);
      var rectHeight = getTextRectHeight(tagTextOptions);
      var x;

      if (this._yAxis.isFromYAxisZero()) {
        x = 0;
      } else {
        x = this._yAxis.width() - rectWidth;
      }

      var y = this._getY(tagOptions);

      renderStrokeFillRoundRect(ctx, tagTextOptions.backgroundColor, tagTextOptions.borderColor, tagTextOptions.borderSize, x, y - rectHeight / 2, rectWidth, rectHeight, tagTextOptions.borderRadius);
      renderText(ctx, tagTextOptions.color, x + tagTextOptions.paddingLeft, y, this._text);
      ctx.restore();
    }
    /**
     * ç»˜åˆ¶çº¿
     * @param ctx
     * @param y
     * @param tagOptions
     * @private
     */

  }, {
    key: "_drawLine",
    value: function _drawLine(ctx, y, tagOptions, yAxisOptions) {
      var tagLineOptions = tagOptions.line;

      if (!tagLineOptions.show) {
        return;
      }

      ctx.save();
      var textRectWidth = getTextRectWidth(ctx, this._text, tagOptions.text);
      var markRectWidth = getTextRectWidth(ctx, this._mark, tagOptions.mark);
      ctx.strokeStyle = tagLineOptions.color;
      ctx.lineWidth = tagLineOptions.size;

      if (tagLineOptions.style === LineStyle.DASH) {
        ctx.setLineDash(tagLineOptions.dashValue);
      }

      var markOffset = tagOptions.mark.offset;
      var lines = [];
      var textValid = isValid(this._text);
      var markValid = isValid(this._mark);

      if (yAxisOptions.inside) {
        if (yAxisOptions.position === YAxisPosition.LEFT) {
          if (textValid && markValid) {
            if (markOffset > 0) {
              lines.push([textRectWidth, textRectWidth + markOffset]);
              lines.push([textRectWidth + markOffset + markRectWidth, this._xAxis.width()]);
            } else {
              if (Math.abs(markOffset) < Math.min(textRectWidth, markRectWidth)) {
                lines.push([textRectWidth + markOffset + markRectWidth, this._xAxis.width()]);
              } else {
                lines.push([Math.max(textRectWidth, markRectWidth), this._xAxis.width()]);
              }
            }
          } else {
            if (textValid) {
              lines.push([textRectWidth, this._xAxis.width()]);
            } else if (markValid) {
              if (markOffset > 0) {
                lines.push([0, markOffset]);
                lines.push([markOffset + markRectWidth, this._xAxis.width()]);
              } else {
                if (Math.abs(markOffset) < markRectWidth) {
                  lines.push([markOffset + markRectWidth, this._xAxis.width()]);
                } else {
                  lines.push([0, this._xAxis.width()]);
                }
              }
            } else {
              lines.push([0, this._xAxis.width()]);
            }
          }
        } else {
          if (textValid && markValid) {
            if (markOffset < 0) {
              lines.push([0, this._xAxis.width() - textRectWidth + markOffset - markRectWidth]);
              lines.push([this._xAxis.width() - textRectWidth + markOffset, this._xAxis.width() - textRectWidth]);
            } else {
              if (markOffset < Math.min(textRectWidth, markRectWidth)) {
                lines.push([0, this._xAxis.width() - textRectWidth - markRectWidth + markOffset]);
              } else {
                lines.push([0, this._xAxis.width() - Math.max(textRectWidth, markRectWidth)]);
              }
            }
          } else {
            if (textValid) {
              lines.push([0, this._xAxis.width() - textRectWidth]);
            } else if (markValid) {
              if (markOffset < 0) {
                lines.push([0, this._xAxis.width() + markOffset - markRectWidth]);
                lines.push([this._xAxis.width() + markOffset, this._xAxis.width()]);
              } else {
                if (markOffset < markRectWidth) {
                  lines.push([0, this._xAxis.width() - markRectWidth + markOffset]);
                } else {
                  lines.push([0, this._xAxis.width()]);
                }
              }
            } else {
              lines.push([0, this._xAxis.width()]);
            }
          }
        }
      } else {
        if (yAxisOptions.position === YAxisPosition.LEFT) {
          if (markValid) {
            if (markOffset > 0) {
              lines.push([0, markOffset]);
              lines.push([markOffset + markRectWidth, this._xAxis.width()]);
            } else {
              if (Math.abs(markOffset) < markRectWidth) {
                lines.push([markRectWidth + markOffset, this._xAxis.width()]);
              } else {
                lines.push([0, this._xAxis.width()]);
              }
            }
          } else {
            lines.push([0, this._xAxis.width()]);
          }
        } else {
          if (markValid) {
            if (markOffset < 0) {
              lines.push([0, this._xAxis.width() - markRectWidth + markOffset]);
              lines.push([this._xAxis.width() + markOffset, this._xAxis.width()]);
            } else {
              if (markOffset < markRectWidth) {
                lines.push([0, this._xAxis.width() - markRectWidth + markOffset]);
              } else {
                lines.push([0, this._xAxis.width()]);
              }
            }
          } else {
            lines.push([0, this._xAxis.width()]);
          }
        }
      }

      lines.forEach(function (line) {
        renderHorizontalLine(ctx, y, line[0], line[1]);
      });
      ctx.restore();
    }
    /**
     * ç»˜åˆ¶æ ‡è®°
     * @param ctx
     * @param y
     * @param tagOptions
     * @param yAxisOptions
     * @private
     */

  }, {
    key: "_drawMark",
    value: function _drawMark(ctx, y, tagOptions, yAxisOptions) {
      if (!isValid(this._mark)) {
        return;
      }

      var tagMarkOptions = tagOptions.mark;
      var rectWidth = getTextRectWidth(ctx, this._mark, tagMarkOptions);
      var rectHeight = getTextRectHeight(tagMarkOptions);
      var x;

      if (yAxisOptions.inside) {
        var textRectWidth = 0;

        if (isValid(this._text)) {
          textRectWidth = getTextRectWidth(ctx, this._text, tagOptions.text);
        }

        if (yAxisOptions.position === YAxisPosition.LEFT) {
          x = textRectWidth;
        } else {
          x = this._xAxis.width() - textRectWidth - rectWidth;
        }
      } else {
        if (yAxisOptions.position === YAxisPosition.LEFT) {
          x = 0;
        } else {
          x = this._xAxis.width() - rectWidth;
        }
      }

      x += tagMarkOptions.offset;
      renderStrokeFillRoundRect(ctx, tagMarkOptions.backgroundColor, tagMarkOptions.borderColor, tagMarkOptions.borderSize, x, y - rectHeight / 2, rectWidth, rectHeight, tagMarkOptions.borderRadius);
      ctx.textBaseline = 'middle';
      ctx.font = createFont(tagMarkOptions.size, tagMarkOptions.weight, tagMarkOptions.family);
      renderText(ctx, tagMarkOptions.color, x + tagMarkOptions.paddingLeft, y, this._mark);
    }
    /**
     * è·å–åæ ‡yå€¼
     * @param tagOptions
     * @return {*}
     * @private
     */

  }, {
    key: "_getY",
    value: function _getY(tagOptions) {
      var offset = tagOptions.offset;

      switch (tagOptions.position) {
        case OverlayPosition.TOP:
          {
            return offset;
          }

        case OverlayPosition.BOTTOM:
          {
            return this._yAxis.height() + offset;
          }

        default:
          {
            return this._yAxis.convertToNicePixel(this._point.value) + offset;
          }
      }
    }
  }]);

  return Tag;
}(Overlay);

var DEFAULT_TECHNICAL_INDICATOR_PANE_HEIGHT = 100; // æŠ€æœ¯æŒ‡æ ‡çª—å£idå‰ç¼€

var TECHNICAL_INDICATOR_PANE_ID_PREFIX = 'technical_indicator_pane_'; // å›¾å½¢idå‰ç¼€

var SHAPE_ID_PREFIX = 'shape_'; // èœ¡çƒ›å›¾çª—å£id

var CANDLE_PANE_ID = 'candle_pane'; // xè½´çª—å£id

var XAXIS_PANE_ID = 'x_axis_pane';

var ChartPane = /*#__PURE__*/function () {
  function ChartPane(container, styleOptions) {
    var _this = this;

    _classCallCheck(this, ChartPane);

    this._initChartContainer(container);

    this._shapeBaseId = 0;
    this._paneBaseId = 0;
    this._separatorDragStartTopPaneHeight = 0;
    this._separatorDragStartBottomPaneHeight = 0;
    this._chartStore = new ChartStore(styleOptions, {
      invalidate: this._invalidatePane.bind(this),
      crosshair: this._crosshairObserver.bind(this)
    });
    this._xAxisPane = new XAxisPane({
      id: XAXIS_PANE_ID,
      container: this._chartContainer,
      chartStore: this._chartStore
    });
    this._panes = new Map([[CANDLE_PANE_ID, new CandlePane({
      container: this._chartContainer,
      chartStore: this._chartStore,
      xAxis: this._xAxisPane.xAxis(),
      id: CANDLE_PANE_ID
    })]]);
    this._separators = new Map();
    this._chartWidth = {};
    this._chartHeight = {};
    this._chartEvent = new ChartEvent(this._chartContainer, this._chartStore, function (paneId) {
      return _this._panes.get(paneId).yAxis();
    });
    this.adjustPaneViewport(true, true, true);
  }
  /**
   * åˆå§‹åŒ–å›¾è¡¨å®¹å™¨
   * @param container
   * @private
   */


  _createClass(ChartPane, [{
    key: "_initChartContainer",
    value: function _initChartContainer(container) {
      this._container = container;
      this._chartContainer = createElement('div', {
        userSelect: 'none',
        webkitUserSelect: 'none',
        msUserSelect: 'none',
        MozUserSelect: 'none',
        webkitTapHighlightColor: 'transparent',
        position: 'relative',
        outline: 'none',
        borderStyle: 'none',
        width: '100%',
        cursor: 'crosshair',
        boxSizing: 'border-box'
      });
      this._chartContainer.tabIndex = 1;
      container.appendChild(this._chartContainer);
    }
    /**
     * åå­—å…‰æ ‡è§‚å¯Ÿè€…
     * @private
     */

  }, {
    key: "_crosshairObserver",
    value: function _crosshairObserver(_ref) {
      var _this2 = this;

      var crosshair = _ref.crosshair,
          dataIndex = _ref.dataIndex,
          kLineData = _ref.kLineData,
          x = _ref.x,
          y = _ref.y;

      if (this._chartStore.actionStore().has(ActionType.CROSSHAIR) || this._chartStore.actionStore().has(ActionType.TOOLTIP)) {
        var techDatas = {};

        this._panes.forEach(function (_, id) {
          var data = {};
          var techDataList = [];

          var techs = _this2.chartStore().technicalIndicatorStore().instances(id);

          techs.forEach(function (tech) {
            var result = tech.result;
            var techData = result[dataIndex];
            data[tech.name] = techData;
            techDataList.push({
              name: tech.name,
              data: techData
            });
          });
          techDatas[id] = data;

          _this2._chartStore.actionStore().execute(ActionType.TOOLTIP, {
            paneId: id,
            dataIndex: dataIndex,
            kLineData: kLineData,
            technicalIndicatorData: techDataList
          });
        });

        if (crosshair.paneId) {
          this._chartStore.actionStore().execute(ActionType.CROSSHAIR, {
            coordinate: {
              x: x,
              y: y
            },
            dataIndex: dataIndex,
            kLineData: kLineData,
            technicalIndicatorData: techDatas
          });
        }
      }
    }
    /**
     * åˆ†å‰²çº¿æ‹–æ‹½å¼€å§‹
     * @param topPaneId
     * @param bottomPaneId
     * @private
     */

  }, {
    key: "_separatorStartDrag",
    value: function _separatorStartDrag(topPaneId, bottomPaneId) {
      this._separatorDragStartTopPaneHeight = this._panes.get(topPaneId).height();
      this._separatorDragStartBottomPaneHeight = this._panes.get(bottomPaneId).height();
    }
    /**
     * åˆ†å‰²çº¿æ‹–æ‹½
     * @param dragDistance
     * @param topPaneId
     * @param bottomPaneId
     * @private
     */

  }, {
    key: "_separatorDrag",
    value: function _separatorDrag(dragDistance, topPaneId, bottomPaneId) {
      var topPaneHeight = this._separatorDragStartTopPaneHeight + dragDistance;
      var bottomPaneHeight = this._separatorDragStartBottomPaneHeight - dragDistance;

      if (topPaneHeight > this._separatorDragStartTopPaneHeight + this._separatorDragStartBottomPaneHeight) {
        topPaneHeight = this._separatorDragStartTopPaneHeight + this._separatorDragStartBottomPaneHeight;
        bottomPaneHeight = 0;
      }

      if (topPaneHeight < 0) {
        topPaneHeight = 0;
        bottomPaneHeight = this._separatorDragStartTopPaneHeight + this._separatorDragStartBottomPaneHeight;
      }

      this._panes.get(topPaneId).setHeight(topPaneHeight);

      this._panes.get(bottomPaneId).setHeight(bottomPaneHeight);

      this._chartStore.actionStore().execute(ActionType.PANE_DRAG, {
        topPaneId: topPaneId,
        bottomPaneId: bottomPaneId,
        topPaneHeight: topPaneHeight,
        bottomPaneHeight: bottomPaneHeight
      });

      this.adjustPaneViewport(true, true, true, true, true);
    }
    /**
     * æ›´æ–°æ‰€æœ‰pane
     * @private
     */

  }, {
    key: "_invalidatePane",
    value: function _invalidatePane() {
      var invalidateLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : InvalidateLevel.FULL;

      if (invalidateLevel === InvalidateLevel.OVERLAY) {
        this._xAxisPane.invalidate(invalidateLevel);

        this._panes.forEach(function (pane) {
          pane.invalidate(invalidateLevel);
        });
      } else {
        var shouldMeasureWidth = false;

        this._panes.forEach(function (pane) {
          var should = pane.yAxis().computeAxis();

          if (should) {
            shouldMeasureWidth = should;
          }
        });

        this.adjustPaneViewport(false, shouldMeasureWidth, true);
      }
    }
    /**
     * æµ‹é‡paneé«˜åº¦
     * @private
     */

  }, {
    key: "_measurePaneHeight",
    value: function _measurePaneHeight() {
      var _this3 = this;

      var styleOptions = this._chartStore.styleOptions();

      var paneHeight = this._container.offsetHeight;
      var separatorSize = styleOptions.separator.size;
      var separatorTotalHeight = separatorSize * this._separators.size;

      var xAxisHeight = this._xAxisPane.xAxis().getSelfHeight();

      var paneExcludeXAxisSeparatorHeight = paneHeight - xAxisHeight - separatorTotalHeight;
      var techPaneTotalHeight = 0;

      this._panes.forEach(function (pane) {
        if (pane.id() !== CANDLE_PANE_ID) {
          var _paneHeight = pane.height();

          if (techPaneTotalHeight + _paneHeight > paneExcludeXAxisSeparatorHeight) {
            pane.setHeight(paneExcludeXAxisSeparatorHeight - techPaneTotalHeight);
            techPaneTotalHeight = paneExcludeXAxisSeparatorHeight;
          } else {
            techPaneTotalHeight += _paneHeight;
          }
        }
      });

      var candlePaneHeight = paneExcludeXAxisSeparatorHeight - techPaneTotalHeight;
      var paneContentSize = {};
      paneContentSize[CANDLE_PANE_ID] = {
        contentTop: 0,
        contentBottom: candlePaneHeight
      };
      var contentTop = candlePaneHeight;
      var contentBottom = candlePaneHeight;

      this._panes.get(CANDLE_PANE_ID).setHeight(candlePaneHeight);

      this._chartHeight[CANDLE_PANE_ID] = candlePaneHeight;

      this._panes.forEach(function (pane) {
        if (pane.id() !== CANDLE_PANE_ID) {
          var _paneHeight2 = pane.height();

          contentBottom += _paneHeight2 + separatorSize;
          paneContentSize[pane.id()] = {
            contentTop: contentTop,
            contentBottom: contentBottom
          };
          _this3._chartHeight[pane.id()] = _paneHeight2;
          contentTop = contentBottom;
        }
      });

      this._xAxisPane.setHeight(xAxisHeight);

      this._chartHeight.xAxis = xAxisHeight;
      this._chartHeight.total = paneHeight;

      this._chartEvent.setPaneContentSize(paneContentSize);

      this._chartEvent.setChartContentTopBottom({
        contentTop: 0,
        contentBottom: contentBottom
      });
    }
    /**
     * æµ‹é‡panå®½åº¦
     * @private
     */

  }, {
    key: "_measurePaneWidth",
    value: function _measurePaneWidth() {
      var _this4 = this;

      var styleOptions = this._chartStore.styleOptions();

      var yAxisOptions = styleOptions.yAxis;
      var isYAxisLeft = yAxisOptions.position === YAxisPosition.LEFT;
      var isOutside = !yAxisOptions.inside;
      var paneWidth = this._container.offsetWidth;
      var mainWidth;
      var yAxisWidth = Number.MIN_SAFE_INTEGER;
      var yAxisOffsetLeft;
      var mainOffsetLeft;

      if (isOutside) {
        this._panes.forEach(function (pane) {
          yAxisWidth = Math.max(yAxisWidth, pane.yAxis().getSelfWidth());
        });

        mainWidth = paneWidth - yAxisWidth;

        if (isYAxisLeft) {
          yAxisOffsetLeft = 0;
          mainOffsetLeft = yAxisWidth;
        } else {
          mainOffsetLeft = 0;
          yAxisOffsetLeft = paneWidth - yAxisWidth;
        }
      } else {
        mainWidth = paneWidth;
        yAxisWidth = paneWidth;
        yAxisOffsetLeft = 0;
        mainOffsetLeft = 0;
      }

      this._chartStore.timeScaleStore().setTotalDataSpace(mainWidth);

      this._panes.forEach(function (pane, paneId) {
        pane.setWidth(mainWidth, yAxisWidth);
        pane.setOffsetLeft(mainOffsetLeft, yAxisOffsetLeft);

        var separator = _this4._separators.get(paneId);

        separator && separator.setSize(mainOffsetLeft, mainWidth);
      });

      this._chartWidth = {
        content: mainWidth,
        yAxis: yAxisWidth,
        total: paneWidth
      };

      this._xAxisPane.setWidth(mainWidth, yAxisWidth);

      this._xAxisPane.setOffsetLeft(mainOffsetLeft, yAxisOffsetLeft);

      this._chartEvent.setChartContentLeftRight({
        contentLeft: mainOffsetLeft,
        contentRight: mainOffsetLeft + mainWidth
      });
    }
    /**
     * è°ƒæ•´çª—å£å°ºå¯¸
     * @param shouldMeasureHeight
     * @param shouldMeasureWidth
     * @param shouldLayout
     * @param shouldComputeAxis
     * @param shouldForceComputeAxis
     */

  }, {
    key: "adjustPaneViewport",
    value: function adjustPaneViewport(shouldMeasureHeight, shouldMeasureWidth, shouldLayout, shouldComputeAxis, shouldForceComputeAxis) {
      if (shouldMeasureHeight) {
        this._measurePaneHeight();
      }

      var isAdjust = false;

      if (shouldComputeAxis) {
        this._panes.forEach(function (pane) {
          var adjust = pane.yAxis().computeAxis(shouldForceComputeAxis);

          if (!isAdjust) {
            isAdjust = adjust;
          }
        });
      }

      if (!shouldComputeAxis && shouldMeasureWidth || shouldComputeAxis && isAdjust) {
        this._measurePaneWidth();
      }

      if (shouldLayout) {
        this._xAxisPane.xAxis().computeAxis(true);

        this._xAxisPane.layout();

        this._panes.forEach(function (pane) {
          pane.layout();
        });
      }
    }
    /**
     * çª—å£æ˜¯å¦å­˜åœ¨
     * @param paneId
     * @return {boolean}
     */

  }, {
    key: "hasPane",
    value: function hasPane(paneId) {
      return this._panes.has(paneId);
    }
    /**
     * è·å–çª—å£
     * @param paneId
     * @returns
     */

  }, {
    key: "getPane",
    value: function getPane(paneId) {
      return this._panes.get(paneId);
    }
    /**
     * è·å–å›¾è¡¨ä¸Šçš„æ•°æ®
     * @returns {chartStore}
     */

  }, {
    key: "chartStore",
    value: function chartStore() {
      return this._chartStore;
    }
    /**
     * ç§»é™¤æŒ‡æ ‡
     * @param paneId
     * @param name
     */

  }, {
    key: "removeTechnicalIndicator",
    value: function removeTechnicalIndicator(paneId, name) {
      var _this5 = this;

      var removed = this._chartStore.technicalIndicatorStore().removeInstance(paneId, name);

      if (removed) {
        var shouldMeasureHeight = false;

        if (paneId !== CANDLE_PANE_ID) {
          if (!this._chartStore.technicalIndicatorStore().hasInstance(paneId)) {
            shouldMeasureHeight = true;

            this._panes.get(paneId).destroy();

            var deleteSeparatorTopPaneId = this._separators.get(paneId).topPaneId();

            this._separators.get(paneId).destroy();

            this._panes.delete(paneId);

            this._separators.delete(paneId);

            this._separators.forEach(function (separator) {
              var topPaneId = separator.topPaneId();

              if (!_this5._separators.has(topPaneId)) {
                separator.updatePaneId(deleteSeparatorTopPaneId);
              }
            });
          }
        }

        this.adjustPaneViewport(shouldMeasureHeight, true, true, true, true);
      }
    }
    /**
     * è®¾ç½®æŒ‡æ ‡ç±»å‹
     * @param tech æŠ€æœ¯æŒ‡æ ‡å®ä¾‹
     * @param isStack æ˜¯å¦å åŠ 
     * @param options é…ç½®
     */

  }, {
    key: "createTechnicalIndicator",
    value: function createTechnicalIndicator(tech, isStack) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (this._panes.has(options.id)) {
        var shouldAdjust = false;

        if (this._chartStore.technicalIndicatorStore().addInstance(options.id, tech, isStack)) {
          shouldAdjust = this._panes.get(options.id).yAxis().computeAxis();
        }

        this.setPaneOptions(options, shouldAdjust);
        return options.id;
      }

      var id = options.id || "".concat(TECHNICAL_INDICATOR_PANE_ID_PREFIX).concat(++this._paneBaseId);
      var dragEnabled = isBoolean(options.dragEnabled) ? options.dragEnabled : true;

      this._separators.set(id, new SeparatorPane(this._chartContainer, this._chartStore, Array.from(this._panes.keys()).pop(), id, dragEnabled, {
        startDrag: this._separatorStartDrag.bind(this),
        drag: throttle(this._separatorDrag.bind(this), 50)
      }));

      var pane = new TechnicalIndicatorPane({
        container: this._chartContainer,
        chartStore: this._chartStore,
        xAxis: this._xAxisPane.xAxis(),
        id: id,
        height: options.height || DEFAULT_TECHNICAL_INDICATOR_PANE_HEIGHT
      });

      this._panes.set(id, pane);

      this._chartStore.technicalIndicatorStore().addInstance(id, tech, isStack);

      this.adjustPaneViewport(true, true, true, true, true);
      return id;
    }
    /**
     * åˆ›å»ºå›¾å½¢
     * @param ShapeTemplateClass
     * @param shapeOptions
     * @param paneId
     */

  }, {
    key: "createShape",
    value: function createShape(ShapeTemplateClass, shapeOptions, paneId) {
      var id = shapeOptions.id,
          points = shapeOptions.points,
          styles = shapeOptions.styles,
          lock = shapeOptions.lock,
          data = shapeOptions.data,
          onDrawStart = shapeOptions.onDrawStart,
          onDrawing = shapeOptions.onDrawing,
          onDrawEnd = shapeOptions.onDrawEnd,
          onClick = shapeOptions.onClick,
          onRightClick = shapeOptions.onRightClick,
          onPressedMove = shapeOptions.onPressedMove,
          onMouseEnter = shapeOptions.onMouseEnter,
          onMouseLeave = shapeOptions.onMouseLeave,
          onRemove = shapeOptions.onRemove;
      var shapeId = id || "".concat(SHAPE_ID_PREFIX).concat(++this._shapeBaseId);

      if (!this._chartStore.shapeStore().hasInstance(shapeId)) {
        var yAxis = null;

        if (this.hasPane(paneId)) {
          yAxis = this._panes.get(paneId).yAxis();
        } else {
          if (points && points.length > 0) {
            paneId = CANDLE_PANE_ID;
            yAxis = this._panes.get(CANDLE_PANE_ID).yAxis();
          }
        }

        var shapeInstance = new ShapeTemplateClass({
          id: shapeId,
          chartStore: this._chartStore,
          xAxis: this._xAxisPane.xAxis(),
          yAxis: yAxis,
          points: points,
          styles: styles,
          lock: lock,
          data: data
        });

        if (isFunction(onDrawStart)) {
          onDrawStart({
            id: shapeId
          });
        }

        perfectOverlayFunc(shapeInstance, [{
          key: 'onDrawing',
          fn: onDrawing
        }, {
          key: 'onDrawEnd',
          fn: onDrawEnd
        }, {
          key: 'onClick',
          fn: onClick
        }, {
          key: 'onRightClick',
          fn: onRightClick
        }, {
          key: 'onPressedMove',
          fn: onPressedMove
        }, {
          key: 'onMouseEnter',
          fn: onMouseEnter
        }, {
          key: 'onMouseLeave',
          fn: onMouseLeave
        }, {
          key: 'onRemove',
          fn: onRemove
        }]);

        this._chartStore.shapeStore().addInstance(shapeInstance, paneId);

        return shapeId;
      }

      return null;
    }
    /**
     * åˆ›å»ºæ³¨è§£
     * @param annotations
     * @param paneId
     */

  }, {
    key: "createAnnotation",
    value: function createAnnotation(annotations, paneId) {
      var _this6 = this;

      var instances = [];
      annotations.forEach(function (_ref2) {
        var point = _ref2.point,
            styles = _ref2.styles,
            checkEventCoordinateOnCustomSymbol = _ref2.checkEventCoordinateOnCustomSymbol,
            drawCustomSymbol = _ref2.drawCustomSymbol,
            drawExtend = _ref2.drawExtend,
            onClick = _ref2.onClick,
            onRightClick = _ref2.onRightClick,
            onMouseEnter = _ref2.onMouseEnter,
            onMouseLeave = _ref2.onMouseLeave;

        if (point && point.timestamp) {
          var annotationInstance = new Annotation({
            id: point.timestamp,
            chartStore: _this6._chartStore,
            point: point,
            xAxis: _this6._xAxisPane.xAxis(),
            yAxis: _this6._panes.get(paneId).yAxis(),
            styles: styles
          });
          perfectOverlayFunc(annotationInstance, [{
            key: 'drawExtend',
            fn: drawExtend
          }, {
            key: 'drawCustomSymbol',
            fn: drawCustomSymbol
          }, {
            key: 'checkEventCoordinateOnCustomSymbol',
            fn: checkEventCoordinateOnCustomSymbol
          }, {
            key: 'onClick',
            fn: onClick
          }, {
            key: 'onRightClick',
            fn: onRightClick
          }, {
            key: 'onMouseEnter',
            fn: onMouseEnter
          }, {
            key: 'onMouseLeave',
            fn: onMouseLeave
          }]);
          instances.push(annotationInstance);
        }
      });

      if (instances.length > 0) {
        this._chartStore.annotationStore().add(instances, paneId);
      }
    }
    /**
     * åˆ›å»ºæ ‡ç­¾
     * @param tags
     * @param paneId
     */

  }, {
    key: "createTag",
    value: function createTag(tags, paneId) {
      var _this7 = this;

      var instances = [];
      var shouldUpdate = false;
      var shouldAdd = false;
      tags.forEach(function (_ref3) {
        var id = _ref3.id,
            point = _ref3.point,
            text = _ref3.text,
            mark = _ref3.mark,
            styles = _ref3.styles;

        if (isValid(id)) {
          if (_this7._chartStore.tagStore().has(id, paneId)) {
            var updateSuccess = _this7._chartStore.tagStore().update(id, paneId, {
              point: point,
              text: text,
              mark: mark,
              styles: styles
            });

            if (!shouldUpdate) {
              shouldUpdate = updateSuccess;
            }
          } else {
            shouldAdd = true;
            instances.push(new Tag({
              id: id,
              point: point,
              text: text,
              mark: mark,
              styles: styles,
              chartStore: _this7._chartStore,
              xAxis: _this7._xAxisPane.xAxis(),
              yAxis: _this7._panes.get(paneId).yAxis()
            }));
          }
        }
      });

      if (shouldAdd) {
        this._chartStore.tagStore().add(instances, paneId);
      } else {
        if (shouldUpdate) {
          this._invalidatePane(InvalidateLevel.OVERLAY);
        }
      }
    }
    /**
     * ç§»é™¤æ‰€æœ‰htmlå…ƒç´ 
     */

  }, {
    key: "removeAllHtml",
    value: function removeAllHtml() {
      this._panes.forEach(function (pane) {
        pane.removeHtml();
      });

      this._xAxisPane.removeHtml();
    }
    /**
     * è®¾ç½®çª—ä½“å‚æ•°
     * @param options
     * @param forceShouldAdjust
     */

  }, {
    key: "setPaneOptions",
    value: function setPaneOptions(options, forceShouldAdjust) {
      var shouldAdjust = forceShouldAdjust;
      var shouldMeasureHeight = false;

      if (options.id !== CANDLE_PANE_ID) {
        var pane = this._panes.get(options.id);

        if (pane) {
          if (isNumber(options.height) && options.height > 0 && pane.height() !== options.height) {
            shouldAdjust = true;
            pane.setHeight(options.height);
            shouldMeasureHeight = true;
          }

          if (isBoolean(options.dragEnabled)) {
            this._separators.get(options.id).setDragEnabled(options.dragEnabled);
          }
        }
      }

      if (shouldAdjust) {
        this.adjustPaneViewport(shouldMeasureHeight, true, true, true, true);
      }
    }
    /**
     * è®¾ç½®æ—¶åŒº
     * @param timezone
     */

  }, {
    key: "setTimezone",
    value: function setTimezone(timezone) {
      this._chartStore.timeScaleStore().setTimezone(timezone);

      this._xAxisPane.xAxis().computeAxis(true);

      this._xAxisPane.invalidate(InvalidateLevel.FULL);
    }
    /**
     * å°†å€¼è£…æ¢æˆåƒç´ 
     * @param timestamp
     * @param point
     * @param paneId
     * @param absoluteYAxis
     */

  }, {
    key: "convertToPixel",
    value: function convertToPixel(point, _ref4) {
      var _this8 = this;

      var _ref4$paneId = _ref4.paneId,
          paneId = _ref4$paneId === void 0 ? CANDLE_PANE_ID : _ref4$paneId,
          absoluteYAxis = _ref4.absoluteYAxis;
      var points = [].concat(point);
      var coordinates = [];

      var separatorSize = this._chartStore.styleOptions().separator.size;

      var absoluteTop = 0;

      var panes = this._panes.values();

      var _iterator = _createForOfIteratorHelper(panes),
          _step;

      try {
        var _loop = function _loop() {
          var pane = _step.value;

          if (pane.id() === paneId) {
            coordinates = points.map(function (_ref5) {
              var timestamp = _ref5.timestamp,
                  dataIndex = _ref5.dataIndex,
                  value = _ref5.value;
              var coordinate = {};
              var index = dataIndex;

              if (isValid(timestamp)) {
                index = _this8._chartStore.timeScaleStore().timestampToDataIndex(timestamp);
              }

              if (isValid(index)) {
                coordinate.x = _this8._xAxisPane.xAxis().convertToPixel(index);
              }

              if (isValid(value)) {
                var y = pane.yAxis().convertToPixel(value);
                coordinate.y = absoluteYAxis ? absoluteTop + y : y;
              }

              return coordinate;
            });
            return "break";
          }

          absoluteTop += pane.height() + separatorSize;
        };

        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _ret = _loop();

          if (_ret === "break") break;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return isArray(point) ? coordinates : coordinates[0] || {};
    }
    /**
     * å°†åƒç´ è½¬æ¢æˆå€¼
     * @param coordinate
     * @param paneId
     * @param dataIndexXAxis
     * @param absoluteYAxis
     * @return {{}[]|*[]}
     */

  }, {
    key: "convertFromPixel",
    value: function convertFromPixel(coordinate, _ref6) {
      var _this9 = this;

      var _ref6$paneId = _ref6.paneId,
          paneId = _ref6$paneId === void 0 ? CANDLE_PANE_ID : _ref6$paneId,
          absoluteYAxis = _ref6.absoluteYAxis;
      var coordinates = [].concat(coordinate);
      var points = [];

      var separatorSize = this._chartStore.styleOptions().separator.size;

      var absoluteTop = 0;

      var panes = this._panes.values();

      var _iterator2 = _createForOfIteratorHelper(panes),
          _step2;

      try {
        var _loop2 = function _loop2() {
          var pane = _step2.value;

          if (pane.id() === paneId) {
            points = coordinates.map(function (_ref7) {
              var x = _ref7.x,
                  y = _ref7.y;
              var point = {};

              if (isValid(x)) {
                point.dataIndex = _this9._xAxisPane.xAxis().convertFromPixel(x);
                point.timestamp = _this9._chartStore.timeScaleStore().dataIndexToTimestamp(point.dataIndex);
              }

              if (isValid(y)) {
                var ry = absoluteYAxis ? y - absoluteTop : y;
                point.value = pane.yAxis().convertFromPixel(ry);
              }

              return point;
            });
            return "break";
          }

          absoluteTop += pane.height() + separatorSize;
        };

        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _ret2 = _loop2();

          if (_ret2 === "break") break;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return isArray(coordinate) ? points : points[0] || {};
    }
    /**
     * å›¾è¡¨å®½åº¦
     * @return {*|{}}
     */

  }, {
    key: "chartWidth",
    value: function chartWidth() {
      return this._chartWidth;
    }
    /**
     * å›¾è¡¨é«˜åº¦
     * @return {*|{}}
     */

  }, {
    key: "chartHeight",
    value: function chartHeight() {
      return this._chartHeight;
    }
    /**
     * è·å–å›¾è¡¨è½¬æ¢ä¸ºå›¾ç‰‡åurl
     * @param includeOverlay,
     * @param type
     * @param backgroundColor
     */

  }, {
    key: "getConvertPictureUrl",
    value: function getConvertPictureUrl(includeOverlay, type, backgroundColor) {
      var _this10 = this;

      var width = this._chartContainer.offsetWidth;
      var height = this._chartContainer.offsetHeight;
      var canvas = createElement('canvas', {
        width: "".concat(width, "px"),
        height: "".concat(height, "px"),
        boxSizing: 'border-box'
      });
      var ctx = canvas.getContext('2d');
      var pixelRatio = getPixelRatio(canvas);
      canvas.width = width * pixelRatio;
      canvas.height = height * pixelRatio;
      ctx.scale(pixelRatio, pixelRatio);
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(0, 0, width, height);
      var offsetTop = 0;

      this._panes.forEach(function (pane, paneId) {
        if (paneId !== CANDLE_PANE_ID) {
          var separator = _this10._separators.get(paneId);

          ctx.drawImage(separator.getImage(), 0, offsetTop, width, separator.height());
          offsetTop += separator.height();
        }

        ctx.drawImage(pane.getImage(includeOverlay), 0, offsetTop, width, pane.height());
        offsetTop += pane.height();
      });

      ctx.drawImage(this._xAxisPane.getImage(includeOverlay), 0, offsetTop, width, this._xAxisPane.height());
      return canvas.toDataURL("image/".concat(type));
    }
    /**
     * é”€æ¯
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._panes.forEach(function (pane) {
        pane.destroy();
      });

      this._separators.forEach(function (pane) {
        pane.destroy();
      });

      this._panes.clear();

      this._separators.clear();

      this._xAxisPane.destroy();

      this._container.removeChild(this._chartContainer);

      this._chartEvent.destroy();
    }
  }]);

  return ChartPane;
}();

var Chart = /*#__PURE__*/function () {
  function Chart(container, styleOptions) {
    _classCallCheck(this, Chart);

    this._chartPane = new ChartPane(container, styleOptions);
  }
  /**
   * è·å–å®½å°ºå¯¸
   * @return {*|{}}
   */


  _createClass(Chart, [{
    key: "getWidth",
    value: function getWidth() {
      return this._chartPane.chartWidth();
    }
    /**
     * è·å–é«˜åº¦å°ºå¯¸
     * @return {*|{}}
     */

  }, {
    key: "getHeight",
    value: function getHeight() {
      return this._chartPane.chartHeight();
    }
    /**
     * è®¾ç½®æ ·å¼é…ç½®
     * @param options é…ç½®
     */

  }, {
    key: "setStyleOptions",
    value: function setStyleOptions(options) {
      if (!isObject(options)) {
        logWarn('setStyleOptions', 'options');
        return;
      }

      this._chartPane.chartStore().applyStyleOptions(options);

      this._chartPane.adjustPaneViewport(true, true, true, true, true);
    }
    /**
     * è·å–æ ·å¼é…ç½®
     * @returns {[]|*[]}
     */

  }, {
    key: "getStyleOptions",
    value: function getStyleOptions() {
      return clone(this._chartPane.chartStore().styleOptions());
    }
    /**
     * è®¾ç½®ä»·æ ¼æ•°é‡ç²¾åº¦
     * @param pricePrecision ä»·æ ¼ç²¾åº¦
     * @param volumePrecision æ•°é‡ç²¾åº¦
     */

  }, {
    key: "setPriceVolumePrecision",
    value: function setPriceVolumePrecision(pricePrecision, volumePrecision) {
      if (!isNumber(pricePrecision) || pricePrecision < 0) {
        logWarn('setPriceVolumePrecision', 'pricePrecision', 'pricePrecision must be a number and greater than zero!!!');
        return;
      }

      if (!isNumber(volumePrecision) || volumePrecision < 0) {
        logWarn('setPriceVolumePrecision', 'volumePrecision', 'volumePrecision must be a number and greater than zero!!!');
        return;
      }

      this._chartPane.chartStore().setPriceVolumePrecision(pricePrecision, volumePrecision);
    }
    /**
     * è®¾ç½®æ—¶åŒº
     * @param timezone æ—¶åŒº
     */

  }, {
    key: "setTimezone",
    value: function setTimezone(timezone) {
      this._chartPane.setTimezone(timezone);
    }
    /**
     * è·å–å½“å‰æ—¶åŒº
     */

  }, {
    key: "getTimezone",
    value: function getTimezone() {
      return this._chartPane.chartStore().timeScaleStore().timezone();
    }
    /**
     * é‡ç½®å°ºå¯¸ï¼Œæ€»æ˜¯ä¼šå¡«å……çˆ¶å®¹å™¨
     */

  }, {
    key: "resize",
    value: function resize() {
      this._chartPane.adjustPaneViewport(true, true, true, true, true);
    }
    /**
     * è®¾ç½®å³è¾¹é—´è·
     * @param space ç©ºé—´å¤§å°
     */

  }, {
    key: "setOffsetRightSpace",
    value: function setOffsetRightSpace(space) {
      if (!isNumber(space)) {
        logWarn('setOffsetRightSpace', 'space', 'space must be a number!!!');
        return;
      }

      this._chartPane.chartStore().timeScaleStore().setOffsetRightSpace(space, true);
    }
    /**
     * è®¾ç½®å·¦è¾¹å¯è§çš„æœ€å°baræ•°é‡
     * @param barCount baræ•°é‡
     */

  }, {
    key: "setLeftMinVisibleBarCount",
    value: function setLeftMinVisibleBarCount(barCount) {
      if (!isNumber(barCount) || barCount <= 0) {
        logWarn('setLeftMinVisibleBarCount', 'barCount', 'barCount must be a number and greater than zero!!!');
        return;
      }

      this._chartPane.chartStore().timeScaleStore().setLeftMinVisibleBarCount(Math.ceil(barCount));
    }
    /**
     * è®¾ç½®å³è¾¹å¯è§çš„æœ€å°baræ•°é‡
     * @param barCount baræ•°é‡
     */

  }, {
    key: "setRightMinVisibleBarCount",
    value: function setRightMinVisibleBarCount(barCount) {
      if (!isNumber(barCount) || barCount <= 0) {
        logWarn('setRightMinVisibleBarCount', 'barCount', 'barCount must be a number and greater than zero!!!');
        return;
      }

      this._chartPane.chartStore().timeScaleStore().setRightMinVisibleBarCount(Math.ceil(barCount));
    }
    /**
     * è®¾ç½®ä¸€æ¡æ•°æ®çš„ç©ºé—´
     * @param space ç©ºé—´å¤§å°
     */

  }, {
    key: "setDataSpace",
    value: function setDataSpace(space) {
      if (!isNumber(space)) {
        logWarn('setDataSpace', 'space', 'space must be a number!!!');
        return;
      }

      this._chartPane.chartStore().timeScaleStore().setDataSpace(space);
    }
    /**
     * è·å–å•æ¡æ•°æ®çš„ç©ºé—´
     * @returns
     */

  }, {
    key: "getDataSpace",
    value: function getDataSpace() {
      return this._chartPane.chartStore().timeScaleStore().dataSpace();
    }
    /**
     * è·å–å•æ¡æ•°æ®ç»˜åˆ¶çš„ç©ºé—´
     * @returns
     */

  }, {
    key: "getBarSpace",
    value: function getBarSpace() {
      return this._chartPane.chartStore().timeScaleStore().barSpace();
    }
    /**
     * æ¸…ç©ºæ•°æ®
     */

  }, {
    key: "clearData",
    value: function clearData() {
      this._chartPane.chartStore().clearDataList();
    }
    /**
     * è·å–æ•°æ®æº
     */

  }, {
    key: "getDataList",
    value: function getDataList() {
      return this._chartPane.chartStore().dataList();
    }
    /**
     * æ·»åŠ æ–°æ•°æ®
     * @param dataList kçº¿æ•°æ®æ•°ç»„
     * @param more æ˜¯å¦è¿˜æœ‰æ›´å¤šæ ‡è¯†
     */

  }, {
    key: "applyNewData",
    value: function applyNewData(dataList, more) {
      var _this = this;

      if (!isArray(dataList)) {
        logWarn('applyNewData', 'dataList', 'dataList must be an array!!!');
        return;
      }

      var chartStore = this._chartPane.chartStore();

      chartStore.clearDataList();
      chartStore.addData(dataList, 0, more);
      Promise.resolve(chartStore.technicalIndicatorStore().calcInstance()).finally(function (_) {
        _this._chartPane.adjustPaneViewport(false, true, true, true);
      });
    }
    /**
     * æ·»åŠ å†å²æ›´å¤šæ•°æ®
     * @param dataList kçº¿æ•°æ®æ•°ç»„
     * @param more æ˜¯å¦è¿˜æœ‰æ›´å¤šæ ‡è¯†
     */

  }, {
    key: "applyMoreData",
    value: function applyMoreData(dataList, more) {
      var _this2 = this;

      if (!isArray(dataList)) {
        logWarn('applyMoreData', 'dataList', 'dataList must be an array!!!');
        return;
      }

      var chartStore = this._chartPane.chartStore();

      chartStore.addData(dataList, 0, more);
      Promise.resolve(chartStore.technicalIndicatorStore().calcInstance()).finally(function (_) {
        _this2._chartPane.adjustPaneViewport(false, true, true, true);
      });
    }
    /**
     * æ›´æ–°æ•°æ®
     * @param data æ–°çš„kçº¿æ•°æ®
     */

  }, {
    key: "updateData",
    value: function updateData(data) {
      var _this3 = this;

      if (!isObject(data) || isArray(data)) {
        logWarn('updateData', 'data', 'data must be an object!!!');
        return;
      }

      var chartStore = this._chartPane.chartStore();

      var dataList = chartStore.dataList();
      var dataSize = dataList.length; // è¿™é‡Œåˆ¤æ–­å•ä¸ªæ•°æ®åº”è¯¥æ·»åŠ åˆ°å“ªä¸ªä½ç½®

      var timestamp = formatValue(data, 'timestamp', 0);
      var lastDataTimestamp = formatValue(dataList[dataSize - 1], 'timestamp', 0);

      if (timestamp >= lastDataTimestamp) {
        var pos = dataSize;

        if (timestamp === lastDataTimestamp) {
          pos = dataSize - 1;
        }

        chartStore.addData(data, pos);
        Promise.resolve(chartStore.technicalIndicatorStore().calcInstance()).finally(function (_) {
          _this3._chartPane.adjustPaneViewport(false, true, true, true);
        });
      }
    }
    /**
     * è®¾ç½®åŠ è½½æ›´å¤šå›è°ƒ
     * @param cb å›è°ƒæ–¹æ³•
     */

  }, {
    key: "loadMore",
    value: function loadMore(cb) {
      if (!isFunction(cb)) {
        logWarn('loadMore', 'cb', 'cb must be a function!!!');
        return;
      }

      this._chartPane.chartStore().timeScaleStore().setLoadMoreCallback(cb);
    }
    /**
     * åˆ›å»ºä¸€ä¸ªæŠ€æœ¯æŒ‡æ ‡
     * @param value æŒ‡æ ‡åæˆ–è€…æŒ‡æ ‡
     * @param isStack æ˜¯å¦è¦†ç›–
     * @param paneOptions çª—å£é…ç½®
     * @returns {string|null}
     */

  }, {
    key: "createTechnicalIndicator",
    value: function createTechnicalIndicator(value, isStack, paneOptions) {
      if (!isValid(value)) {
        logWarn('createTechnicalIndicator', 'value', 'value is invalid!!!');
        return null;
      }

      var tech = isObject(value) && !isArray(value) ? value : {
        name: value
      };

      if (!this._chartPane.chartStore().technicalIndicatorStore().hasTemplate(tech.name)) {
        logWarn('createTechnicalIndicator', 'value', 'can not find the corresponding technical indicator!!!');
        return null;
      }

      return this._chartPane.createTechnicalIndicator(tech, isStack, paneOptions);
    }
    /**
     * æ·»åŠ æŠ€æœ¯æŒ‡æ ‡æ¨¡æ¿
     * @param template æŒ‡æ ‡æ¨¡æ¿
     */

  }, {
    key: "addTechnicalIndicatorTemplate",
    value: function addTechnicalIndicatorTemplate(template) {
      if (!isObject(template)) {
        logWarn('addTechnicalIndicatorTemplate', 'template', 'template must be an object or array!!!');
        return;
      }

      var templates = [].concat(template);

      this._chartPane.chartStore().technicalIndicatorStore().addTemplate(templates);
    }
    /**
     * è¦†ç›–æŠ€æœ¯æŒ‡æ ‡
     * @param override è¦†ç›–å‚æ•°
     * @param paneId çª—å£id
     */

  }, {
    key: "overrideTechnicalIndicator",
    value: function overrideTechnicalIndicator(techOverride, paneId) {
      var _this4 = this;

      if (!isObject(techOverride) || isArray(techOverride)) {
        logWarn('overrideTechnicalIndicator', 'overrideTech', 'overrideTech must be an object!!!');
        return;
      }

      var promise = this._chartPane.chartStore().technicalIndicatorStore().override(techOverride, paneId);

      if (promise) {
        promise.then(function (_) {
          _this4._chartPane.adjustPaneViewport(false, true, true, true);
        });
      }
    }
    /**
     * è·å–æŠ€æœ¯æŒ‡æ ‡åå­—è·å–æŠ€æœ¯æŒ‡æ ‡
     * @param name æŒ‡æ ‡å
     * @return {{}}
     */

  }, {
    key: "getTechnicalIndicatorTemplate",
    value: function getTechnicalIndicatorTemplate(name) {
      return this._chartPane.chartStore().technicalIndicatorStore().getTemplateInfo(name);
    }
    /**
      * è·å–çª—å£ä¸Šçš„æŠ€æœ¯æŒ‡æ ‡
      * @param paneId çª—å£id
      * @param name æŒ‡æ ‡å
      * @return {{}}
      */

  }, {
    key: "getTechnicalIndicatorByPaneId",
    value: function getTechnicalIndicatorByPaneId(paneId, name) {
      return this._chartPane.chartStore().technicalIndicatorStore().getInstanceInfo(paneId, name);
    }
    /**
     * ç§»é™¤ä¸€ä¸ªæŠ€æœ¯æŒ‡æ ‡
     * @param paneId çª—å£id
     * @param name æŒ‡æ ‡å
     */

  }, {
    key: "removeTechnicalIndicator",
    value: function removeTechnicalIndicator(paneId, name) {
      this._chartPane.removeTechnicalIndicator(paneId, name);
    }
    /**
     * æ·»åŠ å›¾å½¢æ¨¡æ¿
     * @param template å›¾å½¢æ¨¡æ¿
     */

  }, {
    key: "addShapeTemplate",
    value: function addShapeTemplate(template) {
      if (!isObject(template)) {
        logWarn('addShapeTemplate', 'template', 'template must be an object or array!!!');
        return;
      }

      var templates = [].concat(template);

      this._chartPane.chartStore().shapeStore().addTemplate(templates);
    }
    /**
     * åˆ›å»ºå›¾å½¢
     * @param value å›¾å½¢åæˆ–è€…å›¾å½¢é…ç½®
     * @param paneId çª—å£id
     */

  }, {
    key: "createShape",
    value: function createShape(value, paneId) {
      if (!isValid(value)) {
        logWarn('createShape', 'value', 'value is invalid!!!');
        return null;
      }

      var shapeOptions = isObject(value) && !isArray(value) ? value : {
        name: value
      };

      var Shape = this._chartPane.chartStore().shapeStore().getTemplate(shapeOptions.name);

      if (!Shape) {
        logWarn('createShape', 'value', 'can not find the corresponding shape!!!');
        return null;
      }

      var id = this._chartPane.createShape(Shape, shapeOptions, paneId);

      if (!id) {
        logWarn('createShape', 'options.id', 'duplicate id!!!');
      }

      return id;
    }
    /**
     * è·å–å›¾å½¢æ ‡è®°
     * @param shapeId å›¾å½¢æ ‡è®°id
     * @return {{name, lock: *, styles, id, points: (*|*[])}[]|{name, lock: *, styles, id, points: (*|*[])}}
     */

  }, {
    key: "getShape",
    value: function getShape(shapeId) {
      return this._chartPane.chartStore().shapeStore().getInstanceInfo(shapeId);
    }
    /**
     * è®¾ç½®å›¾å½¢æ ‡è®°é…ç½®
     * @param options å›¾å½¢æ ‡è®°é…ç½®
     */

  }, {
    key: "setShapeOptions",
    value: function setShapeOptions(options) {
      if (!isObject(options) || isArray(options)) {
        logWarn('setShapeOptions', 'options', 'options must be an object!!!');
        return;
      }

      this._chartPane.chartStore().shapeStore().setInstanceOptions(options);
    }
    /**
     * ç§»é™¤å›¾å½¢
     * @param shapeId å›¾å½¢id
     */

  }, {
    key: "removeShape",
    value: function removeShape(shapeId) {
      this._chartPane.chartStore().shapeStore().removeInstance(shapeId);
    }
    /**
     * åˆ›å»ºæ³¨è§£
     * @param annotation å•ä¸ªæ³¨è§£æˆ–è€…æ³¨è§£æ•°ç»„
     * @param paneId çª—å£id
     */

  }, {
    key: "createAnnotation",
    value: function createAnnotation(annotation) {
      var paneId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CANDLE_PANE_ID;

      if (!isObject(annotation)) {
        logWarn('createAnnotation', 'annotation', 'annotation must be an object or array!!!');
        return;
      }

      if (!this._chartPane.hasPane(paneId)) {
        logWarn('createAnnotation', 'paneId', 'can not find the corresponding pane!!!');
        return;
      }

      var annotations = [].concat(annotation);

      this._chartPane.createAnnotation(annotations, paneId);
    }
    /**
     * ç§»é™¤æ³¨è§£
     * @param paneId çª—å£id
     * @param points å•ä¸ªç‚¹æˆ–è€…ç‚¹æ•°ç»„
     */

  }, {
    key: "removeAnnotation",
    value: function removeAnnotation(paneId, points) {
      this._chartPane.chartStore().annotationStore().remove(paneId, points);
    }
    /**
     * åˆ›å»ºæ ‡ç­¾
     * @param tag å•ä¸ªæ ‡ç­¾æˆ–è€…æ ‡ç­¾æ•°ç»„
     * @param paneId çª—å£id
     */

  }, {
    key: "createTag",
    value: function createTag(tag) {
      var paneId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CANDLE_PANE_ID;

      if (!isObject(tag)) {
        logWarn('createTag', 'tag', 'tag must be an object or array!!!');
        return;
      }

      if (!this._chartPane.hasPane(paneId)) {
        logWarn('createTag', 'paneId', 'can not find the corresponding pane!!!');
        return;
      }

      var tags = [].concat(tag);

      this._chartPane.createTag(tags, paneId);
    }
    /**
     * ç§»é™¤æ ‡ç­¾
     * @param paneId çª—å£id
     * @param tagId æ ‡ç­¾id
     */

  }, {
    key: "removeTag",
    value: function removeTag(paneId, tagId) {
      this._chartPane.chartStore().tagStore().remove(paneId, tagId);
    }
    /**
     * åˆ›å»ºhtmlå…ƒç´ 
     * @param html
     * @param paneId
     * @returns
     */

  }, {
    key: "createHtml",
    value: function createHtml(html) {
      var paneId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CANDLE_PANE_ID;

      if (!isObject(html)) {
        logWarn('createHtml', 'html', 'options must be an object!!!');
        return null;
      }

      if (!isString(html.content) && !(html.content instanceof HTMLElement)) {
        logWarn('createHtml', 'html.content', 'invalid html.content!!!');
        return null;
      }

      var pane = this._chartPane.getPane(paneId);

      if (!pane) {
        logWarn('createHtml', 'paneId', 'can not find the corresponding pane!!!');
        return null;
      }

      return pane.createHtml(html);
    }
    /**
     * ç§»é™¤htmlå…ƒç´ 
     * @param paneId
     * @param htmlId
     */

  }, {
    key: "removeHtml",
    value: function removeHtml(paneId, htmlId) {
      if (paneId) {
        var pane = this._chartPane.getPane(paneId);

        pane && pane.removeHtml(htmlId);
      } else {
        this._chartPane.removeAllHtml();
      }
    }
    /**
     * è®¾ç½®çª—å£å±æ€§
     * @param options çª—å£é…ç½®
     */

  }, {
    key: "setPaneOptions",
    value: function setPaneOptions(options) {
      if (!isObject(options)) {
        logWarn('setPaneOptions', 'options', 'options must be an object!!!');
        return;
      }

      this._chartPane.setPaneOptions(options, false);
    }
    /**
     * è®¾ç½®æ˜¯å¦å¯ä»¥ç¼©æ”¾
     * @param enabled æ ‡è¯†
     */

  }, {
    key: "setZoomEnabled",
    value: function setZoomEnabled(enabled) {
      this._chartPane.chartStore().timeScaleStore().setZoomEnabled(enabled);
    }
    /**
     * æ˜¯å¦å¯ä»¥ç¼©æ”¾
     * @return {boolean}
     */

  }, {
    key: "isZoomEnabled",
    value: function isZoomEnabled() {
      return this._chartPane.chartStore().timeScaleStore().zoomEnabled();
    }
    /**
     * è®¾ç½®æ˜¯å¦å¯ä»¥æ‹–æ‹½æ»šåŠ¨
     * @param enabled æ ‡è¯†
     */

  }, {
    key: "setScrollEnabled",
    value: function setScrollEnabled(enabled) {
      this._chartPane.chartStore().timeScaleStore().setScrollEnabled(enabled);
    }
    /**
     * æ˜¯å¦å¯ä»¥æ‹–æ‹½æ»šåŠ¨
     * @return {boolean}
     */

  }, {
    key: "isScrollEnabled",
    value: function isScrollEnabled() {
      return this._chartPane.chartStore().timeScaleStore().scrollEnabled();
    }
    /**
     * æŒ‰è·ç¦»æ»šåŠ¨
     * @param distance è·ç¦»
     * @param animationDuration åŠ¨ç”»æŒç»­æ—¶é—´
     */

  }, {
    key: "scrollByDistance",
    value: function scrollByDistance(distance, animationDuration) {
      var _this5 = this;

      if (!isNumber(distance)) {
        logWarn('scrollByDistance', 'distance', 'distance must be a number!!!');
        return;
      }

      if (isNumber(animationDuration) && animationDuration > 0) {
        this._chartPane.chartStore().timeScaleStore().startScroll();

        var startTime = new Date().getTime();

        var animation = function animation() {
          var progress = (new Date().getTime() - startTime) / animationDuration;
          var finished = progress >= 1;
          var dis = finished ? distance : distance * progress;

          _this5._chartPane.chartStore().timeScaleStore().scroll(dis);

          if (!finished) {
            requestAnimationFrame(animation);
          }
        };

        animation();
      } else {
        this._chartPane.chartStore().timeScaleStore().startScroll();

        this._chartPane.chartStore().timeScaleStore().scroll(distance);
      }
    }
    /**
     * æ»šåŠ¨åˆ°å®æ—¶ä½ç½®
     * @param animationDuration åŠ¨ç”»æŒç»­æ—¶é—´
     */

  }, {
    key: "scrollToRealTime",
    value: function scrollToRealTime(animationDuration) {
      var difBarCount = this._chartPane.chartStore().timeScaleStore().offsetRightBarCount() - this._chartPane.chartStore().timeScaleStore().offsetRightSpace() / this._chartPane.chartStore().timeScaleStore().dataSpace();

      var distance = difBarCount * this._chartPane.chartStore().timeScaleStore().dataSpace();

      this.scrollByDistance(distance, animationDuration);
    }
    /**
     * æ»šåŠ¨åˆ°æŒ‡å®šçš„æ•°æ®ç´¢å¼•
     * @param dataIndex æ•°æ®ç´¢å¼•
     * @param animationDuration åŠ¨ç”»æŒç»­æ—¶é—´
     */

  }, {
    key: "scrollToDataIndex",
    value: function scrollToDataIndex(dataIndex, animationDuration) {
      if (!isNumber(dataIndex)) {
        logWarn('scrollToDataIndex', 'dataIndex', 'dataIndex must be a number!!!');
        return;
      }

      var distance = (this._chartPane.chartStore().dataList().length - 1 - dataIndex) * this._chartPane.chartStore().timeScaleStore().dataSpace();

      this.scrollByDistance(distance, animationDuration);
    }
    /**
     * åœ¨æŸä¸ªåæ ‡ç‚¹ç¼©æ”¾
     * @param scale ç¼©æ”¾æ¯”ä¾‹
     * @param coordinate åæ ‡ç‚¹
     * @param animationDuration åŠ¨ç”»æŒç»­æ—¶é—´
     */

  }, {
    key: "zoomAtCoordinate",
    value: function zoomAtCoordinate(scale, coordinate, animationDuration) {
      var _this6 = this;

      if (!isNumber(scale)) {
        logWarn('zoomAtCoordinate', 'scale', 'scale must be a number!!!');
        return;
      }

      if (isNumber(animationDuration) && animationDuration > 0) {
        var dataSpace = this._chartPane.chartStore().timeScaleStore().dataSpace();

        var scaleDataSpace = dataSpace * scale;
        var difSpace = scaleDataSpace - dataSpace;
        var startTime = new Date().getTime();

        var animation = function animation() {
          var progress = (new Date().getTime() - startTime) / animationDuration;
          var finished = progress >= 1;
          var progressDataSpace = finished ? difSpace : difSpace * progress;

          _this6._chartPane.chartStore().timeScaleStore().zoom(progressDataSpace / dataSpace, coordinate);

          if (!finished) {
            requestAnimationFrame(animation);
          }
        };

        animation();
      } else {
        this._chartPane.chartStore().timeScaleStore().zoom(scale, coordinate);
      }
    }
    /**
     * åœ¨æŸä¸ªæ•°æ®ç´¢å¼•ç¼©æ”¾
     * @param scale ç¼©æ”¾æ¯”ä¾‹
     * @param dataIndex ç´¢å¼•ä½ç½®
     * @param animationDuration åŠ¨ç”»æŒç»­æ—¶é—´
     */

  }, {
    key: "zoomAtDataIndex",
    value: function zoomAtDataIndex(scale, dataIndex, animationDuration) {
      if (!isNumber(scale)) {
        logWarn('zoomAtDataIndex', 'scale', 'scale must be a number!!!');
        return;
      }

      if (!isNumber(dataIndex)) {
        logWarn('zoomAtDataIndex', 'dataIndex', 'dataIndex must be a number!!!');
        return;
      }

      var x = this._chartPane.chartStore().timeScaleStore().dataIndexToCoordinate(dataIndex);

      this.zoomAtCoordinate(scale, {
        x: x
      }, animationDuration);
    }
    /**
     * å°†å€¼è£…æ¢æˆåƒç´ 
     * @param point å•ä¸ªç‚¹æˆ–è€…ç‚¹é›†åˆ
     * @param finder è¿‡æ»¤æ¡ä»¶
     */

  }, {
    key: "convertToPixel",
    value: function convertToPixel(point, finder) {
      return this._chartPane.convertToPixel(point, finder);
    }
    /**
     * å°†åƒç´ è½¬æ¢æˆå€¼
     * @param coordinate å•ä¸ªåæ ‡æˆ–è€…åæ ‡é›†åˆ
     * @param finder è¿‡æ»¤æ¡ä»¶
     */

  }, {
    key: "convertFromPixel",
    value: function convertFromPixel(coordinate, finder) {
      return this._chartPane.convertFromPixel(coordinate, finder);
    }
    /**
     * è®¢é˜…å›¾è¡¨åŠ¨ä½œ
     * @param type åŠ¨ä½œç±»å‹
     * @param callback å›è°ƒæ–¹æ³•
     */

  }, {
    key: "subscribeAction",
    value: function subscribeAction(type, callback) {
      if (!this._chartPane.chartStore().actionStore().subscribe(type, callback)) {
        logWarn('subscribeAction', 'type', 'type does not exist!!!');
      }
    }
    /**
     * å–æ¶ˆè®¢é˜…å›¾è¡¨åŠ¨ä½œ
     * @param type åŠ¨ä½œç±»å‹
     * @param callback å›è°ƒæ–¹æ³•
     */

  }, {
    key: "unsubscribeAction",
    value: function unsubscribeAction(type, callback) {
      if (!this._chartPane.chartStore().actionStore().unsubscribe(type, callback)) {
        logWarn('unsubscribeAction', 'type', 'type does not exist!!!');
      }
    }
    /**
     * è·å–å°†å›¾è¡¨è£…æ¢æˆå›¾ç‰‡åçš„url
     * @param includeOverlay æ˜¯å¦åŒ…å«è¦†ç›–å±‚
     * @param type å›¾ç‰‡ç±»å‹
     * @param backgroundColor èƒŒæ™¯è‰²
     */

  }, {
    key: "getConvertPictureUrl",
    value: function getConvertPictureUrl(includeOverlay) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'jpeg';
      var backgroundColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#FFFFFF';

      if (type !== 'png' && type !== 'jpeg' && type !== 'bmp') {
        logWarn('getConvertPictureUrl', 'type', 'type only supports jpeg, png and bmp!!!');
        return;
      }

      return this._chartPane.getConvertPictureUrl(includeOverlay, type, backgroundColor);
    }
    /**
     * é”€æ¯
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._chartPane.destroy();
    }
  }]);

  return Chart;
}();

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var instances = {};
var chartBaseId = 1;
var CHART_NAME_PREFIX = 'k_line_chart_';
/**
 * è·å–ç‰ˆæœ¬å·
 * @returns {string}
 */

function version() {
  return '8.2.0';
}
/**
 * åˆå§‹åŒ–
 * @param ds
 * @param style
 * @returns {Chart}
 */


function init(ds) {
  var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  logTag();
  var errorMessage = 'The chart cannot be initialized correctly. Please check the parameters. The chart container cannot be null and child elements need to be added!!!';
  var dom;

  if (!ds) {
    logError('', '', errorMessage);
    return null;
  }

  if (isString(ds)) {
    dom = document.getElementById(ds);
  } else {
    dom = ds;
  }

  if (!dom) {
    logError('', '', errorMessage);
    return null;
  }

  var chart = instances[dom.chartId || ''];

  if (chart) {
    // logWarn('', '', 'The chart has been initialized on the domï¼ï¼ï¼');
    return chart;
  }

  var id = "".concat(CHART_NAME_PREFIX).concat(chartBaseId++);
  chart = new Chart(dom, style);
  chart.id = id;
  dom.chartId = id;
  instances[id] = chart;
  return chart;
}
/**
 * é”€æ¯
 * @param dcs
 */


function dispose(dcs) {
  if (dcs) {
    var id;

    if (isString(dcs)) {
      var dom = document.getElementById(dcs);
      id = dom && dom.chartId;
    } else if (dcs instanceof Chart) {
      id = dcs.id;
    } else {
      id = dcs && dcs.chartId;
    }

    if (id) {
      instances[id].destroy();
      delete instances[id];
    }
  }
}

exports.dispose = dispose;
exports.extension = extension;
exports.init = init;
exports.version = version;

Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=klinecharts.simple.js.map
